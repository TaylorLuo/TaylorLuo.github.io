<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Taylor</title>
  
  <subtitle>老罗</subtitle>
  <link href="https://taylorluo.github.io/atom.xml" rel="self"/>
  
  <link href="https://taylorluo.github.io/"/>
  <updated>2023-06-13T23:32:43.044Z</updated>
  <id>https://taylorluo.github.io/</id>
  
  <author>
    <name>Taylor Luo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://taylorluo.github.io/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/"/>
    <id>https://taylorluo.github.io/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/</id>
    <published>2023-06-13T23:32:43.044Z</published>
    <updated>2023-06-13T23:32:43.044Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式专题-15、链路追踪</title>
    <link href="https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.690Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Open-Tracing"><a href="#1-Open-Tracing" class="headerlink" title="1. Open Tracing"></a>1. Open Tracing</h1><h1 id="2-Skywalking"><a href="#2-Skywalking" class="headerlink" title="2. Skywalking"></a>2. Skywalking</h1><h2 id="2-1-ELK-Skywalking"><a href="#2-1-ELK-Skywalking" class="headerlink" title="2.1. ELK+Skywalking"></a>2.1. ELK+Skywalking</h2><p><a href="https://juejin.cn/post/7012877514787799071#comment">https://juejin.cn/post/7012877514787799071#comment</a></p><p><a href="https://bbs.huaweicloud.com/blogs/273943">https://bbs.huaweicloud.com/blogs/273943</a></p><p><a href="https://zhengjianfeng.cn/?p=578">https://zhengjianfeng.cn/?p=578</a></p><h2 id="2-2-skywalking-VS-Sleuth-ZipKin"><a href="#2-2-skywalking-VS-Sleuth-ZipKin" class="headerlink" title="2.2. skywalking VS Sleuth+ZipKin"></a>2.2. skywalking VS Sleuth+ZipKin</h2><p><a href="https://www.cnblogs.com/cbvlog/p/15770726.html">https://www.cnblogs.com/cbvlog/p/15770726.html</a></p><h1 id="3-Zipkin"><a href="#3-Zipkin" class="headerlink" title="3. Zipkin"></a>3. Zipkin</h1><p>官方网址： <a href="https://zipkin.io/pages/quickstart.html">https://zipkin.io/pages/quickstart.html</a></p><p>参考项目： <a href="https://www.cnblogs.com/lori/p/11113665.html">https://www.cnblogs.com/lori/p/11113665.html</a> 对应 13</p><p>​                   <a href="https://segmentfault.com/a/1190000020946622?utm_source=tag-newest">https://segmentfault.com/a/1190000020946622?utm_source=tag-newest</a></p><p>本地目录：D:\StudyWorkSpace\SpringCloudLearning\13</p><p>原文链接：<a href="https://blog.csdn.net/liuminglei1987/article/details/104004884">https://blog.csdn.net/liuminglei1987/article/details/104004884</a></p><h2 id="3-1-故事"><a href="#3-1-故事" class="headerlink" title="3.1. 故事"></a>3.1. 故事</h2><blockquote><p>在微服务架构中，必须实现分布式链路追踪，来记录一个请求到底有哪些服务参与，顺序又是怎样，达到每个请求的细节都清晰可见，出了问题，快速定位。</p><p>Google 开源了 Dapper 链路追踪组件，并在 2010 年发表了论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这篇文章是业内实现链路追踪的标杆和理论基础，具有非常大的参考价值。</p><p>目前，链路追踪组件有 Google 的 Dapper，Twitter 的 Zipkin，以及阿里的 Eagleeye （鹰眼）等，都是非常优秀的链路追踪开源组件。</p><p>其中，Twitter 的 Zipkin 是基于 google 的分布式监控系统 Dapper（论文）的开源实现，zipkin 用于追踪分布式服务之间的应用数据链路，分析处理延时，帮助我们改进系统的性能和定位故障。</p></blockquote><h2 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2. 安装"></a>3.2. 安装</h2><p>Zipkin Server</p><p><strong>注意事项</strong>：Spring Cloud 从 F 版本开始，已经无需开发者自行构建 Zipkin Server 了，只需下载 jar 运行即可。下载地址为：</p><p><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/%E3%80%82">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/。</a></p><p>Docker 方式安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker run -d -p 9411:9411 openzipkin/zipkin --network microintegration<br></code></pre></td></tr></table></figure><p>验证 test.sxd.com:9411&#x2F;zipkin&#x2F;</p><h2 id="3-3-工程配置"><a href="#3-3-工程配置" class="headerlink" title="3.3. 工程配置"></a>3.3. 工程配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;!--链路追踪start--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--链路追踪end--&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-增加配置"><a href="#3-4-增加配置" class="headerlink" title="3.4. 增加配置"></a>3.4. 增加配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">spring:<br>  zipkin:<br>    base-url: http://192.168.1.212:9411/<br>  sleuth:<br>    sampler:<br>      probability: 1.0<br></code></pre></td></tr></table></figure><h2 id="3-5-Imarket-实施"><a href="#3-5-Imarket-实施" class="headerlink" title="3.5. Imarket 实施"></a>3.5. Imarket 实施</h2><p>链路搜索</p><p><img src="/upload/image-20200716175011876.png" alt="image-20200716175011876"></p><p>链路结构</p><p><img src="/upload/image-20200716174947715.png" alt="image-20200716174947715"></p><h1 id="4-Cat"><a href="#4-Cat" class="headerlink" title="4. Cat"></a>4. Cat</h1><p>有代码侵入性</p><h1 id="5-参考与感谢"><a href="#5-参考与感谢" class="headerlink" title="5. 参考与感谢"></a>5. 参考与感谢</h1><h2 id="5-1-黑马"><a href="#5-1-黑马" class="headerlink" title="5.1. 黑马"></a>5.1. 黑马</h2><h3 id="5-1-1-视频"><a href="#5-1-1-视频" class="headerlink" title="5.1.1. 视频"></a>5.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1154y1r7Mn/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1154y1r7Mn/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="5-1-2-资料"><a href="#5-1-2-资料" class="headerlink" title="5.1.2. 资料"></a>5.1.2. 资料</h3><p>[[skywalking讲义.pdf]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/Enterprise/<span class="hljs-number">0003</span>-Architecture/<span class="hljs-number">005</span>-分布式专题/分布式链路追踪skywalking<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Open-Tracing&quot;&gt;&lt;a href=&quot;#1-Open-Tracing&quot; class=&quot;headerlink&quot; title=&quot;1. Open Tracing&quot;&gt;&lt;/a&gt;1. Open Tracing&lt;/h1&gt;&lt;h1 id=&quot;2-Skywalki</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>资源导航</title>
    <link href="https://taylorluo.github.io/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/"/>
    <id>https://taylorluo.github.io/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.045Z</updated>
    
    <content type="html"><![CDATA[<hr><p>1.JavaGuide: 一份涵盖大部分 Java 程序员所需要掌握的核心知识。<br>2.CS-Notes: 技术面试必备基础知识<br>3.advanced-java: 涵盖高并发、分布式、高可用、微服务<br>4.miaosha:秒杀系统设计与实现<br>5.architect-awesome:后端架构师技术图谱<br>6.toBeTopJavaer:Java工程师成神之路<br>7.technology-talk:Java生态圈常用技术<br>8.JavaFamily：互联网一线大厂面试指南<br>9.JCSprout：处于萌芽的Java核心知识库<br>10.fullstack-tutorial:全栈学习<br>11.JGrowing:Java 成长路线，但学到不仅仅是 Java<br>12.3y:从Java基础、JavaWeb基础到常用的框架再到面试题都有完整的教程，几乎涵盖了Java后端必备的知识点<br>13.interview_internal_reference:2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。<br>14.effective-java-3rd-chinese:Effective Java中文版（第3版），Java 四大名著之一，本书一共包含90个条目，每个条目讨论Java程序设计中的一条规则。这些规则反映了最有经验的优秀程序员在实践中常用的一些有益的做法。<br>15.《OnJava8》：又名《Java编程思想》第5版， Java 四大名著之一。  </p><p>《Java工程师面试突击第一季》：链接:<a href="https://pan.baidu.com/s/1wQNloOiviOLc6jlXGBtSjA">https://pan.baidu.com/s/1wQNloOiviOLc6jlXGBtSjA</a> 密码:srgn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;1.JavaGuide: 一份涵盖大部分 Java 程序员所需要掌握的核心知识。&lt;br&gt;2.CS-Notes: 技术面试必备基础知识&lt;br&gt;3.advanced-java: 涵盖高并发、分布式、高可用、微服务&lt;br&gt;4.miaosha:秒杀系统设计与实现&lt;br&gt;5</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>算法-0、汇总</title>
    <link href="https://taylorluo.github.io/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/"/>
    <id>https://taylorluo.github.io/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.045Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1. 算法分析"></a>1. 算法分析</h1><p>研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且<br>也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。</p><h2 id="1-1-时间复杂度分析-大O记法"><a href="#1-1-时间复杂度分析-大O记法" class="headerlink" title="1.1. 时间复杂度分析-大O记法"></a>1.1. 时间复杂度分析-大O记法</h2><h3 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1. 定义"></a>1.1.1. 定义</h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)&#x3D;O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。<br>在这里，我们需要明确一个事情：执行次数&#x3D;执行时间用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。</p><h3 id="1-1-2-常见的大O阶"><a href="#1-1-2-常见的大O阶" class="headerlink" title="1.1.2. 常见的大O阶"></a>1.1.2. 常见的大O阶</h3><p>常数阶：O(1)<br>对数阶：O(logn)<br>线性阶：O(n)<br>线性对数阶: O(nlogn)<br>平方阶：O(n<sup>2</sup>)<br>立方阶：O(n<sup>3</sup>)<br>k次方阶：O(n<sup>k</sup>)<br>指数阶：O(2<sup>n</sup>)</p><p>他们的复杂程度从低到高依次为：<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(n<sup>k</sup>)&lt;O(2<sup>n</sup>)</p><h2 id="1-2-空间复杂度分析"><a href="#1-2-空间复杂度分析" class="headerlink" title="1.2. 空间复杂度分析"></a>1.2. 空间复杂度分析</h2><p>1.基本数据类型内存占用情况：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20220927094340.png"></p><p>2.计算机访问内存的方式都是一次一个字节<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20220927094410.png"><br>3.一个引用（机器地址）需要8个字节表示：<br>例如： Date date &#x3D; new Date(),则date这个变量需要占用8个字节来表示<br>4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，<span style="background-color:#00ff00">每个对象的自身开销是16个字节，用来保存对象的头信息</span>。<br>5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节的倍数字节数：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20220927094459.png"></p><p>6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要：24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)，再加上保存值所需的内存。</p><p>了解了java的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。</p><p>算法的空间复杂度计算公式记作：S(n)&#x3D;O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。</p><h1 id="2-算法题"><a href="#2-算法题" class="headerlink" title="2. 算法题"></a>2. 算法题</h1><p>[[Java基础-算法题解析]]</p><h1 id="3-算法汇总"><a href="#3-算法汇总" class="headerlink" title="3. 算法汇总"></a>3. 算法汇总</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20220924130123.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/imgimage-20211016144158004.png" alt="image-20211016144158004"></p><h1 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4. 排序算法"></a>4. 排序算法</h1><h2 id="4-1-算法分类"><a href="#4-1-算法分类" class="headerlink" title="4.1. 算法分类"></a>4.1. 算法分类</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyjsntg3j30za0f0790.jpg" alt="image-20200202124614464"></p><p>内部排序和外部排序。<br>内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。<br>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</p><h2 id="4-2-算法比较"><a href="#4-2-算法比较" class="headerlink" title="4.2. 算法比较"></a>4.2. 算法比较</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyk8czcpj31ao0u04qp.jpg" alt="image-20200202124639588"></p><h1 id="5-查找算法"><a href="#5-查找算法" class="headerlink" title="5. 查找算法"></a>5. 查找算法</h1><h2 id="5-1-BM"><a href="#5-1-BM" class="headerlink" title="5.1. BM"></a>5.1. BM</h2><p><a href="https://blog.csdn.net/DBC_121/article/details/105569440">https://blog.csdn.net/DBC_121/article/details/105569440</a><br><a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a></p><h1 id="6-其他算法"><a href="#6-其他算法" class="headerlink" title="6. 其他算法"></a>6. 其他算法</h1><p><a href="https://www.cnblogs.com/hongdada/p/10406902.html">https://www.cnblogs.com/hongdada/p/10406902.html</a><br><a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a><br>[[20221011-LRU和LFU的区别 - stardsd - 博客园]]</p><h2 id="6-1-LRU"><a href="#6-1-LRU" class="headerlink" title="6.1. LRU"></a>6.1. LRU</h2><h2 id="6-2-LFU"><a href="#6-2-LFU" class="headerlink" title="6.2. LFU"></a>6.2. LFU</h2><h2 id="6-3-FIFO"><a href="#6-3-FIFO" class="headerlink" title="6.3. FIFO"></a>6.3. FIFO</h2><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><h2 id="7-1-左程云算法"><a href="#7-1-左程云算法" class="headerlink" title="7.1. 左程云算法"></a>7.1. 左程云算法</h2><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;001-基础知识专题&#x2F;000-数据结构与算法&#x2F;左神算法资料</p><h2 id="7-2-吴师兄学算法"><a href="#7-2-吴师兄学算法" class="headerlink" title="7.2. 吴师兄学算法"></a>7.2. 吴师兄学算法</h2><p><a href="https://blog.algomooc.com/">https://blog.algomooc.com/</a><br>动图：<a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg">https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg</a><br><a href="https://github.com/GarenXie1/LeetCodeAnimation">https://github.com/GarenXie1/LeetCodeAnimation</a></p><h2 id="7-3-CodeSheep"><a href="#7-3-CodeSheep" class="headerlink" title="7.3. CodeSheep"></a>7.3. CodeSheep</h2><p><a href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ</a></p><h2 id="7-4-抖码课堂"><a href="#7-4-抖码课堂" class="headerlink" title="7.4. 抖码课堂"></a>7.4. 抖码课堂</h2><p><a href="https://www.bilibili.com/video/BV1qL411M7iB/?p=103&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1qL411M7iB/?p=103&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>代码已下载<br>&#x2F;Users&#x2F;weileluo&#x2F;obsidian_repo&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;algo_interview_bilibili-master</p><h2 id="7-5-黑马程序员"><a href="#7-5-黑马程序员" class="headerlink" title="7.5. 黑马程序员"></a>7.5. 黑马程序员</h2><p><a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=56&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1iJ411E7xW?p=56&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>代码已下载</p><h2 id="7-6-图灵学院"><a href="#7-6-图灵学院" class="headerlink" title="7.6. 图灵学院"></a>7.6. 图灵学院</h2><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;001-基础知识专题&#x2F;000-数据结构与算法&#x2F;算法资料&#x2F;leetcode算法资料.pdf</p><p><a href="https://www.jianshu.com/p/33cffa1ce613">https://www.jianshu.com/p/33cffa1ce613</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-算法分析&quot;&gt;&lt;a href=&quot;#1-算法分析&quot; class=&quot;headerlink&quot; title=&quot;1. 算法分析&quot;&gt;&lt;/a&gt;1. 算法分析&lt;/h1&gt;&lt;p&gt;研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且&lt;br&gt;也通过</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>算法-1、题目解析</title>
    <link href="https://taylorluo.github.io/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://taylorluo.github.io/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.045Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-不用中间变量交换两个数"><a href="#1-1-不用中间变量交换两个数" class="headerlink" title="1.1. 不用中间变量交换两个数"></a>1.1. 不用中间变量交换两个数</h2><h2 id="1-2-找到出现奇数次的数"><a href="#1-2-找到出现奇数次的数" class="headerlink" title="1.2. 找到出现奇数次的数"></a>1.2. 找到出现奇数次的数</h2><p><a href="https://www.bilibili.com/video/BV1zu411X744?p=8&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1zu411X744?p=8&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221023080100.png"></p><h2 id="1-3-找到-2-个出现奇数次的数"><a href="#1-3-找到-2-个出现奇数次的数" class="headerlink" title="1.3. 找到 2 个出现奇数次的数"></a>1.3. 找到 2 个出现奇数次的数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public static int bit1counts(int N) &#123;  <br>   int count = 0;  <br>   //   011011010000  <br>   //   000000010000     1      //   011011000000  <br>   //     <br>while(N != 0) &#123;  <br>      int rightOne = N &amp; ((~N) + 1);  <br>      count++;  <br>      N ^= rightOne;  <br>      // N -= rightOne  <br>   &#125;  <br>     <br>   return count;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-数字中-1-的个数"><a href="#1-4-数字中-1-的个数" class="headerlink" title="1.4. 数字中 1 的个数"></a>1.4. 数字中 1 的个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">public static int bit1counts(int N) &#123;  <br>   int count = 0;  <br>   //   011011010000  <br>   //   000000010000     1      //   011011000000  <br>   //   <br>   while(N != 0) &#123;  <br>      int rightOne = N &amp; ((~N) + 1);  <br>      count++;  <br>      N ^= rightOne;  <br>      // N -= rightOne  <br>   &#125;  <br>  <br>   return count;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-合并两个有序数组-L88"><a href="#1-5-合并两个有序数组-L88" class="headerlink" title="1.5. 合并两个有序数组 -L88"></a>1.5. 合并两个有序数组 -L88</h2><p><a href="https://www.bilibili.com/video/BV1ya4y1H7gH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1ya4y1H7gH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="1-5-1-双指针倒序复制"><a href="#1-5-1-双指针倒序复制" class="headerlink" title="1.5.1. 双指针倒序复制"></a>1.5.1. 双指针倒序复制</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221014135111.png" alt="image-20221014135111713"></p><h3 id="1-5-2-有剩余情况"><a href="#1-5-2-有剩余情况" class="headerlink" title="1.5.2. 有剩余情况"></a>1.5.2. 有剩余情况</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221014141451.gif" alt="Oct-14-2022 14-14-16"></p><h3 id="1-5-3-无剩余情况"><a href="#1-5-3-无剩余情况" class="headerlink" title="1.5.3. 无剩余情况"></a>1.5.3. 无剩余情况</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221014140607.gif" alt="Oct-14-2022 14-05-22"></p><p>动图中有个小错误，在最后一步，p1 指针应该没动，只有 p 和 p2 向左移动了一步，p 和 p1 都指向 1 所在的位置。p2 越界了跳出 while 循环，此时 p2&#x3D;-1，走到下面一句：System.arraycopy(nums2,0,num1,0,0)，相当于没有变化，即 nums2 已经全部转移到了 nums1 中，最后的扫尾动作相当于没有变化。</p><h3 id="1-5-4-代码实现"><a href="#1-5-4-代码实现" class="headerlink" title="1.5.4. 代码实现"></a>1.5.4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> ((p1 &gt;= <span class="hljs-number">0</span>) &amp;&amp; (p2 &gt;= <span class="hljs-number">0</span>))<br>    nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];<br><br>  System.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">0</span>, p2 + <span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><h2 id="2-1-反转链表"><a href="#2-1-反转链表" class="headerlink" title="2.1. 反转链表"></a>2.1. 反转链表</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221014124457.png"></p><h1 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h1><h2 id="3-1-层序遍历"><a href="#3-1-层序遍历" class="headerlink" title="3.1. 层序遍历"></a>3.1. 层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> index, List result)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> result.size();  <br>    <span class="hljs-keyword">if</span> (length &lt;= index) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= index - length; j++) &#123;  <br>            result.add(length + j, <span class="hljs-literal">null</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    result.set(index, root.val);  <br>    levelOrder(root.left, <span class="hljs-number">2</span>*index, result);  <br>    levelOrder(root.right, <span class="hljs-number">2</span>*index + <span class="hljs-number">1</span>, result);  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-树的最大宽度"><a href="#3-2-树的最大宽度" class="headerlink" title="3.2. 树的最大宽度"></a>3.2. 树的最大宽度</h2><h3 id="3-2-1-使用-map"><a href="#3-2-1-使用-map" class="headerlink" title="3.2.1. 使用 map"></a>3.2.1. 使用 map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxWidthUseMap</span><span class="hljs-params">(Node head)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>   &#125;  <br>   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>   queue.add(head);  <br>   <span class="hljs-comment">// key 在 哪一层，value  </span><br>   HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>   levelMap.put(head, <span class="hljs-number">1</span>);  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">curLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前你正在统计哪一层的宽度  </span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">curLevelNodes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层curLevel层，宽度目前是多少  </span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>      <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();  <br>      <span class="hljs-type">int</span> <span class="hljs-variable">curNodeLevel</span> <span class="hljs-operator">=</span> levelMap.get(cur);  <br>      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;  <br>         levelMap.put(cur.left, curNodeLevel + <span class="hljs-number">1</span>);  <br>         queue.add(cur.left);  <br>      &#125;  <br>      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;  <br>         levelMap.put(cur.right, curNodeLevel + <span class="hljs-number">1</span>);  <br>         queue.add(cur.right);  <br>      &#125;  <br>      <span class="hljs-keyword">if</span> (curNodeLevel == curLevel) &#123;  <br>         curLevelNodes++;  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>         max = Math.max(max, curLevelNodes);  <br>         curLevel++;  <br>         curLevelNodes = <span class="hljs-number">1</span>;  <br>      &#125;  <br>   &#125;  <br>   max = Math.max(max, curLevelNodes);  <br>   <span class="hljs-keyword">return</span> max;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-不用-map"><a href="#3-2-2-不用-map" class="headerlink" title="3.2.2. 不用 map"></a>3.2.2. 不用 map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxWidthNoMap</span><span class="hljs-params">(Node head)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>   &#125;  <br>   Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>   queue.add(head);  <br>   <span class="hljs-type">Node</span> <span class="hljs-variable">curEnd</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// 当前层，最右节点是谁  </span><br>   <span class="hljs-type">Node</span> <span class="hljs-variable">nextEnd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 下一层，最右节点是谁  </span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>   <span class="hljs-type">int</span> <span class="hljs-variable">curLevelNodes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前层的节点数  </span><br>   <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;  <br>      <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();  <br>      <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;  <br>         queue.add(cur.left);  <br>         nextEnd = cur.left;  <br>      &#125;  <br>      <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;  <br>         queue.add(cur.right);  <br>         nextEnd = cur.right;  <br>      &#125;  <br>      curLevelNodes++;  <br>      <span class="hljs-keyword">if</span> (cur == curEnd) &#123;  <br>         max = Math.max(max, curLevelNodes);  <br>         curLevelNodes = <span class="hljs-number">0</span>;  <br>         curEnd = nextEnd;  <br>      &#125;  <br>   &#125;  <br>   <span class="hljs-keyword">return</span> max;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-序列化"><a href="#3-3-序列化" class="headerlink" title="3.3. 序列化"></a>3.3. 序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Queue&lt;String&gt; <span class="hljs-title function_">preSerial</span><span class="hljs-params">(Node head)</span> &#123;  <br>   Queue&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>   pres(head, ans);  <br>   <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pres</span><span class="hljs-params">(Node head, Queue&lt;String&gt; ans)</span> &#123;  <br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;  <br>      ans.add(<span class="hljs-literal">null</span>);  <br>   &#125; <span class="hljs-keyword">else</span> &#123;  <br>      ans.add(String.valueOf(head.value));  <br>      pres(head.left, ans);  <br>      pres(head.right, ans);  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-图"><a href="#4-图" class="headerlink" title="4. 图"></a>4. 图</h1><h1 id="5-ForkJoin"><a href="#5-ForkJoin" class="headerlink" title="5. ForkJoin"></a>5. ForkJoin</h1><p>分而治之思想<br><a href="https://www.bilibili.com/video/BV11A411H7Xh?p=7&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV11A411H7Xh?p=7&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221012193941.png"></p><h1 id="6-等概率生成器"><a href="#6-等概率生成器" class="headerlink" title="6. 等概率生成器"></a>6. 等概率生成器</h1><p><a href="https://www.bilibili.com/video/BV1qd4y1B7XC?p=12&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1qd4y1B7XC?p=12&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h1 id="7-快慢指针"><a href="#7-快慢指针" class="headerlink" title="7. 快慢指针"></a>7. 快慢指针</h1><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;001- 基础知识专题&#x2F;000- 数据结构与算法&#x2F;黑马 - 数据结构与算法资料&#x2F;文档&#x2F;04_ 线性表.pdf</p><h1 id="8-从后往前节省空间"><a href="#8-从后往前节省空间" class="headerlink" title="8. 从后往前节省空间"></a>8. 从后往前节省空间</h1><p><a href="https://www.bilibili.com/video/BV1iE411s7Gi/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1iE411s7Gi/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h1 id="9-参考"><a href="#9-参考" class="headerlink" title="9. 参考"></a>9. 参考</h1><p><a href="https://space.bilibili.com/390775036">https://space.bilibili.com/390775036</a></p><h2 id="9-1-左程云算法"><a href="#9-1-左程云算法" class="headerlink" title="9.1. 左程云算法"></a>9.1. 左程云算法</h2><p><a href="https://www.bilibili.com/video/BV1qd4y1B7XC/?p=13&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1qd4y1B7XC/?p=13&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;001- 基础知识专题&#x2F;000- 数据结构与算法&#x2F;左神算法资料</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-数组&quot;&gt;&lt;a href=&quot;#1-数组&quot; class=&quot;headerlink&quot; title=&quot;1. 数组&quot;&gt;&lt;/a&gt;1. 数组&lt;/h1&gt;&lt;h2 id=&quot;1-1-不用中间变量交换两个数&quot;&gt;&lt;a href=&quot;#1-1-不用中间变量交换两个数&quot; class=</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/"/>
    <id>https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.687Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Kafka-知识总结"><a href="#1-Kafka-知识总结" class="headerlink" title="1. Kafka 知识总结"></a>1. <strong>Kafka 知识总结</strong></h1><h2 id="1-1-一、讲讲-acks-参数对消息持久化的影响"><a href="#1-1-一、讲讲-acks-参数对消息持久化的影响" class="headerlink" title="1.1. 一、讲讲 acks 参数对消息持久化的影响"></a>1.1. <strong>一、讲讲 acks 参数对消息持久化的影响</strong></h2><h3 id="1-1-1-目录"><a href="#1-1-1-目录" class="headerlink" title="1.1.1. 目录"></a>1.1.1. <strong>目录</strong></h3><ol><li>写在前面</li><li>如何保证宕机时数据不丢失？</li><li>多副本之间数据如何同步？</li><li>ISR 到底指的是什么东西？</li><li>acks 参数的含义？</li><li>最后的思考</li></ol><h3 id="1-1-2-1-写在前面"><a href="#1-1-2-1-写在前面" class="headerlink" title="1.1.2. 1.写在前面"></a>1.1.2. <strong>1.写在前面</strong></h3><p>面试大厂时，一旦简历上写了 Kafka，几乎必然会被问到一个问题：说说 acks 参数对消息持久化的影响？</p><p>这个 acks 参数在 kafka 的使用中，是非常核心以及关键的一个参数，决定了很多东西。</p><p>所以无论是为了面试还是实际项目使用，大家都值得看一下这篇文章对 Kafka 的 acks 参数的分析，以及背后的原理。</p><h3 id="1-1-3-2-如何保证宕机的时候数据不丢失？（或者-kafka-如何保证高可用、或者-Kafka-如何保证高可用）"><a href="#1-1-3-2-如何保证宕机的时候数据不丢失？（或者-kafka-如何保证高可用、或者-Kafka-如何保证高可用）" class="headerlink" title="1.1.3. 2.如何保证宕机的时候数据不丢失？（或者 kafka 如何保证高可用、或者 Kafka 如何保证高可用）"></a>1.1.3. <strong>2.如何保证宕机的时候数据不丢失？（或者 kafka 如何保证高可用、或者 Kafka 如何保证高可用）</strong></h3><ul><li><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是 <strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是 <strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p></li><li><p>而且 Kafka 还提供 replica<strong>副本机制</strong>，每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。所有 replica 会选举出来一个 leader 出来，那么 <strong>生产和消费都跟这个 leader 打交道</strong>，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</p></li></ul><p>如果某个 broker 宕机了，那个 broker 上的 partition 在其他机器上都有副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么从 follower 中重新选举一个新的 leader 出来，然后继续读写新的 leader 即可，这就是所谓的高可用。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230514115527.jpg" alt="11"></p><h3 id="1-1-4-3-多副本之间数据如何保证同步"><a href="#1-1-4-3-多副本之间数据如何保证同步" class="headerlink" title="1.1.4. 3.多副本之间数据如何保证同步"></a>1.1.4. 3.<strong>多副本之间数据如何保证同步</strong></h3><p>其实任何一个 Partition，只有 Leader 是对外提供读写服务的，也就是说，如果有一个客户端往一个 Partition 写入数据，此时一般就是写入这个 Partition 的 Leader 副本。</p><p>然后 Leader 副本接收到数据之后，Follower 副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/2.jpg"></p><h3 id="1-1-5-4-ISR-到底指的是什么东西？"><a href="#1-1-5-4-ISR-到底指的是什么东西？" class="headerlink" title="1.1.5. 4.ISR 到底指的是什么东西？"></a>1.1.5. <strong>4.ISR 到底指的是什么东西？</strong></h3><p>ISR 全称是“In-Sync Replicas”，也就是 <strong>保持同步的副本</strong>，他的含义就是，跟 Leader 始终保持同步的 Follower 有哪些。</p><p>大家可以想一下 ，如果说某个 Follower 所在的 Broker 因为 JVM FullGC 之类的问题，导致自己卡顿了，无法及时从 Leader 拉取同步数据，那么是不是会导致 Follower 的数据比 Leader 要落后很多？</p><p>所以这个时候，就意味着 Follower 已经跟 Leader 不再处于同步的关系了。但是只要 Follower 一直及时从 Leader 同步数据，就可以保证他们是处于同步的关系的。</p><p>所以每个 Partition 都有一个 ISR，这个 ISR 里一定会有 Leader 自己，因为 Leader 肯定数据是最新的，然后就是那些跟 Leader 保持同步的 Follower，也会在 ISR 里。</p><h3 id="1-1-6-5-acks-参数的含义"><a href="#1-1-6-5-acks-参数的含义" class="headerlink" title="1.1.6. 5.acks 参数的含义"></a>1.1.6. <strong>5.acks 参数的含义</strong></h3><p>首先这个 acks 参数，是在 KafkaProducer，也就是生产者客户端里设置的</p><p>也就是说，你往 kafka 写数据的时候，就可以来设置这个 acks 参数。然后这个参数实际上有三种常见的值可以设置，分别是：<strong>0、1 和 all</strong>。</p><p><strong>第一种选择是把 acks 参数设置为 0</strong>，意思就是我的 KafkaProducer 在客户端，只要把消息发送出去，不管那条数据有没有在哪怕 Partition Leader 上落到磁盘，我就不管他了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。结果呢，Partition Leader 所在 Broker 就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会 <strong>导致这条消息就丢失了</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/3.jpg"></p><p><strong>第二种选择是设置 acks &#x3D; 1</strong>，意思就是说只要 Partition Leader 接收到消息而且写入本地磁盘了，就认为成功了，不管他其他的 Follower 有没有同步过去这条消息了。</p><p>这种设置其实是 <strong>kafka 默认的设置</strong></p><p>也就是说，默认情况下，你要是不管 acks 这个参数，只要 Partition Leader 写成功就算成功。</p><p>但是这里有一个问题，万一 Partition Leader 刚刚接收到消息，Follower 还没来得及同步过去，结果 Leader 所在的 broker 宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/4.jpg"></p><p><strong>最后一种情况，就是设置 acks&#x3D;all</strong>，这个意思就是说，<strong>Partition Leader 接收到消息之后，还必须要求 ISR 列表里跟 Leader 保持同步的那些 Follower 都要把消息同步过去</strong>，才能认为这条消息是写入成功了。</p><p>如果说 Partition Leader 刚接收到了消息，但是结果 Follower 没有收到消息，此时 Leader 宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能 Partition 2 的 Follower 变成 Leader 了，此时 ISR 列表里只有最新的这个 Follower 转变成的 Leader 了，那么只要这个新的 Leader 接收消息就算成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/5.jpg"></p><h3 id="1-1-7-6-最后的思考"><a href="#1-1-7-6-最后的思考" class="headerlink" title="1.1.7. 6.最后的思考"></a>1.1.7. <strong>6.最后的思考</strong></h3><p>acks&#x3D;all 就可以代表数据一定不会丢失了吗？</p><p>当然不是，如果你的 Partition 只有一个副本，也就是一个 Leader，任何 Follower 都没有，你认为 acks&#x3D;all 有用吗？</p><p>当然没用了，因为 ISR 里就一个 Leader，他接收完消息后宕机，也会导致数据丢失。</p><p>所以说，<strong>这个 acks&#x3D;all，必须跟 ISR 列表里至少有 2 个以上的副本配合使用</strong>，起码是有一个 Leader 和一个 Follower 才可以。</p><p>这样才能保证说写一条数据过去，一定是 2 个以上的副本都收到了才算是成功，此时任何一个副本宕机，不会导致数据丢失。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A">https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A</a></p><h2 id="1-2-二、Kafka-参数调优实战"><a href="#1-2-二、Kafka-参数调优实战" class="headerlink" title="1.2. 二、Kafka 参数调优实战"></a>1.2. 二、Kafka 参数调优实战</h2><h3 id="1-2-1-目录"><a href="#1-2-1-目录" class="headerlink" title="1.2.1. 目录"></a>1.2.1. 目录</h3><ol><li>背景引入：很多同学看不懂的 Kafka 参数</li><li>一段 Kafka 生产端的示例代码</li><li>内存缓冲的大小</li><li>多少数据打包为一个 Batch 合适？</li><li>要是一个 Batch 迟迟无法凑满怎么办？</li><li>最大请求大小</li><li>重试机制</li><li>持久化机制</li></ol><h4 id="1-2-1-1-1、背景引入：很多同学看不懂的-kafka-参数"><a href="#1-2-1-1-1、背景引入：很多同学看不懂的-kafka-参数" class="headerlink" title="1.2.1.1. 1、背景引入：很多同学看不懂的 kafka 参数"></a>1.2.1.1. 1、背景引入：很多同学看不懂的 kafka 参数</h4><p>在使用 Kafka 的客户端编写代码与服务器交互的时候，是需要对客户端设置很多的参数的。</p><h4 id="1-2-1-2-2、一段-Kafka-生产端的示例代码"><a href="#1-2-1-2-2、一段-Kafka-生产端的示例代码" class="headerlink" title="1.2.1.2. 2、一段 Kafka 生产端的示例代码"></a>1.2.1.2. 2、一段 Kafka 生产端的示例代码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Properties</span> props = <span class="hljs-keyword">new</span> <span class="hljs-type">Properties</span>();<br>props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;localhost:9092&quot;</span>); <br>props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">67108864</span>); <br>props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">131072</span>); <br>props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">100</span>); <br>props.put(<span class="hljs-string">&quot;max.request.size&quot;</span>, <span class="hljs-number">10485760</span>); <br>props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>); <br>props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">10</span>); <br>props.put(<span class="hljs-string">&quot;retry.backoff.ms&quot;</span>, <span class="hljs-number">500</span>);<br><br><span class="hljs-type">KafkaProducer</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaProducer</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt;(props);<br></code></pre></td></tr></table></figure><h4 id="1-2-1-3-3、内存缓冲的大小"><a href="#1-2-1-3-3、内存缓冲的大小" class="headerlink" title="1.2.1.3. 3、内存缓冲的大小"></a>1.2.1.3. 3、内存缓冲的大小</h4><p>首先看看“<strong>buffer.memory</strong>”这个参数是什么意思？</p><p>Kafka 的客户端发送数据到服务器，一般都是要经过 <strong>缓冲</strong> 的，也就是说，<strong>通过 KafkaProducer 发送出去的消息都是先进入到客户端本地的内存缓冲里，然后把很多消息收集成一个一个的 Batch，再发送到 Broker 上去的</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/6.jpg"></p><p>所以这个“<strong>buffer.memory”的本质就是用来约束 KafkaProducer 能够使用的内存缓冲的大小的，他的默认值是 32MB</strong>。</p><p>你可以先想一下，如果这个内存缓冲设置的过小的话，可能会导致一个什么问题？</p><p>首先要明确一点，那就是在内存缓冲里大量的消息会缓冲在里面，形成一个一个的 Batch，每个 Batch 里包含多条消息。</p><p>然后 KafkaProducer 有一个 Sender 线程会把多个 Batch 打包成一个 Request 发送到 Kafka 服务器上去。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/7.jpg"></p><p>那么如果要是 <strong>内存设置的太小</strong>，可能 <strong>导致一个问题</strong>：消息快速的写入内存缓冲里面，但是 Sender 线程来不及把 Request 发送到 Kafka 服务器。</p><p>这样是不是会造成内存缓冲很快就被写满？一旦被写满，就会阻塞用户线程，不让继续往 Kafka 写消息了。</p><p>所以对于“buffer.memory”这个参数应该结合自己的实际情况来进行压测，你需要测算一下在生产环境，你的用户线程会以每秒多少消息的频率来写入内存缓冲。</p><p>比如说每秒 300 条消息，那么你就需要压测一下，假设内存缓冲就 32MB，每秒写 300 条消息到内存缓冲，是否会经常把内存缓冲写满？经过这样的压测，你可以调试出来一个合理的内存大小。</p><h4 id="1-2-1-4-4、多少数据打包为一个-Batch-合适？"><a href="#1-2-1-4-4、多少数据打包为一个-Batch-合适？" class="headerlink" title="1.2.1.4. 4、多少数据打包为一个 Batch 合适？"></a>1.2.1.4. 4、多少数据打包为一个 Batch 合适？</h4><p>接着你需要思考第二个问题，就是你的“<strong>batch.size</strong>”应该如何设置？<strong>这决定了你的每个 Batch 要存放多少数据就可以发送出去了</strong>。</p><p>比如说你要是给一个 Batch 设置成是 16KB 的大小，那么里面凑够 16KB 的数据就可以发送了。</p><p>这个 <strong>参数的默认值是 16KB</strong>，一般可以尝试把这个参数调节大一些，然后利用自己的生产环境发消息的负载来测试一下。</p><p>比如说发送消息的频率就是每秒 300 条，那么如果比如“batch.size”调节到了 32KB，或者 64KB，是否可以提升发送消息的整体吞吐量。</p><p>因为理论上来说，提升 batch 的大小，可以允许更多的数据缓冲在里面，那么一次 Request 发送出去的数据量就更多了，这样吞吐量可能会有所提升。</p><p>但是 <strong>不能无限的大</strong>，过于大了之后，要是数据老是缓冲在 Batch 里迟迟不发送出去，那么岂不是你发送消息的延迟就会很高，<strong>导致高延迟问题</strong>。</p><p>比如说，一条消息进入了 Batch，但是要等待 5 秒钟 Batch 才凑满了 64KB，才能发送出去。那这条消息的延迟就是 5 秒钟。</p><p>所以需要在这里按照生产环境的发消息的速率，调节不同的 Batch 大小自己测试一下最终出去的吞吐量以及消息的 延迟，设置一个最合理的参数。</p><h4 id="1-2-1-5-5、要是一个-Batch-迟迟无法凑满怎么办？"><a href="#1-2-1-5-5、要是一个-Batch-迟迟无法凑满怎么办？" class="headerlink" title="1.2.1.5. 5、要是一个 Batch 迟迟无法凑满怎么办？"></a>1.2.1.5. 5、要是一个 Batch 迟迟无法凑满怎么办？</h4><p>要是一个 Batch 迟迟无法凑满，此时就需要引入另外一个参数了，“<strong>linger.ms</strong>”</p><p><strong>含义是一个 Batch 被创建之后，最多过多久，不管这个 Batch 有没有写满，都必须发送出去了</strong>。</p><p>给大家举个例子，比如说 batch.size 是 16kb，但是现在某个低峰时间段，发送消息很慢。</p><p>这就导致可能 Batch 被创建之后，陆陆续续有消息进来，但是迟迟无法凑够 16KB，难道此时就一直等着吗？</p><p>当然不是，假设你现在设置“linger.ms”是 50ms，那么只要这个 Batch 从创建开始到现在已经过了 50ms 了，哪怕他还没满 16KB，也要发送他出去了。</p><p>所以“linger.ms”决定了你的消息一旦写入一个 Batch，最多等待这么多时间，他一定会跟着 Batch 一起发送出去。</p><p>避免一个 Batch 迟迟凑不满，导致消息一直积压在内存里发送不出去的情况。<strong>这是一个很关键的参数。</strong></p><p>这个参数一般要非常慎重的来设置，要配合 batch.size 一起来设置。</p><p>举个例子，首先假设你的 Batch 是 32KB，那么你得估算一下，正常情况下，一般多久会凑够一个 Batch，比如正常来说可能 20ms 就会凑够一个 Batch。</p><p>那么你的 linger.ms 就可以设置为 25ms，也就是说，正常来说，大部分的 Batch 在 20ms 内都会凑满，但是你的 linger.ms 可以保证，哪怕遇到低峰时期，20ms 凑不满一个 Batch，还是会在 25ms 之后强制 Batch 发送出去。</p><p>如果要是你把 linger.ms 设置的太小了，比如说默认就是 0ms，或者你设置个 5ms，那可能导致你的 Batch 虽然设置了 32KB，但是经常是还没凑够 32KB 的数据，5ms 之后就直接强制 Batch 发送出去，这样也不太好其实，会导致你的 Batch 形同虚设，一直凑不满数据。</p><h4 id="1-2-1-6-6、最大请求大小"><a href="#1-2-1-6-6、最大请求大小" class="headerlink" title="1.2.1.6. 6、最大请求大小"></a>1.2.1.6. 6、最大请求大小</h4><p><strong>“max.request.size”这个参数决定了每次发送给 Kafka 服务器请求的最大大小</strong>，同时也会限制你一条消息的最大大小也不能超过这个参数设置的值，这个其实可以根据你自己的消息的大小来灵活的调整。</p><p>给大家举个例子，你们公司发送的消息都是那种大的报文消息，每条消息都是很多的数据，一条消息可能都要 20KB。</p><p>此时你的 batch.size 是不是就需要调节大一些？比如设置个 512KB？然后你的 buffer.memory 是不是要给的大一些？比如设置个 128MB？</p><p>只有这样，才能让你在大消息的场景下，还能使用 Batch 打包多条消息的机制。但是此时“max.request.size”是不是也得同步增加？</p><p>因为可能你的一个请求是很大的，默认他是 1MB，你是不是可以适当调大一些，比如调节到 5MB？</p><h4 id="1-2-1-7-7、重试机制"><a href="#1-2-1-7-7、重试机制" class="headerlink" title="1.2.1.7. 7、重试机制"></a>1.2.1.7. 7、重试机制</h4><p><strong>“retries”和“retries.backoff.ms”决定了重试机制，也就是如果一个请求失败了可以重试几次，每次重试的间隔是多少毫秒</strong>。</p><p>这个大家适当设置几次重试的机会，给一定的重试间隔即可，比如给 100ms 的重试间隔。</p><h4 id="1-2-1-8-8、持久化机制"><a href="#1-2-1-8-8、持久化机制" class="headerlink" title="1.2.1.8. 8、持久化机制"></a>1.2.1.8. 8、持久化机制</h4><p>“acks”参数决定了发送出去的消息要采用什么样的持久化策略，这个涉及到了很多其他的概念，大家可以参考之前专门为“acks”写过的一篇文章。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw"></a></p><h2 id="1-3-三、消息中间件消费到的消息处理失败怎么办？"><a href="#1-3-三、消息中间件消费到的消息处理失败怎么办？" class="headerlink" title="1.3. 三、消息中间件消费到的消息处理失败怎么办？"></a>1.3. 三、消息中间件消费到的消息处理失败怎么办？</h2><p>消息中间件最核心的作用是：解耦、异步、削峰。</p><p>假如有如下的系统：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/8.jpg"></p><p>生产中存在这种情况：如果独立仓库系统或者第三方物流系统故障了，导致仓储系统消费到一条订单消息之后，尝试进行发货失败，也就是对这条消费到的消息处理失败。这种情况，怎么处理？</p><h4 id="1-3-1-死信队列的使用：处理失败的消息"><a href="#1-3-1-死信队列的使用：处理失败的消息" class="headerlink" title="1.3.1. 死信队列的使用：处理失败的消息"></a>1.3.1. 死信队列的使用：处理失败的消息</h4><p>一般生产环境中，如果你有丰富的架构设计经验，都会在使用 MQ 的时候设计两个队列：一个是 <strong>核心业务队列</strong>，一个是 <strong>死信队列</strong>。</p><p>核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。</p><p>面试被问到这个问题时，必须要结合你自己的业务实践经验来说。</p><p>比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。</p><p>此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！<strong>注意，这个步骤很重要。</strong></p><p>一旦标志这条消息处理失败了之后，MQ 就会把这条消息转入提前设置好的一个死信队列中。</p><p>然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。</p><p>然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。</p><p>一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。</p><p><strong>死信队列的使用，其实就是 MQ 在生产实践中非常重要的一环，也就是架构设计必须要考虑的</strong>。</p><p>整个过程，如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/9.jpg"></p><h2 id="1-4-四、Kafka-选举"><a href="#1-4-四、Kafka-选举" class="headerlink" title="1.4. 四、Kafka 选举"></a>1.4. 四、Kafka 选举</h2><p>Kafka 中的选举大致可以分为三大类：</p><ul><li>控制器的选举</li><li>分区 leader 的选举</li><li>消费者相关的选举</li></ul><h4 id="1-4-1-1、控制器选举"><a href="#1-4-1-1、控制器选举" class="headerlink" title="1.4.1. 1、控制器选举"></a>1.4.1. 1、控制器选举</h4><p>在 Kafka 集群中会有一个或多个 broker，其中有一个 broker 会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。</p><p>比如 <strong>当某个分区的 leader 副本出现故障时，由控制器负责为该分区选举新的 leader 副本</strong>。再比如当检测到某个分区的 ISR 集合发生变化时，由控制器负责通知所有 broker 更新其元数据信息。</p><p>Kafka Controller 的选举是依赖 Zookeeper 来实现的，在 Kafka 集群中那个 broker 能够成功创建&#x2F;controller 这个临时（Ephemeral）节点他就可以成为 Kafka Controller。</p><p>这里需要说明一下的是 Kafka Controller 的实现还是相当复杂的，涉及到各个方面的内容，如果你掌握了 Kafka Controller，你就掌握了 Kafka 的“半壁江山”。</p><h4 id="1-4-2-2、分区-leader-的选举"><a href="#1-4-2-2、分区-leader-的选举" class="headerlink" title="1.4.2. 2、分区 leader 的选举"></a>1.4.2. 2、分区 leader 的选举</h4><p>分区 leader 副本的选举 <strong>由 Kafka Controller 负责具体实施</strong>。</p><p>当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的 leader 副本下线，此时分区需要选举一个新的 leader 上线来对外提供服务）的时候都需要执行 leader 的选举动作。</p><p>基本思路是按照 AR 集合中副本的顺序查找第一个存活的副本，并且这个副本在 ISR 集合中。</p><p>一个分区的 AR 集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的 ISR 集合中副本的顺序可能会改变。</p><p>注意：这里是根据 AR 的顺序而不是 ISR 的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭&#x2F;开启某个集群中的 broker 来观察一下具体的变化。</p><p>还有一些情况也会发生分区 leader 的选举，比如当分区进行重分配（reassign）的时候也需要执行 leader 的选举动作。</p><p>这个思路比较简单：从重分配的 AR 列表中找到第一个存活的副本，且这个副本在目前的 ISR 列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为 leader 即可，AR 集合中的第一个副本即为优先副本。</p><p>还有一种情况就是当某节点被优雅地关闭（也就是执行 ControlledShutdown）时，位于这个节点上的 leader 副本都会下线，所以与此对应的分区需要执行 leader 的选举。</p><p>这里的具体思路为：从 AR 列表中找到第一个存活的副本，且这个副本在目前的 ISR 列表中，与此同时还要确保这个副本不处于正在被关闭的节点上。</p><h4 id="1-4-3-3、消费者相关的选择"><a href="#1-4-3-3、消费者相关的选择" class="headerlink" title="1.4.3. 3、消费者相关的选择"></a>1.4.3. 3、消费者相关的选择</h4><p>组协调器 GroupCoordinator 需要为消费组内的消费者选举出一个消费组的 leader，这个选举的算法也很简单，分两种情况分析。</p><ul><li><strong>如果消费组内还没有 leader，那么第一个加入消费组的消费者即为消费组的 leader</strong>。</li><li><strong>如果某一时刻 leader 消费者由于某些原因退出了消费组，那么会重新选举一个新的 leader，这个重新选举 leader 的过程又更“随意”了，相关代码如下</strong>：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//scala code.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> members = <span class="hljs-keyword">new</span> mutable.<span class="hljs-type">HashMap</span>[<span class="hljs-type">String</span>, <span class="hljs-type">MemberMetadata</span>]<br><span class="hljs-keyword">var</span> leaderId = members.keys.head<br></code></pre></td></tr></table></figure><p>解释一下这 2 行代码：在 GroupCoordinator 中消费者的信息是以 HashMap 的形式存储的，其中 key 为消费者的 member_id，而 value 是消费者相关的元数据信息。</p><p>leaderId 表示 leader 消费者的 member_id，它的取值为 HashMap 中的第一个键值对的 key，这种选举的方式基本上和随机无异。</p><p>总体上来说，消费组的 leader 选举过程是很随意的。</p><p>到这里就结束了吗？还有分区分配策略的选举呢。</p><p>或许你对此有点陌生，但是用过 Kafka 的同学或许对 partition.assignment.strategy（取值为 RangeAssignor、RoundRobinAssignor、StickyAssignor 等）这个参数并不陌生。</p><p>每个消费者都可以设置自己的分区分配策略，对消费组而言需要从各个消费者呈报上来的各个分配策略中选举一个彼此都“信服”的策略来进行整体上的分区分配。</p><p>这个分区分配的选举并非由 leader 消费者决定，而是根据消费组内的各个消费者投票来决定的。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ"></a></p><h2 id="1-5-五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"><a href="#1-5-五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）" class="headerlink" title="1.5. 五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"></a>1.5. 五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）</h2><h3 id="1-5-1-面试官心理分析"><a href="#1-5-1-面试官心理分析" class="headerlink" title="1.5.1. 面试官心理分析"></a>1.5.1. 面试官心理分析</h3><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你 <strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p><h3 id="1-5-2-面试题剖析"><a href="#1-5-2-面试题剖析" class="headerlink" title="1.5.2. 面试题剖析"></a>1.5.2. 面试题剖析</h3><p>回答这个问题，首先大概说一说可能会有哪些重复消费的问题。</p><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，挑 Kafka 来举个例子，说说怎么重复消费吧。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（<strong>定时定期</strong>），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是，你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是 <strong>没来得及提交 offset，重启之后，少数消息会再次消费一次</strong>。</p><p>例如，数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&#x2F;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1&#x2F;2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/10.png"></p><p><strong>如何保证消息队列消费的幂等性</strong>？</p><p>回答这个问题需要结合业务思考，有如下几个思路：</p><ul><li>比如数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update 一下。</li><li>比如是写 Redis，那没问题了，因为每次都是 set，天然幂等性。</li><li>比如不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面 <strong>加一个全局唯一的 id</strong>，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，就别处理，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/11.png"></p><h2 id="1-6-六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"><a href="#1-6-六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）" class="headerlink" title="1.6. 六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"></a>1.6. 六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）</h2><h2 id="1-7-面试官心理分析"><a href="#1-7-面试官心理分析" class="headerlink" title="1.7. 面试官心理分析"></a>1.7. 面试官心理分析</h2><p>这个是肯定的，用 MQ 有个基本原则，就是 <strong>数据不能多一条，也不能少一条</strong>，不能多，就是前面说的 [重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中 <strong>绝对不会把计费消息给弄丢</strong>。</p><h2 id="1-8-面试题剖析"><a href="#1-8-面试题剖析" class="headerlink" title="1.8. 面试题剖析"></a>1.8. 面试题剖析</h2><p>数据的丢失问题，可能出现在 <strong>生产者、MQ、消费者</strong> 中，从 Kafka 来分析一下。</p><h3 id="1-8-1-Kafka"><a href="#1-8-1-Kafka" class="headerlink" title="1.8.1. Kafka"></a>1.8.1. Kafka</h3><h3 id="1-8-2-1、消费者丢失数据"><a href="#1-8-2-1、消费者丢失数据" class="headerlink" title="1.8.2. 1、消费者丢失数据"></a>1.8.2. 1、消费者丢失数据</h3><p>唯一可能导致消费者弄丢数据的情况，是消费到了这个消息，然后消费者那边 <strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>由于 Kafka 会自动提交 offset，那么只要 <strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是 <strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题是 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h3 id="1-8-3-2、Kafka-弄丢数据"><a href="#1-8-3-2、Kafka-弄丢数据" class="headerlink" title="1.8.3. 2、Kafka 弄丢数据"></a>1.8.3. 2、Kafka 弄丢数据</h3><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是 <strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是 <strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h3 id="1-8-4-3、生产者会不会弄丢数据？"><a href="#1-8-4-3、生产者会不会弄丢数据？" class="headerlink" title="1.8.4. 3、生产者会不会弄丢数据？"></a>1.8.4. 3、生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h2 id="1-9-七、如何保证消息的顺序性？"><a href="#1-9-七、如何保证消息的顺序性？" class="headerlink" title="1.9. 七、如何保证消息的顺序性？"></a>1.9. 七、如何保证消息的顺序性？</h2><p>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞 <strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/12.png"></p><h4 id="1-9-1-解决方案："><a href="#1-9-1-解决方案：" class="headerlink" title="1.9.1. 解决方案："></a>1.9.1. 解决方案：</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个 <strong>内存 queue</strong>，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/13.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Kafka-知识总结&quot;&gt;&lt;a href=&quot;#1-Kafka-知识总结&quot; class=&quot;headerlink&quot; title=&quot;1. Kafka 知识总结&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;Kafka 知识总结&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>分布式专题-5、负载均衡-Ribbon</title>
    <link href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/"/>
    <id>https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.691Z</updated>
    
    <content type="html"><![CDATA[<hr><p>我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h1 id="1-负载均衡原理"><a href="#1-负载均衡原理" class="headerlink" title="1. 负载均衡原理"></a>1. 负载均衡原理</h1><p><span style="background-color:#ff00ff">SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224133.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是 <a href="http://userservice/user/1">http://userservice/user/1</a>，怎么变成了 <a href="http://localhost:8081/">http://localhost:8081</a> 的呢？</p><h1 id="2-源码跟踪"><a href="#2-源码跟踪" class="headerlink" title="2. 源码跟踪"></a>2. 源码跟踪</h1><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们<span style="background-color:#ff00ff">根据 service 名称，获取到了服务实例的 ip 和端口</span>。它就是 <code>LoadBalancerInterceptor</code>，这个类会对 RestTemplate 的请求进行拦截，然后从 Eureka 中根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h2 id="2-1-LoadBalancerIntercepor"><a href="#2-1-LoadBalancerIntercepor" class="headerlink" title="2.1. LoadBalancerIntercepor"></a>2.1. LoadBalancerIntercepor</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304231125.png" alt="image.png"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：<span style="background-color:#00ff00">获取请求 uri</span>，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：<span style="background-color:#00ff00">获取 uri 路径的主机名</span>，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型，我们继续跟入。</p><h2 id="2-2-LoadBalancerClient"><a href="#2-2-LoadBalancerClient" class="headerlink" title="2.2. LoadBalancerClient"></a>2.2. LoadBalancerClient</h2><p>继续跟入 execute 方法：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224009.png" alt="image.png"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：<span style="background-color:#ff00ff">根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来</span>。</li><li>getServer(loadBalancer)：<span style="background-color:#ff00ff">利用内置的负载均衡算法，从服务列表中选择一个</span> 在本例中，可以看到获取了 8082 端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是 8081：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304232315.png" alt="image.png"></p><p>果然实现了负载均衡。</p><h2 id="2-3-负载均衡策略-IRule"><a href="#2-3-负载均衡策略-IRule" class="headerlink" title="2.3. 负载均衡策略 IRule"></a>2.3. 负载均衡策略 IRule</h2><p>在刚才的代码中，可以看到<span style="background-color:#ff00ff">获取服务使通过一个 <code>getServer</code> 方法来做负载均衡</span>:</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224002.png" alt="image.png"></p><p>我们继续跟入：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223958.png" alt="image.png"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223953.png" alt="image.png"></p><p>我们看看这个 rule 是谁：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223950.png" alt="image.png"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code>，看类的介绍：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223945.png" alt="image.png"></p><p>这不就是轮询的意思嘛。<br>到这里，整个负载均衡的流程我们就清楚了。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4. 总结"></a>2.4. 总结</h2><p><span style="display:none">%%<br>▶49.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230312-1455%%</span>❕ ^pxs57b</p><p>SpringCloudRibbon 的底层采用了一个<span style="background-color:#ff0000">拦截器</span>，<span style="background-color:#ff00ff">拦截了 RestTemplate 发出的请求，对地址做了修改</span>。用一幅图来总结一下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224511.png" alt="image.png"></p><p>基本流程如下：</p><ol><li><code>LoadBalancerIntercepor</code> 拦截我们的 RestTemplate 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求 url 中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li><code>Eureka</code> 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> <span style="background-color:#ff00ff">修改请求地址</span>，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1">http://localhost:8081/user/1</a>，发起真实请求</li></ol><h1 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="3. 负载均衡策略"></a>3. 负载均衡策略</h1><h2 id="3-1-负载均衡策略"><a href="#3-1-负载均衡策略" class="headerlink" title="3.1. 负载均衡策略"></a>3.1. 负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304222952.png" alt="image.png"></p><p>不同规则的含义如下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305071024.png" alt="image.png"></p><p>默认的实现就是 <span style="background-color:#ff00ff">ZoneAvoidanceRule</span>，是一种轮询方案</p><h2 id="3-2-详细介绍"><a href="#3-2-详细介绍" class="headerlink" title="3.2. 详细介绍"></a>3.2. 详细介绍</h2><p><strong>IRule</strong><br>这是所有负载均衡策略的父接口，里边的核心方法就是 choose 方法，用来选择一个服务实例。<br><strong>AbstractLoadBalancerRule</strong><br>AbstractLoadBalancerRule 是一个抽象类，里边主要定义了一个 ILoadBalancer，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。</p><h3 id="3-2-1-RandomRule"><a href="#3-2-1-RandomRule" class="headerlink" title="3.2.1. RandomRule"></a>3.2.1. RandomRule</h3><p>看名字就知道，这种负载均衡策略就是<span style="background-color:#ffff00">随机选择一个服务实例</span>，看源码我们知道，在 RandomRule 的无参构造方法中初始化了一个 Random 对象，然后在它重写的 choose 方法又调用了 choose(ILoadBalancer lb, Object key) 这个重载的 choose 方法，在这个重载的 choose 方法中，&#x3D;&#x3D;每次利用 random 对象生成一个不大于服务实例总数的随机数&#x3D;&#x3D;，并将该数作为下标所以获取一个服务实例。</p><h3 id="3-2-2-RoundRobinRule"><a href="#3-2-2-RoundRobinRule" class="headerlink" title="3.2.2. RoundRobinRule"></a>3.2.2. RoundRobinRule</h3><p>RoundRobinRule 这种负载均衡策略叫做<span style="background-color:#ffff00">线性轮询负载均衡策略</span>。这个类的 choose(ILoadBalancer lb, Object key) 函数整体逻辑是这样的：开启一个计数器 count，在 while 循环中遍历服务清单，获取清单之前先通过 incrementAndGetModulo 方法获取一个下标，这个下标是一个不断自增长的数先加 1 然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加 1，如果连续 10 次都没有取到服务，则会报一个警告 <code>No available alive servers after 10 tries from load balancer: XXXX</code></p><h3 id="3-2-3-RetryRule（在轮询的基础上进行重试）"><a href="#3-2-3-RetryRule（在轮询的基础上进行重试）" class="headerlink" title="3.2.3. RetryRule（在轮询的基础上进行重试）"></a>3.2.3. RetryRule（在轮询的基础上进行重试）</h3><p>看名字就知道这种负载均衡策略带有重试功能。首先 RetryRule 中又定义了一个 subRule，它的实现类是 RoundRobinRule，然后在 RetryRule 的 choose(ILoadBalancer lb, Object key) 方法中，每次还是采用 RoundRobinRule 中的 choose 规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为 null 或者已经失效，则<span style="background-color:#00ff00">在失效时间 deadline 之前不断的进行重试</span>（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过了 deadline 还是没取到则会返回一个 null。</p><h3 id="3-2-4-WeightedResponseTimeRule"><a href="#3-2-4-WeightedResponseTimeRule" class="headerlink" title="3.2.4. WeightedResponseTimeRule"></a>3.2.4. WeightedResponseTimeRule</h3><p>（权重 —nacos 的 NacosRule ，Nacos 还扩展了一个自己的基于配置的权重扩展）<br>WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，在 WeightedResponseTimeRule 中对 RoundRobinRule 的功能进行了扩展，<br>WeightedResponseTimeRule 中会根据每一个实例的运行情况来给计算出该实例的一个权重，然后在挑选实例的时候则根据权重进行挑选，这样能<br>够实现更优的实例调用。WeightedResponseTimeRule 中有一个名叫 DynamicServerWeightTask 的定时任务，默认情况下每隔 30 秒会计算一次<br>各个服务实例的权重，权重的计算规则也很简单，<span style="background-color:#00ff00">如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大</span>。</p><h3 id="3-2-5-ClientConfigEnabledRoundRobinRule"><a href="#3-2-5-ClientConfigEnabledRoundRobinRule" class="headerlink" title="3.2.5. ClientConfigEnabledRoundRobinRule"></a>3.2.5. ClientConfigEnabledRoundRobinRule</h3><p>ClientConfigEnabledRoundRobinRule 选择策略的实现很简单，内部定义了 RoundRobinRule，choose 方法还是采用了 RoundRobinRule 的<br>choose 方法，所以它的选择策略<span style="background-color:#00ff00">和 RoundRobinRule 的选择策略一致</span>，不赘述。</p><h3 id="3-2-6-BestAvailableRule"><a href="#3-2-6-BestAvailableRule" class="headerlink" title="3.2.6. BestAvailableRule"></a>3.2.6. BestAvailableRule</h3><p>BestAvailableRule 继承自 ClientConfigEnabledRoundRobinRule，它在 ClientConfigEnabledRoundRobinRule 的基础上主要增加了根据<br>loadBalancerStats 中保存的服务实例的状态信息来<span style="background-color:#00ff00">过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用</span>。然而<br>loadBalancerStats 有可能为 null，如果 loadBalancerStats 为 null，则 BestAvailableRule 将采用它的父类即<br>ClientConfigEnabledRoundRobinRule 的服务选取策略（线性轮询）。</p><h3 id="3-2-7-ZoneAvoidanceRule"><a href="#3-2-7-ZoneAvoidanceRule" class="headerlink" title="3.2.7. ZoneAvoidanceRule"></a>3.2.7. ZoneAvoidanceRule</h3><p><span style="background-color:#ff00ff">默认规则，复合判断 server 所在区域的性能和 server 的可用性选择服务器</span><br>ZoneAvoidanceRule 是 PredicateBasedRule 的一个实现类，只不过这里多一个过滤条件，ZoneAvoidanceRule 中的过滤条件是以<br>ZoneAvoidancePredicate 为主过滤条件和以<br>AvailabilityPredicate 为次过滤条件组成的一个叫做 CompositePredicate 的组合过滤条件，过滤成功之后，继续采用线性轮询<br>(RoundRobinRule) 的方式从过滤结果中选择一个出来。<br>AvailabilityFilteringRule（先过滤掉故障实例，再选择并发较小的实例）<br> 过滤掉一直连接失败的被标记为 circuit tripped 的后端 Server，并过滤掉那些高并发的后端 Server 或者使用一个 AvailabilityPredicate 来<br>包含过滤 server 的逻辑，其实就是检查 status 里记录的各个 Server 的运行状态</p><h2 id="3-3-自定义负载均衡策略"><a href="#3-3-自定义负载均衡策略" class="headerlink" title="3.3. 自定义负载均衡策略"></a>3.3. 自定义负载均衡策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：<br><span style="background-color:#ffff00">这是一种全局配置，不推荐</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Bean  <br>public IRule randomRule()&#123;  <br>    return new RandomRule();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：<br><span style="background-color:#00ff00">按服务配置，更灵活</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  <br>  ribbon:  <br>    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 <br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意</strong>，<span style="background-color:#ff00ff">一般用默认的负载均衡规则，不做修改</span>。</p></blockquote><h1 id="4-饥饿加载"><a href="#4-饥饿加载" class="headerlink" title="4. 饥饿加载"></a>4. 饥饿加载</h1><p><span style="display:none">%%<br>▶48.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230312-1358%%</span>❕ ^x4qqqw</p><p>Ribbon <span style="background-color:#ff00ff">默认是采用懒加载</span>，即<span style="background-color:#ff00ff">第一次访问时才会去创建</span> <code>LoadBalanceClient</code>，请求时间会很长。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312135815.png" alt="image.png"></p><p><span style="background-color:#ff00ff">而饥饿加载则会在项目启动时创建，降低第一次访问的耗时</span>，通过下面配置开启饥饿加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ribbon:    <br>  eager-load:    <br>    enabled: true    <br>    clients: userservice<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312140030.png" alt="image.png"></p><h1 id="5-重试机制"><a href="#5-重试机制" class="headerlink" title="5. 重试机制"></a>5. 重试机制</h1><span style="display:none">- [ ] 🚩 - 重试机制 - 🏡 2023-03-12 18:41</span>#todo<h1 id="6-RestTemplate"><a href="#6-RestTemplate" class="headerlink" title="6. RestTemplate"></a>6. RestTemplate</h1><h2 id="6-1-是什么"><a href="#6-1-是什么" class="headerlink" title="6.1. 是什么"></a>6.1. 是什么</h2><p>RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法, 能够大大提高客户端的编写效率。</p><p>调用 RestTemplate 的默认构造函数，RestTemplate 对象在底层通过使用 java.net 包下的实现创建 HTTP 请求，可以通过使用 ClientHttpRequestFactory 指定不同的 HTTP 请求方式。</p><p>ClientHttpRequestFactory 接口主要提供了两种实现方式</p><ol><li>一种是 SimpleClientHttpRequestFactory，使用 J2SE 提供的方式（既 java.net 包提供的方式）创建底层的 Http 请求连接。</li><li>一种方式是使用 HttpComponentsClientHttpRequestFactory 方式，底层使用 HttpClient 访问远程的 Http 服务，使用 HttpClient 可以配置连接池和证书等信息。</li></ol><p>RestTemplate 的核心之一 Http Client。</p><p>目前通过 RestTemplate 的源码可知，RestTemplate 可支持多种 Http Client 的 http 的访问，如下所示：</p><ul><li>基于 JDK HttpURLConnection 的 SimpleClientHttpRequestFactory，默认。</li><li>基于 Apache HttpComponents Client 的 HttpComponentsClientHttpRequestFactory</li><li>基于 OkHttp3 的 OkHttpClientHttpRequestFactory。</li><li>基于 Netty4 的 Netty4ClientHttpRequestFactory。</li></ul><p>其中 HttpURLConnection 和 HttpClient 为原生的网络访问类，OkHttp3 采用了 OkHttp3 的框架，Netty4 采用了 Netty 框架。</p><h2 id="6-2-配置"><a href="#6-2-配置" class="headerlink" title="6.2. 配置"></a>6.2. 配置</h2><h3 id="6-2-1-RestTempate-的访问的超时设置"><a href="#6-2-1-RestTempate-的访问的超时设置" class="headerlink" title="6.2.1. RestTempate 的访问的超时设置"></a>6.2.1. RestTempate 的访问的超时设置</h3><p>例如，我用的是 Httpclient 的连接池，RestTemplate 的超时设置依赖 HttpClient 的内部的三个超时时间设置。</p><p>HttpClient 内部有三个超时时间设置：连接池获取可用连接超时，连接超时，读取数据超时：</p><p><strong>1.setConnectionRequestTimeout 从连接池中获取可用连接超时：设置从 connect Manager 获取 Connection 超时时间，单位毫秒。</strong></p><p>HttpClient 中的要用连接时尝试从连接池中获取，若是在等待了一定的时间后还没有获取到可用连接（比如连接池中没有空闲连接了）则会抛出获取连接超时异常。</p><p><strong>2.连接目标超时 connectionTimeout，单位毫秒。</strong></p><p>指的是连接目标 url 的连接超时时间，即客服端发送请求到与目标 url 建立起连接的最大时间。如果在该时间范围内还没有建立起连接，则就抛出 connectionTimeOut 异常。</p><p>如测试的时候，将 url 改为一个不存在的 url：“<a href="http://test.com”/">http://test.com”</a> ，超时时间 3000ms 过后，系统报出异常：   org.apache.commons.httpclient.ConnectTimeoutException:The host did not accept the connection within timeout of 3000 ms</p><p><strong>3.等待响应超时（读取数据超时）socketTimeout ，单位毫秒。</strong></p><p>连接上一个 url 后，获取 response 的返回等待时间 ，即在与目标 url 建立连接后，等待放回 response 的最大时间，在规定时间内没有返回响应的话就抛出 SocketTimeout。</p><p>测试时，将 socketTimeout 设置很短，会报等待响应超时。</p><p>我遇到的问题，restTemplate 请求到一个高可用的服务时，返回的超时时间是设置值的 2 倍，是因为负载均衡器返回的重定向，导致 httpClient 底层认为没有超时，又请求一次，如果负载均衡器下有两个节点，就耗费 connectionTimeout 的双倍时间。</p><h2 id="6-3-连接池"><a href="#6-3-连接池" class="headerlink" title="6.3. 连接池"></a>6.3. 连接池</h2><p><a href="https://zhuanlan.zhihu.com/p/384627133">https://zhuanlan.zhihu.com/p/384627133</a></p><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><h2 id="8-1-黑马程序员"><a href="#8-1-黑马程序员" class="headerlink" title="8.1. 黑马程序员"></a>8.1. 黑马程序员</h2><p>微服务开发框架 SpringCloud+RabbitMQ+Docker+Redis+ 搜索 + 分布式微服务全技术栈课程 ^4ps1v8</p><h3 id="8-1-1-视频"><a href="#8-1-1-视频" class="headerlink" title="8.1.1. 视频"></a>8.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=17&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=17&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-1-2-资料"><a href="#8-1-2-资料" class="headerlink" title="8.1.2. 资料"></a>8.1.2. 资料</h3><p>[[SpringCloud01]]</p><h2 id="8-2-其他"><a href="#8-2-其他" class="headerlink" title="8.2. 其他"></a>8.2. 其他</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210925135730907.png" alt="image-20210925135730907"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？&lt;/p&gt;
&lt;h1 id=&quot;1-负载均衡原理&quot;&gt;&lt;a href=&quot;#1-负载均衡原理&quot; class=&quot;headerlink&quot; title=&quot;1. 负载均衡原理&quot;&gt;&lt;/a&gt;1. 负载均衡</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>服务注册与发现-12、Zookeeper</title>
    <link href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-12%E3%80%81Zookeeper/"/>
    <id>https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-12%E3%80%81Zookeeper/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.712Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-节点类型"><a href="#1-节点类型" class="headerlink" title="1. 节点类型"></a>1. 节点类型</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327132528.png" alt="image.png"></p><h1 id="2-选举过程"><a href="#2-选举过程" class="headerlink" title="2. 选举过程"></a>2. 选举过程</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1. 概述"></a>2.1. 概述</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327145406.png" alt="image.png"></p><h2 id="2-2-初始化选举"><a href="#2-2-初始化选举" class="headerlink" title="2.2. 初始化选举"></a>2.2. 初始化选举</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327131555.png" alt="image.png"></p><h2 id="2-3-崩溃恢复"><a href="#2-3-崩溃恢复" class="headerlink" title="2.3. 崩溃恢复"></a>2.3. 崩溃恢复</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327131737.png" alt="image.png"></p><h1 id="3-写数据流程"><a href="#3-写数据流程" class="headerlink" title="3. 写数据流程"></a>3. 写数据流程</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327133951.png" alt="image.png"></p><p>如果是请求的 leader，则最后是由 leader 通知 Client 数据写成功了。</p><h1 id="4-数据同步"><a href="#4-数据同步" class="headerlink" title="4. 数据同步"></a>4. 数据同步</h1><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002122124593.png" alt="image-20211002122124593"></p><h1 id="5-监听器原理"><a href="#5-监听器原理" class="headerlink" title="5. 监听器原理"></a>5. 监听器原理</h1><h2 id="5-1-Watch-机制"><a href="#5-1-Watch-机制" class="headerlink" title="5.1. Watch 机制"></a>5.1. Watch 机制</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327173040.png" alt="image.png"></p><h3 id="5-1-1-详细逻辑"><a href="#5-1-1-详细逻辑" class="headerlink" title="5.1.1. 详细逻辑"></a>5.1.1. 详细逻辑</h3><p>Zookeeper 是一个分布式协调组件，为分布式架构下的多个应用组件提供了顺序访问控制能力。它的数据存储采用了类似于文件系统的树形结构，以节点的方式来管理存储在 Zookeeper 上的数据。</p><p>Zookeeper 提供了一个 Watch 机制，可以让客户端感知到 Zookeeper Server 上存储的数据变化，这样一种机制可以让 Zookeeper 实现很多的场景，比如配置中心、注册中心等。</p><p>Watch 机制采用了 <span style="background-color:#ff00ff">Push 的方式</span>来实现，也就是说客户端和 Zookeeper Server 会建立一个长连接，一旦监听的指定节点发生了变化，就会通过这个长连接把变化的事件推送给客户端。<br>Watch 的具体流程分为几个部分：<br>首先，是客户端通过指定命令比如 exists、get，对特定路径增加 watch 然后服务端收到请求以后，<span style="background-color:#ff00ff">用 HashMap 保存这个客户端会话以及对应关注的节点路径</span>，同时客户端也会<span style="background-color:#ff00ff">使用 HashMap 存储指定节点和事件回调函数的对应关系</span>。<br>当服务端指定被 watch 的节点发生变化后，就会找到这个节点对应的会话，把变化的事件和节点信息发给这个客户端。 客户端收到请求以后，从 <code>ZkWatcherManager</code> 里面对应的回调方法进行调用， 完成事件变更的通知。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230601193046.png" alt="image.png"></p><h2 id="5-2-存在问题"><a href="#5-2-存在问题" class="headerlink" title="5.2. 存在问题"></a>5.2. 存在问题</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002131830455.png" alt="image-20211002131830455"></p><p><a href="https://www.bilibili.com/video/BV1t7411j7P7?p=4">https://www.bilibili.com/video/BV1t7411j7P7?p=4</a></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211017173229688.png" alt="image-20211017173229688"></p><h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6. 面试题"></a>6. 面试题</h1><h2 id="6-1-生产集群安装多少台-ZK"><a href="#6-1-生产集群安装多少台-ZK" class="headerlink" title="6.1. 生产集群安装多少台 ZK"></a>6.1. 生产集群安装多少台 ZK</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327145656.png" alt="image.png"></p><h1 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7. 应用场景"></a>7. 应用场景</h1><h2 id="7-1-集群管理-副本机制"><a href="#7-1-集群管理-副本机制" class="headerlink" title="7.1. 集群管理 - 副本机制"></a>7.1. 集群管理 - 副本机制</h2><p>在多个节点组成的集群中，为了保证集群的 HA 特性，每个节点都会冗余一份数据副本。这种情况下需要保证客户端访问集群中的任意一个节点都是最新的数据<br>Zookeeper 提供了 CP 的模型，来保证集群中的每个节点的数据一致性，当然 Zk 本身的集群并不是 CP 模型，而是顺序一致性模型，如果要保证 CP 特性，需要调用 <code>sync</code> 同步方法。</p><h2 id="7-2-master-选举"><a href="#7-2-master-选举" class="headerlink" title="7.2. master 选举"></a>7.2. master 选举</h2><p>在多个节点组成的集群中，为了降低集群数据同步的复杂度，一般会存在 Master 和 Slave 两种角色的节点，Master 负责事务和非事务请求处理，Slave 负责非事务请求处理。但是在分布式系统中如何确定某个节点是 Master 还是 Slave，也成了一个难度不小的挑战。基于这三类常见场景的需求，所以产生了 Zookeeper 这样一个中间件。它是一个分布式开源协调组件，简单来说，就是类似于一个裁判员的角色，专门负责协调和解决分布式系统中的各类问题。比如，针对上述描述的问题，Zookeeper 都可以解决。<br>Zookeeper 可以利用持久化节点来存储和管理其他集群节点的信息，从而进行 Master 选举机制。或者还可以利用集群中的有序节点特性，来实现 Master 选举。 <span style="background-color:#ff00ff">目前主流的 Kafka、Hbase、Hadoop 都是通过 Zookeeper 来实现集群节点的主从选举</span>。<br>总的来说，Zookeeper 就是经典的分布式数据一致性解决方案，致力于为分布式应用提供高性能、高可用，并且具有严格顺序访问控制能力的分布式协调服务。它底层通过基于 Paxos 算法演化而来的 ZAB 协议实现。</p><h2 id="7-3-监听服务器节点动态上下线案例⭐️🔴"><a href="#7-3-监听服务器节点动态上下线案例⭐️🔴" class="headerlink" title="7.3. 监听服务器节点动态上下线案例⭐️🔴"></a>7.3. 监听服务器节点动态上下线案例⭐️🔴</h2><p><span style="background-color:#ff00ff">先在集群上创建&#x2F;servers 永久节点</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327173040.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327143500.png" alt="image.png"></p><h2 id="7-4-分布式锁-临时顺序节点⭐️🔴"><a href="#7-4-分布式锁-临时顺序节点⭐️🔴" class="headerlink" title="7.4. 分布式锁 - 临时顺序节点⭐️🔴"></a>7.4. 分布式锁 - 临时顺序节点⭐️🔴</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230601-1007%%</span>❕ ^018oy5</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327144509.png" alt="image.png"></p><h1 id="8-相关算法"><a href="#8-相关算法" class="headerlink" title="8. 相关算法"></a>8. 相关算法</h1><p><a href="https://www.bilibili.com/video/BV1to4y1C7gw?p=31&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1to4y1C7gw?p=31&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="8-1-ZAB-协议"><a href="#8-1-ZAB-协议" class="headerlink" title="8.1. ZAB 协议"></a>8.1. ZAB 协议</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327170120.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327170926.png" alt="image.png"></p><h2 id="8-2-CAP-理论"><a href="#8-2-CAP-理论" class="headerlink" title="8.2. CAP 理论"></a>8.2. CAP 理论</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327170657.png" alt="image.png"></p><h1 id="9-参考与感谢"><a href="#9-参考与感谢" class="headerlink" title="9. 参考与感谢"></a>9. 参考与感谢</h1><h2 id="9-1-尚硅谷大数据"><a href="#9-1-尚硅谷大数据" class="headerlink" title="9.1. 尚硅谷大数据"></a>9.1. 尚硅谷大数据</h2><h3 id="9-1-1-视频"><a href="#9-1-1-视频" class="headerlink" title="9.1.1. 视频"></a>9.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1to4y1C7gw?p=4&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1to4y1C7gw?p=4&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="9-1-2-资料"><a href="#9-1-2-资料" class="headerlink" title="9.1.2. 资料"></a>9.1.2. 资料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">005</span>-分布式专题/012_Zookeeper的替身<br></code></pre></td></tr></table></figure><p><code>尚硅谷大数据技术之Zookeeper</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-节点类型&quot;&gt;&lt;a href=&quot;#1-节点类型&quot; class=&quot;headerlink&quot; title=&quot;1. 节点类型&quot;&gt;&lt;/a&gt;1. 节点类型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tay</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>面试专题-4、微服务</title>
    <link href="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98-4%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98-4%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.039Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-微服务架构的优缺点"><a href="#1-微服务架构的优缺点" class="headerlink" title="1. 微服务架构的优缺点"></a>1. 微服务架构的优缺点</h1><p>1. 演变而来（从单体应用演变过来）<br>2. 初期评估起手就上微服务</p><h2 id="1-1-面相服务-单一职责"><a href="#1-1-面相服务-单一职责" class="headerlink" title="1.1. 面相服务 单一职责"></a>1.1. 面相服务 单一职责</h2><p>避免业务重复开发</p><h2 id="1-2-分工协作"><a href="#1-2-分工协作" class="headerlink" title="1.2. 分工协作"></a>1.2. 分工协作</h2><p><strong>单体</strong>：影响开发效率,发布和迭代性差；项目启动慢，    每个人对整体的项目都要有所把握；  业务缩减后如果<br>语言不一致开发人员面临流失。<br><strong>拆分</strong>：提高开发效率和敏捷性；单个服务启动快， 专人处理专事专注自己的服务；  充分利用项目开发人员<br>（哪怕是不同的语言不同框架，不同存储技术，也可以）</p><h2 id="1-3-并发能力"><a href="#1-3-并发能力" class="headerlink" title="1.3. 并发能力"></a>1.3. 并发能力</h2><p><strong>单体</strong>：整体集群，易造成系统资源浪费；   之前下单功能要去集群无法准确评测最大并发量， 因为所有的<br>功能都在一起，无法准确预估扩容的服务器。<br><strong>拆分</strong>：服务集群，充分利用服务器资源；现在只需要针对下单服务进行压测就可以得到，下单功能具体<br>能承受的并发量最高水位，从而更准确的进行扩容。</p><h2 id="1-4-隔离能力"><a href="#1-4-隔离能力" class="headerlink" title="1.4. 隔离能力"></a>1.4. 隔离能力</h2><p>服务之间调用做好隔离、容错、降级，可以避免出现级联错误</p><h2 id="1-5-维护能力"><a href="#1-5-维护能力" class="headerlink" title="1.5. 维护能力"></a>1.5. 维护能力</h2><p><strong>单体</strong>：随着业务量增加，应用慢慢膨胀，后续可能会变得牵一发而动全身，难以维护。<br><strong>拆分</strong>：根据功能垂直拆分，责任更加分明，维护更加精准。<br>容错<br><strong>单体</strong>：单点故障，一个功能 OOM 导致整个应用都不可用<br><strong>拆分</strong>：弱依赖的服务出现故障，可以进行熔断（隔离） 依然不影响主业务正常使用</p><h2 id="1-6-扩展"><a href="#1-6-扩展" class="headerlink" title="1.6. 扩展"></a>1.6. 扩展</h2><p>单体：难以技术升级<br>拆分：新的服务采用任意新技术（技术多样性）</p><h2 id="1-7-缺点"><a href="#1-7-缺点" class="headerlink" title="1.7. 缺点"></a>1.7. 缺点</h2><h3 id="1-7-1-分布式"><a href="#1-7-1-分布式" class="headerlink" title="1.7.1. 分布式"></a>1.7.1. 分布式</h3><p>分布式系统较难编程，因为远程调用速度很慢，并且总是面临失败的风险。对于开发人员的技术要求更高</p><h3 id="1-7-2-最终一致性"><a href="#1-7-2-最终一致性" class="headerlink" title="1.7.2. 最终一致性"></a>1.7.2. 最终一致性</h3><p>对于分布式系统而言，保持强一致性非常困难，这意味着每个人都必须管理最终一致性。</p><h3 id="1-7-3-运维复杂性"><a href="#1-7-3-运维复杂性" class="headerlink" title="1.7.3. 运维复杂性"></a>1.7.3. 运维复杂性</h3><p>微服务必定带来开发、上线、运维的复杂度的提高，如果说单体应用复杂度为 10，实施了微服务后的复杂度将是 100，<br>配备了相应的工具和平台后，可以将复杂度降低到 50，但仍然比单体复杂的多。</p><h3 id="1-7-4-隐式接口"><a href="#1-7-4-隐式接口" class="headerlink" title="1.7.4. 隐式接口"></a>1.7.4. 隐式接口</h3><p>服务和服务之间通过接口来“联系”，当某一个服务更改接口格式时，可能涉及到此接口的所有服务都需要做调整。</p><h3 id="1-7-5-重复劳动"><a href="#1-7-5-重复劳动" class="headerlink" title="1.7.5. 重复劳动"></a>1.7.5. 重复劳动</h3><p>在很多服务中可能都会使用到同一个功能，而这一功能点没有足够大到提供一个服务的程度，这个时候可能不同的服务<br>团队都会单独开发这一功能，重复的业务逻辑，这违背了良好的软件工程中的很多原则。</p><h1 id="2-SOA、分布式、微服务之间有什么关系和区别"><a href="#2-SOA、分布式、微服务之间有什么关系和区别" class="headerlink" title="2. SOA、分布式、微服务之间有什么关系和区别"></a>2. SOA、分布式、微服务之间有什么关系和区别</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225160809.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225160151.png" alt="image.png"></p><ol><li>分布式架构是指将单体架构中的各个部分拆分，然后部署不同的机器或进程中去，SOA 和微服务基本上都是分布式架构的</li><li>SOA 是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用</li><li>微服务是一种更彻底的面向服务的架构，将系统中各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构</li></ol><h1 id="3-微服务怎么拆分"><a href="#3-微服务怎么拆分" class="headerlink" title="3. 微服务怎么拆分"></a>3. 微服务怎么拆分</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225184236.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225184647.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225194822.png" alt="image.png"></p><p>1、高内聚低耦合，职责单一，服务粒度适中，服务不要太细（有的团队甚至一个接口一个服务，一个表一个服务）<br>2、以业务模型切入：比如产品，用户，订单为一个模型来切入）<br>3、演进式拆分：刚开始不要划分太细，可以随着迭代过程来逐步优化。  </p><p>微服务 1.0，仅使用注册发现，基于 SpringCloud 或者 Dubbo 进行开发，目前意图实施微服务的传统企业大部分处于这个阶段，或者正从单体应用，向这个阶段过渡，处于 0.5 的阶段；<br>微服务 2.0，使用了熔断，限流，降级等服务治理策略，并配备完整微服务工具和平台，目前大部分互联网企业处于这个阶段。传统企业中的领头羊，在做互联网转型的过程中，正在向这个阶段过渡，处于 1.5 的阶段；<br>微服务 3.0，Service Mesh 将服务治理作为通用组件，下沉到平台层实现，使得应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现 AIOps 和智能调度。目前一线互联网公司在进行这方面的尝试</p><h1 id="4-常用分布式组件及作用"><a href="#4-常用分布式组件及作用" class="headerlink" title="4. 常用分布式组件及作用"></a>4. 常用分布式组件及作用</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225170435.png" alt="image.png"></p><h1 id="5-分布式之日志监控方案"><a href="#5-分布式之日志监控方案" class="headerlink" title="5. 分布式之日志监控方案"></a>5. 分布式之日志监控方案</h1><h1 id="6-SpringCloud-常见组件"><a href="#6-SpringCloud-常见组件" class="headerlink" title="6. SpringCloud 常见组件"></a>6. SpringCloud 常见组件</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225224605.png" alt="image.png"></p><h2 id="6-1-技术对比"><a href="#6-1-技术对比" class="headerlink" title="6.1. 技术对比"></a>6.1. 技术对比</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312114119.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312114225.png" alt="image.png"></p><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><h2 id="8-1-黑马程序员-SpringCloud"><a href="#8-1-黑马程序员-SpringCloud" class="headerlink" title="8.1. 黑马程序员 SpringCloud"></a>8.1. 黑马程序员 SpringCloud</h2><h3 id="8-1-1-视频"><a href="#8-1-1-视频" class="headerlink" title="8.1.1. 视频"></a>8.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=163&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=163&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-1-2-资料"><a href="#8-1-2-资料" class="headerlink" title="8.1.2. 资料"></a>8.1.2. 资料</h3><p>[[微服务常见面试题]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-微服务架构的优缺点&quot;&gt;&lt;a href=&quot;#1-微服务架构的优缺点&quot; class=&quot;headerlink&quot; title=&quot;1. 微服务架构的优缺点&quot;&gt;&lt;/a&gt;1. 微服务架构的优缺点&lt;/h1&gt;&lt;p&gt;1. 演变而来（从单体应用演变过来）&lt;br&gt;2. 初期</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试专题-6、分布式组件</title>
    <link href="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98-6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    <id>https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98-6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.040Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1. 服务注册与发现"></a>1. 服务注册与发现</h1><a href="/2023/03/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-6%E3%80%81Nacos/" title="服务注册与发现-6、Nacos">服务注册与发现-6、Nacos</a><h1 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h1><a href="/2023/03/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-8%E3%80%81%E7%BD%91%E5%85%B3-GateWay/" title="分布式专题-8、网关-GateWay">分布式专题-8、网关-GateWay</a><h1 id="3-服务熔断降级限流"><a href="#3-服务熔断降级限流" class="headerlink" title="3. 服务熔断降级限流"></a>3. 服务熔断降级限流</h1><h2 id="3-1-服务雪崩"><a href="#3-1-服务雪崩" class="headerlink" title="3.1. 服务雪崩"></a>3.1. 服务雪崩</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301155601.png" alt="image.png"></p><p><strong>服务雪崩</strong>： 因服务提供者的不可用导致服务调用者的不可用, 并将不可用逐渐放大的过程，就叫服务雪崩效应<br><strong>解决方式</strong>：<br><span style="background-color:#00ff00">通过熔断机制</span>，当一个服务挂了，被影响的服务能够及时熔断，使用 Fallback 数据保证流程在非关键服务不可用的情况下，仍然可以进行。<br><span style="background-color:#00ff00">通过线程池和消息队列机制实现异步化</span>，允许服务快速失败，当一个服务因为过慢而阻塞，被影响服务可以在超时后快速失败，不会影响整个调用链路。</p><h2 id="3-2-服务限流"><a href="#3-2-服务限流" class="headerlink" title="3.2. 服务限流"></a>3.2. 服务限流</h2><p>是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。</p><h2 id="3-3-服务熔断"><a href="#3-3-服务熔断" class="headerlink" title="3.3. 服务熔断"></a>3.3. 服务熔断</h2><p>当服务 A 调用的某个服务 B 不可用时，上游服务 A 为了保证自己不受影响，及时切断与服务 B 的通讯。以防服务雪崩。防止服务雪崩一种措施。</p><h2 id="3-4-服务降级"><a href="#3-4-服务降级" class="headerlink" title="3.4. 服务降级"></a>3.4. 服务降级</h2><p>提前预想好另外一种兜底措施，可以进行后期补救。直到服务 B 恢复，再恢复和 B 服务的正常通讯。当被调用服务不可用时的一种兜底措施。</p><h3 id="3-4-1-哪些场景用到了限流、降级？怎么配的？"><a href="#3-4-1-哪些场景用到了限流、降级？怎么配的？" class="headerlink" title="3.4.1. 哪些场景用到了限流、降级？怎么配的？"></a>3.4.1. 哪些场景用到了限流、降级？怎么配的？</h3><h4 id="3-4-1-1-服务降级的预案"><a href="#3-4-1-1-服务降级的预案" class="headerlink" title="3.4.1.1. 服务降级的预案"></a>3.4.1.1. 服务降级的预案</h4><p>在进行降级之前要对系统进行梳理，提前将一些 不重要 或 不紧急 的服务（弱依赖）或任务进行服务的 延迟使用 或 暂停使用。 （积分）<br>看看哪些服务是必须誓死保护，哪些系统是能够丢卒保帅；具体可以参考日志级别设置预案：<br><strong>一般</strong>：有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br><strong>警告</strong>：有些服务在一段时间内成功率有波动（如在 95~100% 之间），可以自动降级或人工降级，并发送告警；<br><strong>错误</strong>：可用率低于 90%，或者连接池被占用满了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br><strong>严重错误</strong>：因为特殊原因数据错误了，此时需要紧急人工降级 </p><h4 id="3-4-1-2-QPS-并发配置"><a href="#3-4-1-2-QPS-并发配置" class="headerlink" title="3.4.1.2. QPS 并发配置"></a>3.4.1.2. QPS 并发配置</h4><ol><li>测试会提供准确的数据；</li><li>自己算： 二八法则<br>计算关系：<br>QPS &#x3D; 并发量 &#x2F; 平均响应时间<br>并发量 &#x3D; QPS * 平均响应时间<br>根据以上计算关系，我们来预估下单日访问量在 1000W 需要多大的 QPS 来支持：<br>通常情况下，80% 的访问量集中在 20% 的时间，算一下这 1000w pv 实际需要机器达到多少 qps 才能满足，<br>qps &#x3D; (1000w * 0.8) &#x2F; (24 * 3600 * 0.2)<br>qps &#x3D; 462.9</li><li>根据压力测试的反馈，单台机子的 QPS 是多少，利用以上结果就可以算出需要几台机器或大致推算出需不需要使用缓存配置<br>方案一： 使用集群服务器 不使用缓存服务器<br>方案二： 使用集群服务器 同时使用缓存服务器 (推荐)<br>例子：<br> 每秒可以处理的请求数 QPS（TPS）：每秒钟可以处理的请求或者事务的数量。<br>    并发数： 系统同一时候处理的请求数量（事务数）<br>    响应时间：  一般取平均响应时间<br>QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间<br>并发数 &#x3D; QPS<em>平均响应时间<br>例子:<br> 一个典型的上班签到系统，早上 8 点上班。7 点半到 8 点这 30 分钟的时间里用户会登录签到系统进行签到。公司员工为 1000<br>人，平均每一个员上登录签到系统的时长为 5 分钟。能够用以下的方法计算。<br>（1）QPS &#x3D; 1000&#x2F;(30×60) 事务&#x2F;秒<br>（2）平均响应时间为 &#x3D; 5×60  秒<br>（3）并发数&#x3D; QPS</em> 平均响应时间 &#x3D; 1000&#x2F;(30×60) ×(5×60)&#x3D;166.7<br>再看如果老板要求实现多少并发数，在反推出机器需要多少 QPS，看是否集群配置。</li></ol><h2 id="3-5-Sentinal"><a href="#3-5-Sentinal" class="headerlink" title="3.5. Sentinal"></a>3.5. Sentinal</h2><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/" title="服务治理-10、限流熔断降级(服务保护)-Sentinel">服务治理-10、限流熔断降级(服务保护)-Sentinel</a><h1 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4. 分布式事务"></a>4. 分布式事务</h1><p>可以参考： <a href="/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="事务-2、分布式事务">事务-2、分布式事务</a> ^lnql61</p><h2 id="4-1-Seata-的实现原理-AT2PC-变种⭐️🔴"><a href="#4-1-Seata-的实现原理-AT2PC-变种⭐️🔴" class="headerlink" title="4.1. Seata 的实现原理 -AT2PC 变种⭐️🔴"></a>4.1. Seata 的实现原理 -AT2PC 变种⭐️🔴</h2><p><span style="display:none">%%<br>▶60.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-1852%%</span>❕ ^a3vjds</p><p>分布式事务： <a href="https://www.jianshu.com/p/044e95223a17">https://www.jianshu.com/p/044e95223a17</a>  ⭐️🔴<br>在应用中 Seata 整体事务逻辑基于两阶段提交的模型，核心概念包含三个角色：<br>TC：事务协调者，即独立运行的 seata-server，用于接收事务注册，提交和回滚。<br>TM：事务发起者。用来告诉 TC 全局事务的开始，提交，回滚。<br>RM：事务资源，每一个 RM 都会作为一个分支事务注册在 TC。<br><strong>AT(Auto Transaction) 模式</strong></p><h2 id="4-2-执行流程"><a href="#4-2-执行流程" class="headerlink" title="4.2. 执行流程"></a>4.2. 执行流程</h2><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230404-2144%%</span>❕ ^14aw6x</p><p>假设运行：update product set name &#x3D; ‘GTS’ where name &#x3D; ‘TXC’;    &#x2F;&#x2F; id&#x3D;1</p><h3 id="4-2-1-TM-开启全局事务"><a href="#4-2-1-TM-开启全局事务" class="headerlink" title="4.2.1. TM 开启全局事务"></a>4.2.1. TM 开启全局事务</h3><p> TM 向 TC 申请开启一个全局事务，全局事务创建并生成一个全局唯一的 XID。<br> <span style="background-color:#ff00ff">XID 在微服务调用链路的上下文中传播</span>。</p><h3 id="4-2-2-第一阶段-各-RM-执行并提交分支事务"><a href="#4-2-2-第一阶段-各-RM-执行并提交分支事务" class="headerlink" title="4.2.2. 第一阶段 - 各 RM 执行并提交分支事务"></a>4.2.2. 第一阶段 - 各 RM 执行并提交分支事务</h3><p>1. 解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。<br>2. 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。 <code>select * from product where name = &#39;TXC&#39; </code> 镜像前数据<br>3. 执行业务 SQL：更新这条记录的 name 为 ‘GTS’。<br>4. 查询后镜像：根据前镜像的结果，通过 主键 定位数据。<code>select * from produc where name = &#39;TXC&#39; </code> 镜像后数据<br>5. RM 在同一个本地事务中执行业务 SQL 和 UNDO_LOG 数据的插入<br>把<span style="background-color:#ff00ff">前后镜像数据以及业务 SQL 相关的信息</span>组成一条回滚日志记录，插入到 UNDO_LOG 表中。<br><span style="background-color:#ff0000">提交前</span>，<span style="background-color:#ff00ff">RM 向 TC 注册分支</span>：<span style="background-color:#ff0000">申请</span> product 表中，主键值等于 1 的记录的<span style="background-color:#ff0000">全局锁</span> <br>如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向 TC 汇报本地事务执行失败。等待全局锁的情况如下图所示：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228173404.png" alt="image.png"></p><p>等不到全局锁回滚本地事务的情况，请看防止脏写的 3 种情况</p><p>6. <span style="background-color:#ff00ff">RM 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。释放本地锁，但此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。</span></p><h3 id="4-2-3-TM-发起全局决议"><a href="#4-2-3-TM-发起全局决议" class="headerlink" title="4.2.3. TM 发起全局决议"></a>4.2.3. TM 发起全局决议</h3><p>TM 将本地事务提交的结果上报给 TC。并向 TC 发起针对 XID 的全局提交或回滚决议。TC 根据所有的分支事务执行结果，向 RM 下发提交或回滚命令。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228135405.png" alt="image.png"></p><h3 id="4-2-4-第二阶段-TM-决议后通知-TC-发起全局提交"><a href="#4-2-4-第二阶段-TM-决议后通知-TC-发起全局提交" class="headerlink" title="4.2.4. 第二阶段 - TM 决议后通知 TC 发起全局提交"></a>4.2.4. 第二阶段 - TM 决议后通知 TC 发起全局提交</h3><p>TC 调度 XID 下管辖的全部分支事务完成提交请求</p><ol><li>RM 如果收到 TC 的提交命令，首先立即释放相关记录的全局锁 (其实锁是在 TC 端维护的)</li><li>然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，<span style="background-color:#00ff00">只是删除相应 UNDO LOG 记录而已</span>。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228172840.png" alt="image.png"></p><h3 id="4-2-5-第二阶段-TM-决议后通知-TC-发起全局回滚"><a href="#4-2-5-第二阶段-TM-决议后通知-TC-发起全局回滚" class="headerlink" title="4.2.5. 第二阶段 - TM 决议后通知 TC 发起全局回滚"></a>4.2.5. 第二阶段 - TM 决议后通知 TC 发起全局回滚</h3><p>TC 调度 XID 下管辖的全部分支事务完成回滚请求</p><ol><li>所有 RM 开启一个本地事务</li><li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li><li>数据校验：拿 UNDO LOG 中的<span style="background-color:#ff00ff">后镜与当前数据进行比较</span>，如果有不同，说明数据被当前全局事务之外的动作做了修改（出现脏写），转人工处理（Seata 因为无法感知这个脏写如何发生，此时只能打印日志和触发异常通知，告知用户需要人工介入） 。人工没有脏写就简单了：根据 UNDO LOG 中的<span style="background-color:#ff00ff">前镜像和业务 SQL 的相关信息</span>生成并执行回滚的语句</li><li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li><li><span style="background-color:#ff0000">最后释放相关记录的全局锁</span></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228173006.png" alt="image.png"></p><h2 id="4-3-GlobalTransactionScanner-原理"><a href="#4-3-GlobalTransactionScanner-原理" class="headerlink" title="4.3. @GlobalTransactionScanner 原理"></a>4.3. @GlobalTransactionScanner 原理</h2><p><a href="https://www.cnblogs.com/wxbty/p/10411190.html">https://www.cnblogs.com/wxbty/p/10411190.html</a></p><h2 id="4-4-Seata-的全局事务隔离级别⭐️🔴"><a href="#4-4-Seata-的全局事务隔离级别⭐️🔴" class="headerlink" title="4.4. Seata 的全局事务隔离级别⭐️🔴"></a>4.4. Seata 的全局事务隔离级别⭐️🔴</h2><p><span style="display:none">%%<br>▶59.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-1850%%</span>❕ ^mm3ts9</p><p>脏读脏写的解决方案<br><a href="https://seata.io/zh-cn/blog/seata-at-lock.html">https://seata.io/zh-cn/blog/seata-at-lock.html</a></p><h3 id="4-4-1-如何防止脏写"><a href="#4-4-1-如何防止脏写" class="headerlink" title="4.4.1. 如何防止脏写"></a>4.4.1. 如何防止脏写</h3><p><span style="display:none">%%<br>▶8.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1001%%</span>❕ ^qngn57</p><p>先来看一下使用 Seata AT 模式是怎么产生脏写的：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305095414.png"></p><p><em>注：分支事务执行过程省略其它过程。</em></p><p>业务一开启全局事务，其中包含分支事务 A（修改 A）和分支事务 B（修改 B），业务二修改 A，其中业务一执行分支事务 A 先获取本地锁，业务二则等待业务一执行完分支事务 A 之后，获得本地锁修改 A 并入库，业务一在执行分支事务时发生异常了，由于分支事务 A 的数据被业务二修改，导致业务一的全局事务无法回滚。</p><p>如何防止脏写？</p><h4 id="4-4-1-1-GlobalTransactional"><a href="#4-4-1-1-GlobalTransactional" class="headerlink" title="4.4.1.1. @GlobalTransactional"></a>4.4.1.1. @GlobalTransactional</h4><p>1、业务二执行时加 <code>@GlobalTransactional</code> 注解：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305095359.png"></p><p><em>注：分支事务执行过程省略其它过程。</em></p><p>业务二在执行全局事务过程中，分支事务 A <span style="background-color:#ff00ff">提交前注册分支事务获取全局锁</span>时，发现业务业务一全局锁还没执行完，因此业务二提交不了，抛异常回滚，所以不会发生脏写。</p><h4 id="4-4-1-2-GlobalLock"><a href="#4-4-1-2-GlobalLock" class="headerlink" title="4.4.1.2. @GlobalLock"></a>4.4.1.2. @GlobalLock</h4><p>2、业务二执行时加 <code>@GlobalLock</code> 注解：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305095351.png"></p><p><em>注：分支事务执行过程省略其它过程。</em></p><p>与 <code>@GlobalTransactional</code> 注解效果类似，只不过不需要开启全局事务，只在本地事务提交前，检查全局锁是否存在。</p><h4 id="4-4-1-3-GlobalLock-select-for-update"><a href="#4-4-1-3-GlobalLock-select-for-update" class="headerlink" title="4.4.1.3. @GlobalLock + select for update"></a>4.4.1.3. @GlobalLock + select for update</h4><p>2、业务二执行时加 <code>@GlobalLock</code> 注解 + <code>select for update</code> 语句：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305095340.png"></p><p>如果加了 <code>select for update</code> 语句，则会在 update 前检查全局锁是否存在，只有当全局锁释放之后，业务二才能开始执行 updateA 操作。</p><p>加 select for update 的作用是可以重试。</p><h3 id="4-4-2-如何防止脏读"><a href="#4-4-2-如何防止脏读" class="headerlink" title="4.4.2. 如何防止脏读"></a>4.4.2. 如何防止脏读</h3><p>Seata AT 模式的脏读是指在全局事务未提交前，被其它业务读到已提交的分支事务的数据，根本原因是 <span style="background-color:#ff00ff">Seata 默认的全局事务是读未提交</span></p><p>那么怎么避免脏读现象呢？</p><p>业务二查询 A 时加 <code>@GlobalLock</code> 注解 + <code>select for update</code> 语句：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305095324.png"></p><p>加 <code>select for update</code> 语句会在执行 SQL 前检查全局锁是否存在，只有当全局锁完成之后，才能继续执行 SQL，这样就防止了脏读。</p><h3 id="4-4-3-select-for-update"><a href="#4-4-3-select-for-update" class="headerlink" title="4.4.3. select for update"></a>4.4.3. select for update</h3><p>Seata 由于一阶段 RM 自动提交本地事务的原因，默认隔离级别为 Read Uncommitted。如果希望隔离级别为 Read Committed，那么可以使用 <code>SELECT...FOR UPDATE</code> 语句。<span style="background-color:#00ff00">Seata 引擎重写了 <code>SELECT...FOR UPDATE</code> 语句执行逻辑</span>，<code>SELECT...FOR UPDATE</code> 语句的执行<span style="background-color:#ff0000">会先申请全局锁</span>，如果全局锁被其他事务持有，则释放本地锁（回滚 <code>SELECT...FOR UPDATE</code> 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到全局锁拿到，即读取的相关数据是已提交的才返回。<br><span style="background-color:#00ff00">除了能够检查是否有全局锁</span>，<span style="background-color:#ff00ff">加 select for update 还有个好处，就是可以重试。</span></p><p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p><h2 id="4-5-集中管理全局锁的考虑"><a href="#4-5-集中管理全局锁的考虑" class="headerlink" title="4.5. 集中管理全局锁的考虑"></a>4.5. 集中管理全局锁的考虑</h2><p>全局锁是由 TC 也就是 server 来集中维护，而不是在数据库维护的。这样做有两点好处：</p><ul><li>一方面：锁的释放非常快，尤其是在全局提交的情况下，收到全局提交的请求，锁马上就释放掉了，不需要与 RM 或数据库进行一轮交互。</li><li>另外一方面：因为锁不是数据库维护的，从数据库层面看，数据没有锁定。这也就是给极端情况下，业务 <strong>降级</strong> 提供了方便，事务协调器异常导致的一部分异常事务，不会 block 后面业务的继续进行。</li></ul><h1 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5. 负载均衡"></a>5. 负载均衡</h1><h2 id="5-1-Ribbon-原理"><a href="#5-1-Ribbon-原理" class="headerlink" title="5.1. Ribbon 原理"></a>5.1. Ribbon 原理</h2><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/" title="分布式专题-5、负载均衡-Ribbon">分布式专题-5、负载均衡-Ribbon</a><h1 id="6-远程服务调用"><a href="#6-远程服务调用" class="headerlink" title="6. 远程服务调用"></a>6. 远程服务调用</h1><a href="/2023/03/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-7%E3%80%81%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8-Feign%E4%B8%8EOpenFeign/" title="分布式专题-7、远程调用-Feign与OpenFeign">分布式专题-7、远程调用-Feign与OpenFeign</a><h1 id="7-SpringCloudAlibaba"><a href="#7-SpringCloudAlibaba" class="headerlink" title="7. SpringCloudAlibaba"></a>7. SpringCloudAlibaba</h1><p>尚硅谷 2020-3.2 第二季最新课程 SpringCloud H 版 +SpringCloud Alibaba 构成</p><h1 id="8-实战经验"><a href="#8-实战经验" class="headerlink" title="8. 实战经验"></a>8. 实战经验</h1><h1 id="9-参考与感谢"><a href="#9-参考与感谢" class="headerlink" title="9. 参考与感谢"></a>9. 参考与感谢</h1><h2 id="9-1-黑马程序员"><a href="#9-1-黑马程序员" class="headerlink" title="9.1. 黑马程序员"></a>9.1. 黑马程序员</h2><p><span style="display:none">%%<br>▶46.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️%%</span>❕ ^n93hnw</p><h3 id="9-1-1-视频"><a href="#9-1-1-视频" class="headerlink" title="9.1.1. 视频"></a>9.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=173&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=173&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="9-1-2-资料"><a href="#9-1-2-资料" class="headerlink" title="9.1.2. 资料"></a>9.1.2. 资料</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/Users/Enterprise/0003-Architecture/005-分布式专题/1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程/<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/Users/taylor/Nutstore Files/Obsidian_data/pages/002-schdule/001-Arch/001-Subject/005-分布式专题/黑马资料-微服务架构的分布式事务控制解决方案<br></code></pre></td></tr></table></figure><h2 id="9-3-网络笔记"><a href="#9-3-网络笔记" class="headerlink" title="9.3. 网络笔记"></a>9.3. 网络笔记</h2><p>分布式事务： <a href="https://www.jianshu.com/p/044e95223a17">https://www.jianshu.com/p/044e95223a17</a>  ⭐️🔴</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-服务注册与发现&quot;&gt;&lt;a href=&quot;#1-服务注册与发现&quot; class=&quot;headerlink&quot; title=&quot;1. 服务注册与发现&quot;&gt;&lt;/a&gt;1. 服务注册与发现&lt;/h1&gt;&lt;a href=&quot;/2023/03/11/005-%E5%88%86%E5%</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>分布式专题-13、Dubbo</title>
    <link href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-13%E3%80%81Dubbo/"/>
    <id>https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-13%E3%80%81Dubbo/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.689Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Dubbo"><a href="#1-Dubbo" class="headerlink" title="1. Dubbo"></a>1. Dubbo</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1. 是什么"></a>1.1. 是什么</h2><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架。由 10 层模式构成，整个分层依赖由上至下。通过这张图我们也可以将 Dubbo 理解为三层模式：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230520214554.png" alt="image.png"></p><p>第一层的 Business 业务逻辑层由我们自己来提供接口和实现还有一些配置信息。<br>第二层的 RPC 调用的核心层负责封装和实现整个 RPC 的调用过程、负载均衡、集群容错、代理等核心功能。<br>第三层的 Remoting 则是对网络传输协议和数据转换的封装。</p><h2 id="1-2-核心能力-特性"><a href="#1-2-核心能力-特性" class="headerlink" title="1.2. 核心能力 (特性)"></a>1.2. 核心能力 (特性)</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512110804.png" alt="image.png"></p><h2 id="1-3-架构"><a href="#1-3-架构" class="headerlink" title="1.3. 架构"></a>1.3. 架构</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512111824.png" alt="image.png"></p><h2 id="1-4-协议"><a href="#1-4-协议" class="headerlink" title="1.4. 协议"></a>1.4. 协议</h2><h3 id="1-4-1-Dubbo-协议"><a href="#1-4-1-Dubbo-协议" class="headerlink" title="1.4.1. Dubbo 协议"></a>1.4.1. Dubbo 协议</h3><p>Dubbo 缺省协议采用<span style="background-color:#ff00ff">单一长连接和 NIO 异步通讯</span>，适合于<span style="background-color:#ff00ff">小数据量大并发</span>的服务调用，<span style="background-color:#ff00ff">以及服务消费者机器数远大于服务提供者机器数</span>的情况。</p><p>反之，Dubbo 缺省协议<span style="background-color:#ff0000">不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</span></p><p>缺省协议，使用基于 netty <code>3.2.5.Final</code> 和 hessian2 <code>3.2.1-fixed-2(Alibaba embed version)</code> 的 tbremoting 交互。</p><ul><li>连接个数：单连接</li><li>连接方式：长连接</li><li>传输协议：TCP</li><li>传输方式：NIO 异步传输</li><li><span style="background-color:#ff00ff">序列化：Hessian 二进制序列化</span></li><li>适用范围：<span style="background-color:#ff00ff">传入传出参数数据包较小（建议小于 100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</span></li><li>适用场景：常规远程服务方法调用</li></ul><h4 id="1-4-1-1-为什么不适合大文件"><a href="#1-4-1-1-为什么不适合大文件" class="headerlink" title="1.4.1.1. 为什么不适合大文件"></a>1.4.1.1. 为什么不适合大文件</h4><p><a href="https://blog.csdn.net/qq_43842093/article/details/126332133">https://blog.csdn.net/qq_43842093/article/details/126332133</a></p><h3 id="1-4-2-其他协议"><a href="#1-4-2-其他协议" class="headerlink" title="1.4.2. 其他协议"></a>1.4.2. 其他协议</h3><p>通信框架方面，Dubbo 默认采用了 Netty 作为通信框架。<br>通信协议方面，Dubbo 除了支持私有的 Dubbo 协议外，还支持 RMI 协议、Hession 协议、HTTP 协议、Thrift 协议等。<br>序列化格式方面，Dubbo 支持多种序列化格式，比如 Dubbo、Hession、JSON、 Kryo、FST 等。</p><h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230530154755.png" alt="image.png"></p><ol><li>服务启动的时候，provider 和 consumer 根据配置信息，连接到注册中心 register，分别向注册中心注册和订阅服务</li><li>register 根据服务订阅关系，返回 provider 信息到 consumer，同时 consumer 会把 provider 信息缓存到本地。如果信息有变更，consumer 会收到来自 register 的推送</li><li>consumer 生成代理对象，同时根据负载均衡策略，选择一台 provider ，同时定时向 monitor 记录接口的调用次数和时间信息</li><li>consumer 拿到代理对象之后，通过代理对象发起接口调用</li><li>provider 收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现</li></ol><h2 id="2-1-负载均衡⭐️🔴"><a href="#2-1-负载均衡⭐️🔴" class="headerlink" title="2.1. 负载均衡⭐️🔴"></a>2.1. 负载均衡⭐️🔴</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002222615305.png" alt="image-20211002222615305"></p><h2 id="2-2-超时与重试"><a href="#2-2-超时与重试" class="headerlink" title="2.2. 超时与重试"></a>2.2. 超时与重试</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327100224.png" alt="image.png"></p><p><span style="background-color:#ff00ff">默认使用 consumer 中的 timeout 为 1000ms</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327095831.png" alt="image.png"></p><p><span style="background-color:#ff00ff">该数字不包含刚开始的 1 次</span></p><h3 id="2-2-1-配置优先级"><a href="#2-2-1-配置优先级" class="headerlink" title="2.2.1. 配置优先级"></a>2.2.1. 配置优先级</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327100922.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327100959.png" alt="image.png"></p><h2 id="2-3-服务容错⭐️🔴"><a href="#2-3-服务容错⭐️🔴" class="headerlink" title="2.3. 服务容错⭐️🔴"></a>2.3. 服务容错⭐️🔴</h2><p><a href="https://www.bilibili.com/video/BV1t7411j7P7?p=15">https://www.bilibili.com/video/BV1t7411j7P7?p=15</a></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211018060627326.png" alt="image-20211018060627326"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002223619323.png" alt="image-20211002223619323"></p><h2 id="2-4-服务降级"><a href="#2-4-服务降级" class="headerlink" title="2.4. 服务降级"></a>2.4. 服务降级</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002223240884.png" alt="image-20211002223240884"></p><h2 id="2-5-延迟暴露"><a href="#2-5-延迟暴露" class="headerlink" title="2.5. 延迟暴露"></a>2.5. 延迟暴露</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211018060908252.png" alt="image-20211018060908252"></p><h2 id="2-6-线程模型"><a href="#2-6-线程模型" class="headerlink" title="2.6. 线程模型"></a>2.6. 线程模型</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211018061104632.png" alt="image-20211018061104632"></p><h2 id="3-注册中心"><a href="#3-注册中心" class="headerlink" title="3. 注册中心"></a>3. 注册中心</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214522.jpg" alt="image-20200422011315464"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214516.jpg" alt="image-20200422011522254"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214511.jpg" alt="image-20200422011945717"></p><h4 id="3-1-配置方式"><a href="#3-1-配置方式" class="headerlink" title="3.1. 配置方式"></a>3.1. 配置方式</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214446.jpg" alt="image-20200422084117654"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214424.jpg" alt="image-20200422084312824"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214417.jpg" alt="image-20200422084432841"></p><h1 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h1><h2 id="5-1-标签解析"><a href="#5-1-标签解析" class="headerlink" title="5.1. 标签解析"></a>5.1. 标签解析</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924073517589.png" alt="image-20210924073517589"></p><ol><li><p>启动容器的 main 方法执行时就会调用标签解析器<br> Spring 解析配置文件的总接口：<strong>BeanDefinitionParser</strong>，其中 Dubbo 的实现类为 <strong>DubboBeanDefinitionParser</strong>，其中的方法为 <strong>parse()</strong><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327215252.jpg" alt="image-20200413112454357"></p></li><li><p>在 DubboBeanDefinitionParser 创建时，有一个 <code>DubboNameSpaceHandler</code> 类的 init() 方法，会给每一个标签注册一个解析器，解析器中就绑定了 class 类别<br>   <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327215246.jpg" alt="image-20200413114008915"></p></li><li><p>在 DubboDefinitionParser 的 parse() 中就能根据标签找到对应的 bean 来封装配置文件中的信息。值得注意的是 service 标签对应的叫 <code>ServiceBean</code>，reference 对应的叫 <code>ReferenceBean</code>，其他的都叫 xxxConfig，为什么与众不同，因为有超能力，分别用于暴露服务和引用服务。</p></li></ol><h2 id="5-2-ServiceBean-版"><a href="#5-2-ServiceBean-版" class="headerlink" title="5.2. ServiceBean 版"></a>5.2. ServiceBean 版</h2><p><a href="https://blog.51cto.com/u_15281317/2942413">https://blog.51cto.com/u_15281317/2942413</a></p><h2 id="5-3-Dubbo-启动原理-2-7-7-注解版"><a href="#5-3-Dubbo-启动原理-2-7-7-注解版" class="headerlink" title="5.3. Dubbo 启动原理 -2.7.7- 注解版"></a>5.3. Dubbo 启动原理 -2.7.7- 注解版</h2><p><a href="https://juejin.cn/post/7024797126336970766#heading-6">https://juejin.cn/post/7024797126336970766#heading-6</a><br><a href="https://blog.csdn.net/yang1060887552/article/details/122836658?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-122836658-blog-107958704.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-122836658-blog-107958704.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&utm_relevant_index=10">Dubbo源码阅读四：在Spring下DubboBootstrap的启动过程</a></p><p><a href="https://juejin.cn/post/6945839380799946766">https://juejin.cn/post/6945839380799946766</a></p><h3 id="5-3-1-流程图"><a href="#5-3-1-流程图" class="headerlink" title="5.3.1. 流程图"></a>5.3.1. 流程图</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230330223915.png" alt="image.png"></p><h3 id="5-3-2-属性配置解析器-EnableDubboConfig"><a href="#5-3-2-属性配置解析器-EnableDubboConfig" class="headerlink" title="5.3.2. 属性配置解析器 -@EnableDubboConfig"></a>5.3.2. 属性配置解析器 -@EnableDubboConfig</h3><p>当你使用 <code>@EnableDubbo</code> 注解启动 Dubbo 的时候，会加载它的 <code>@EnableDubboConfig</code> 和 <code>@DubboComponentScan</code> 注解，分别用于处理 Dubbo 属性配置和解析 Dubbo 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">// 处理配置文件中（例如yaml文件）的dubbo配置</span><br><span class="hljs-meta">@EnableDubboConfig</span><br><span class="hljs-comment">// 扫描并解析使用了dubbo注解的组件（例如@Service）</span><br><span class="hljs-meta">@DubboComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableDubbo &#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@EnableDubboConfig</code> 和 <code>@DubboComponentScan</code> 注解使用了 Spring 的 <code>@Import</code> 注解来加载具体的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(DubboConfigConfigurationRegistrar.class)</span><br><span class="hljs-meta">@Import(DubboComponentScanRegistrar.class)</span><br></code></pre></td></tr></table></figure><h4 id="5-3-2-1-DubboConfigConfigurationRegistrar"><a href="#5-3-2-1-DubboConfigConfigurationRegistrar" class="headerlink" title="5.3.2.1. DubboConfigConfigurationRegistrar"></a>5.3.2.1. DubboConfigConfigurationRegistrar</h4><p><code>DubboConfigConfigurationRegistrar</code> 用于将不同的属性加载到不同的配置文件中<br><code>registerBeans</code> 方法最终通过 <code>ConfigurationBeanBindingsRegister</code> 将解析之后的配置类注册到 <code>BeanDefinitionMap</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401070059.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401070142.png" alt="image.png"><br>最终在 Spring 容器中他们会被初始化成若干对象，例如：<code>dubbo:registry</code> 会转换成 <code>org.apache.dubbo.config.RegistryConfig#0</code></p><h3 id="5-3-3-注解解析器-DubboComponentScan"><a href="#5-3-3-注解解析器-DubboComponentScan" class="headerlink" title="5.3.3. 注解解析器 -@DubboComponentScan"></a>5.3.3. 注解解析器 -@DubboComponentScan</h3><h4 id="5-3-3-1-DubboComponentScanRegistrar"><a href="#5-3-3-1-DubboComponentScanRegistrar" class="headerlink" title="5.3.3.1. DubboComponentScanRegistrar"></a>5.3.3.1. DubboComponentScanRegistrar</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230331083325.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230331083400.png" alt="image.png"></p><p><code>DubboComponentScanRegistrar</code> 主要是用来将 <code>ServiceAnnotationBeanPostProcessor</code> （2.7 以上为 <code>ServiceClassPostProcessor</code>）注册到 <code>BeanDefinitionMap</code> 中。<br>在 Spring 调用 BeanFactory 相关的后置处理器（<code>invokeBeanFactoryPostProcessors</code>）时，会使用 <code>ServiceAnnotationBeanPostProcessor</code> 将 <code>@DubboService</code> 相关注解注册到 <code>BeanDefinitionMap</code></p><p>  <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401070742.png" alt="image.png"><br><span style="background-color:#ff00ff">在 <code>ServiceClassPostProcessor</code> 中，它注册了一个 dubbo 监听器，用于监听 Spring 容器的刷新、关闭事件，同时也将 <code>@DubboService</code> 注解的类注册到了 <code>BeanDefinitionMap</code> 中</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401070910.png" alt="image.png"></p><h3 id="5-3-4-启动"><a href="#5-3-4-启动" class="headerlink" title="5.3.4. 启动"></a>5.3.4. 启动</h3><p><a href="https://juejin.cn/post/7024797126336970766#heading-7">https://juejin.cn/post/7024797126336970766#heading-7</a></p><h4 id="5-3-4-1-ServiceClassPostProcessor"><a href="#5-3-4-1-ServiceClassPostProcessor" class="headerlink" title="5.3.4.1. ServiceClassPostProcessor"></a>5.3.4.1. ServiceClassPostProcessor</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401071355.png" alt="image.png"></p><h5 id="5-3-4-1-1-DubboBootstrapApplicationListener"><a href="#5-3-4-1-1-DubboBootstrapApplicationListener" class="headerlink" title="5.3.4.1.1. DubboBootstrapApplicationListener"></a>5.3.4.1.1. DubboBootstrapApplicationListener</h5><p>伴随着 Spring 容器的启动，在 invokeBeanFactoryPostProcessors 阶段我们注册了 dubbo 相关的组件到 IOC，在 finishBeanFactoryInitialization(beanFactory) Dubbo 的组件被初始化、实例化，最后 Dubbo 通过监听 Spring 事件的方式完成启动器的调用、服务导出等操作<br><code>DubboBootstrap</code> 的启动是通过监听 Spring 事件实现的。Spring 会在容器 Refresh 的最后一步发送一个事件 <code>ContextRefreshedEvent</code>，表示容器刷新完毕。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401071549.png" alt="image.png"></p><p>对于 <code>ContextRefreshedEvent</code> 事件的监听，最终调用了 dubboBootstrap.start() 方法，在这个方法里，Dubbo 完成了对服务的导出（暴露），导出服务的过程中，<span style="background-color:#ff00ff">用到了 DUBBO SPI 机制</span></p><h5 id="5-3-4-1-2-ServiceConfig"><a href="#5-3-4-1-2-ServiceConfig" class="headerlink" title="5.3.4.1.2. ServiceConfig"></a>5.3.4.1.2. ServiceConfig</h5><h5 id="5-3-4-1-3-ServiceNameMappingListener"><a href="#5-3-4-1-3-ServiceNameMappingListener" class="headerlink" title="5.3.4.1.3. ServiceNameMappingListener"></a>5.3.4.1.3. ServiceNameMappingListener</h5><p>ServiceNameMapping 及其子类承接了对注册中心的调用，以 nacos 为例调用逻辑如下图<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230401142610.png" alt="image.png"></p><h2 id="5-4-服务暴露与引用原理-2-7-7-注解版"><a href="#5-4-服务暴露与引用原理-2-7-7-注解版" class="headerlink" title="5.4. 服务暴露与引用原理 -2.7.7- 注解版"></a>5.4. 服务暴露与引用原理 -2.7.7- 注解版</h2><p><a href="https://juejin.cn/post/6874731589243240461">https://juejin.cn/post/6874731589243240461</a></p><h2 id="5-5-服务暴露原理-xml-版⭐️🔴"><a href="#5-5-服务暴露原理-xml-版⭐️🔴" class="headerlink" title="5.5. 服务暴露原理 -xml 版⭐️🔴"></a>5.5. 服务暴露原理 -xml 版⭐️🔴</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230328-0629%%</span>❕ ^gl53ku</p><h3 id="5-5-1-封装-serviceBean"><a href="#5-5-1-封装-serviceBean" class="headerlink" title="5.5.1. 封装 serviceBean"></a>5.5.1. 封装 serviceBean</h3><p>IOC 容器启动时，BeanDefinitionParser 的实现类 DubboBeanDefinitionParser，会解析 dubbo 的标签，而在解析 service 标签时，会将 service 的 Beandefinition 封装成 serviceBean</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327081610.jpg" alt="image-20200413162808979"></p><h3 id="5-5-2-实现了-【InitializingBean】"><a href="#5-5-2-实现了-【InitializingBean】" class="headerlink" title="5.5.2. 实现了 【InitializingBean】"></a>5.5.2. 实现了 【InitializingBean】</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924073843703.png" alt="image-20210924073843703"></p><h4 id="5-5-2-1-afterpropertiesSet-保存信息到-serviceBean"><a href="#5-5-2-1-afterpropertiesSet-保存信息到-serviceBean" class="headerlink" title="5.5.2.1. afterpropertiesSet- 保存信息到 serviceBean"></a>5.5.2.1. afterpropertiesSet- 保存信息到 serviceBean</h4><p>在组件实例化完成，属性设置完之后，调用 <code>afterpropertiesSet() </code> 方法，把配置中的 provider、application、module、registries、monitor、protocols 等的信息保存起来，保存到当前的 serviceBean 里面，最后组装成 URL</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924080634932.png" alt="image-20210924080634932"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924080658454.png" alt="image-20210924080658454"></p><h3 id="5-5-3-实现了【-ApplicationListener】"><a href="#5-5-3-实现了【-ApplicationListener】" class="headerlink" title="5.5.3. 实现了【 ApplicationListener】"></a>5.5.3. 实现了【 ApplicationListener】</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924074228912.png" alt="image-20210924074228912"></p><p><span style="background-color:#ff0000">📢 : 2.7 版本注解版变动挺大，没有实现 ApplicationListener</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230330165227.png" alt="image.png"></p><h4 id="5-5-3-1-onApplicationEvent-加载注册中心的信息"><a href="#5-5-3-1-onApplicationEvent-加载注册中心的信息" class="headerlink" title="5.5.3.1. onApplicationEvent- 加载注册中心的信息"></a>5.5.3.1. onApplicationEvent- 加载注册中心的信息</h4><p>IOC 容器刷新完成，所有对象都创建完成之后，回调 onApplicationEvent()，执行 export、doExport、doExportUrls 等方法，其中会根据不同的协议暴露不同的服务</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924080346850.png" alt="image-20210924080346850"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924080923918.png" alt="image-20210924080923918"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924080952304.png" alt="image-20210924080952304"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924081059881.png" alt="image-20210924081059881"></p><h4 id="5-5-3-2-将目标服务实现类、接口、URL-等信息封装成-invoker-执行器"><a href="#5-5-3-2-将目标服务实现类、接口、URL-等信息封装成-invoker-执行器" class="headerlink" title="5.5.3.2. 将目标服务实现类、接口、URL 等信息封装成 invoker 执行器"></a>5.5.3.2. 将目标服务实现类、接口、URL 等信息封装成 invoker 执行器</h4><p><span style="background-color:#ff00ff">使用 proxyFactory 将目标服务实现类、接口、URL 等信息封装成 invoker 执行器</span><br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924081252224.png" alt="image-20210924081252224"></p><h4 id="5-5-3-3-protocol-export-warpperInvoker-暴露-invoker"><a href="#5-5-3-3-protocol-export-warpperInvoker-暴露-invoker" class="headerlink" title="5.5.3.3. protocol.export(warpperInvoker)- 暴露 invoker"></a>5.5.3.3. protocol.export(warpperInvoker)- 暴露 invoker</h4><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924081305979.png" alt="image-20210924081305979"></p><p>基于 Java 的 SPI 机制，会得到 2 个 protocol</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924101256388.png" alt="image-20210924101256388"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924092702515.png" alt="image-20210924092702515"></p><p><a href="https://www.bilibili.com/video/BV1AP4y1Y7YX?p=28">https://www.bilibili.com/video/BV1AP4y1Y7YX?p=28</a></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002202328113.png" alt="image-20211002202328113"></p><h5 id="5-5-3-3-1-RegistryProtocol-export-暴露-Regisry"><a href="#5-5-3-3-1-RegistryProtocol-export-暴露-Regisry" class="headerlink" title="5.5.3.3.1. RegistryProtocol.export- 暴露 Regisry"></a>5.5.3.3.1. RegistryProtocol.export- 暴露 Regisry</h5><p>export 中有 2 个关键方法：</p><h6 id="5-5-3-3-1-1-doLocalExport"><a href="#5-5-3-3-1-1-doLocalExport" class="headerlink" title="5.5.3.3.1.1. doLocalExport"></a>5.5.3.3.1.1. doLocalExport</h6><p><span style="background-color:#ff00ff">invokeDelegete 暴露会进入 DubboProtocol.class 中的 export 方法</span><br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002203437343.png" alt="image-20211002203437343"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924093034314.png" alt="image-20210924093034314"></p><p><span style="background-color:#ff00ff">invokeDelegete 暴露会进入 DubboProtocol.class 中的 export 方法</span><br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002203919831.png" alt="image-20211002203919831"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002203950166.png" alt="image-20211002203950166"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002204038478.png" alt="image-20211002204038478"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924093208709.png" alt="image-20210924093208709"></p><p><span style="background-color:#ff00ff">接下面的 DubboProtocol.export</span></p><h6 id="5-5-3-3-1-2-DubboProtocol-export-暴露-Dubbo-启动-netty-服务器"><a href="#5-5-3-3-1-2-DubboProtocol-export-暴露-Dubbo-启动-netty-服务器" class="headerlink" title="5.5.3.3.1.2. DubboProtocol.export- 暴露 Dubbo- 启动 netty 服务器"></a>5.5.3.3.1.2. DubboProtocol.export- 暴露 Dubbo- 启动 netty 服务器</h6><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924093438794.png" alt="image-20210924093438794"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002204347042.png" alt="image-20211002204347042"></p><p><span style="background-color:#ff00ff">在 createServer 中启动 netty 服务器，监听 20882 端口</span></p><h4 id="5-5-3-4-ProviderConsumerRegTable-registerProvider-注册服务"><a href="#5-5-3-4-ProviderConsumerRegTable-registerProvider-注册服务" class="headerlink" title="5.5.3.4. ProviderConsumerRegTable.registerProvider- 注册服务"></a>5.5.3.4. ProviderConsumerRegTable.registerProvider- 注册服务</h4><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924093845033.png" alt="image-20210924093845033"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924081709274.png" alt="image-20210924081709274"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211002204723685.png" alt="image-20211002204723685"></p><h2 id="5-6-服务引用原理-xml-版⭐️🔴"><a href="#5-6-服务引用原理-xml-版⭐️🔴" class="headerlink" title="5.6. 服务引用原理 -xml 版⭐️🔴"></a>5.6. 服务引用原理 -xml 版⭐️🔴</h2><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230328-0653%%</span>❕ ^3aliel</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924084531649.png" alt="image-20210924084531649"></p><h3 id="5-6-1-实现了-【FactoryBean】"><a href="#5-6-1-实现了-【FactoryBean】" class="headerlink" title="5.6.1. 实现了 【FactoryBean】"></a>5.6.1. 实现了 【FactoryBean】</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924100429599.png" alt="image-20210924100429599"></p><ol><li>解析 reference 注解时，发现引用 UserService，就需要在容器中找，因为 ReferenceBean 实现了 FactoryBean，所以调用 getObject 方法</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924100827788.png" alt="image-20210924100827788"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924100802949.png" alt="image-20210924100802949"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003070252288.png" alt="image-20211003070252288"></p><ol start="2"><li>在 get() 方法中调用了创建代理的 <code>createProxy()</code> 方法，在这个方法里有用到了通过 SPI 方式加载的 Protocol 类<br>map 中存放的是 reference 标签中的属性，用来创建代理类，然后调用 refer，doRefer，subscribe 等关键方法</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003070217503.png" alt="image-20211003070217503"></p><ol start="3"><li>与暴露方法同样的，引用方法也有 2 个实现，分别是 DubboProtocol 和 RegistryProtocol 中的 refer() 方法</li></ol><p><code>urls</code> 是注册中心的地址<br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003070628762.png" alt="image-20211003070628762"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924101141683.png" alt="image-20210924101141683"></p><h3 id="5-6-2-RegistryProtocol-refer"><a href="#5-6-2-RegistryProtocol-refer" class="headerlink" title="5.6.2. RegistryProtocol.refer"></a>5.6.2. RegistryProtocol.refer</h3><ol start="4"><li>先调用 RegistryProtocol 中的 refer() 方法，在该方法里到注册中心订阅服务，获取服务信息。</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924110432057.png" alt="image-20210924110432057"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924110754573.png" alt="image-20210924110754573"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924110832104.png" alt="image-20210924110832104"></p><p><span style="background-color:#ff00ff">subscribe 方法会调用 dubboProtocol.refer</span></p><h3 id="5-6-3-DubboProtocol-refer"><a href="#5-6-3-DubboProtocol-refer" class="headerlink" title="5.6.3. DubboProtocol.refer"></a>5.6.3. DubboProtocol.refer</h3><ol start="5"><li>在订阅服务的方法中调用了 DubboProtocol 的 refer() 方法，方法中 getClients() 方法中创建客户端。<br><span style="background-color:#ff00ff">getClients()</span> → <span style="background-color:#ff00ff">initClient()</span></li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924084254521.png" alt="image-20210924084254521"></p><p><span style="background-color:#ff00ff">Exchanges.connect(url,xxx)</span></p><ol start="6"><li><span style="background-color:#ff00ff">创建 netty 的客户端，然后将带有连接属性的 invoker 返回</span></li><li><span style="background-color:#ff00ff">最后，将 invoker 注册到 ProviderConsumerRegTable 中，注册地址为订阅地址</span></li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924111102833.png" alt="image-20210924111102833"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924111128709.png" alt="image-20210924111128709"></p><h2 id="5-7-服务调用原理-xml-版"><a href="#5-7-服务调用原理-xml-版" class="headerlink" title="5.7. 服务调用原理 -xml 版"></a>5.7. 服务调用原理 -xml 版</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924085205572.png" alt="image-20210924085205572"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924111722548.png" alt="image-20210924111722548"></p><h3 id="5-7-1-进入-InvokerInvocationHandler"><a href="#5-7-1-进入-InvokerInvocationHandler" class="headerlink" title="5.7.1. 进入 InvokerInvocationHandler"></a>5.7.1. 进入 InvokerInvocationHandler</h3><ol><li>代理对象层层封装了 Invoker 对象，里面是一些真正要执行的方法<br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924111756013.png" alt="image-20210924111756013"></li></ol><h3 id="5-7-2-执行-new-RpcInvocation-方法"><a href="#5-7-2-执行-new-RpcInvocation-方法" class="headerlink" title="5.7.2. 执行 new RpcInvocation 方法"></a>5.7.2. 执行 new RpcInvocation 方法</h3><ol start="2"><li>可以在刚开始给代理对象加一些 filter，比如 cache、mock(比如服务降级) 功能</li><li>其中 InvokerInvocationHanlder 中的 invoke() 方法先到 MockClusterInvoker 类中，这个类可以封装多个 Invoker 对象，比如 failover、failback 功能的 Invoker<br>首先会进入 MockClusterInvoker 中，获取失败容错信息</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003072302993.png" alt="image-20211003072302993"></p><h3 id="5-7-3-获取负载均衡机制"><a href="#5-7-3-获取负载均衡机制" class="headerlink" title="5.7.3. 获取负载均衡机制"></a>5.7.3. 获取负载均衡机制</h3><ol start="4"><li>多个 Invoker 可以经过通过 SPI 获取到的负载均衡机制进行负载均衡<br>在注册中心找想要执行的方法列表，如果是多个则获取负载均衡机制，然后执行 doInvoker</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003071436483.png" alt="image-20211003071436483"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924111843322.png" alt="image-20210924111843322"></p><ol start="5"><li>最终底层真正执行方法的 Invoker 是 DubboInvoker，通过 client 调用底层 Netty 客户端进行交互<br>doInvoke 方法进入 FailoverClusterInvoker 中，随机选择一个 Invoker，然后执行 invoker.invoke</li></ol><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003072550600.png" alt="image-20211003072550600"></p><h3 id="5-7-4-经过多个-filter"><a href="#5-7-4-经过多个-filter" class="headerlink" title="5.7.4. 经过多个 filter"></a>5.7.4. 经过多个 filter</h3><p>invoker 是封装的 filter，会经过多个 filter</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003084214043.png" alt="image-20211003084214043"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003082843646.png" alt="image-20211003082843646"></p><h3 id="5-7-5-DubboInvoker-方法中的-doInvoke-方法"><a href="#5-7-5-DubboInvoker-方法中的-doInvoke-方法" class="headerlink" title="5.7.5. DubboInvoker 方法中的 doInvoke 方法"></a>5.7.5. DubboInvoker 方法中的 doInvoke 方法</h3><p>经过多个 filter 之后，是 DubboInvoker 方法中的 doInvoke 方法，真正执行功能的方法</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210924112129947.png" alt="image-20210924112129947"></p><h3 id="5-7-6-currentClient-request"><a href="#5-7-6-currentClient-request" class="headerlink" title="5.7.6. currentClient.request"></a>5.7.6. currentClient.request</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003084855353.png" alt="image-20211003084855353"></p><h1 id="6-分层设计"><a href="#6-分层设计" class="headerlink" title="6. 分层设计"></a>6. 分层设计</h1><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003102405068.png" alt="image-20211003102405068"><br><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211003102603060.png" alt="image-20211003102603060"></p><h1 id="7-协议"><a href="#7-协议" class="headerlink" title="7. 协议"></a>7. 协议</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214815.jpg" alt="image-20200422012747019"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214810.jpg" alt="image-20200422012807396"></p><h1 id="8-与-SpringBoot-整合"><a href="#8-与-SpringBoot-整合" class="headerlink" title="8. 与 SpringBoot 整合"></a>8. 与 SpringBoot 整合</h1><p>SpringBoot 与 dubbo 整合的三种方式：</p><p>1）、导入 dubbo-starter，在 application.properties 配置属性，使用@Service【暴露服务】使用@Reference【引用服务】</p><p>2）、保留 dubbo xml 配置文件; 导入 dubbo-starter，使用@ImportResource 导入 dubbo 的配置文件即可</p><p>3）、使用注解 API 的方式：将每一个组件手动创建到容器中,让 dubbo 来扫描其他的组件</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214642.jpg" alt="image-20200422000348930"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230327214636.jpg" alt="image-20200422000305379"></p><h1 id="9-Dubbo-SPI-与-JDK-SPI-区别"><a href="#9-Dubbo-SPI-与-JDK-SPI-区别" class="headerlink" title="9. Dubbo SPI 与 JDK SPI 区别"></a>9. Dubbo SPI 与 JDK SPI 区别</h1><p><a href="https://juejin.cn/post/6872138926216511501">https://juejin.cn/post/6872138926216511501</a></p><h1 id="10-面试题"><a href="#10-面试题" class="headerlink" title="10. 面试题"></a>10. 面试题</h1><h2 id="10-1-与-SpringCloud-的区别"><a href="#10-1-与-SpringCloud-的区别" class="headerlink" title="10.1. 与 SpringCloud 的区别"></a>10.1. 与 SpringCloud 的区别</h2><a href="/2023/05/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-16%E3%80%81SpringCloud/" title="分布式专题-16、SpringCloud">分布式专题-16、SpringCloud</a><h2 id="10-2-动态感知服务下线"><a href="#10-2-动态感知服务下线" class="headerlink" title="10.2. 动态感知服务下线"></a>10.2. 动态感知服务下线</h2><p><a href="https://www.bilibili.com/video/BV1Z44y1372E/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Z44y1372E/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="10-3-容错机制"><a href="#10-3-容错机制" class="headerlink" title="10.3. 容错机制"></a>10.3. 容错机制</h2><p><a href="https://www.bilibili.com/video/BV1hP4y1u77c/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1hP4y1u77c/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="10-4-对-Dubbo-的理解"><a href="#10-4-对-Dubbo-的理解" class="headerlink" title="10.4. 对 Dubbo 的理解"></a>10.4. 对 Dubbo 的理解</h2><p><a href="https://www.bilibili.com/video/BV1FU4y1K7C7/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1FU4y1K7C7/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="10-5-文字面试题"><a href="#10-5-文字面试题" class="headerlink" title="10.5. 文字面试题"></a>10.5. 文字面试题</h2><p>[[Dubbo面试题 47道.pdf]]</p><h1 id="11-参考与感谢"><a href="#11-参考与感谢" class="headerlink" title="11. 参考与感谢"></a>11. 参考与感谢</h1><h2 id="11-1-Dubbo-教程-雷丰阳-尚硅谷"><a href="#11-1-Dubbo-教程-雷丰阳-尚硅谷" class="headerlink" title="11.1. Dubbo 教程 _ 雷丰阳 _ 尚硅谷"></a>11.1. Dubbo 教程 _ 雷丰阳 _ 尚硅谷</h2><h3 id="11-1-1-视频"><a href="#11-1-1-视频" class="headerlink" title="11.1.1. 视频"></a>11.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1Gb411T7Ha?p=12">https://www.bilibili.com/video/BV1Gb411T7Ha?p=12</a></p><h3 id="11-1-2-资料"><a href="#11-1-2-资料" class="headerlink" title="11.1.2. 资料"></a>11.1.2. 资料</h3><p>注解版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Volumes/Seagate Bas/<span class="hljs-number">001</span>-study/语言工具/Dubbo/课件、资料/课件<br></code></pre></td></tr></table></figure><h2 id="11-2-黑马程序员"><a href="#11-2-黑马程序员" class="headerlink" title="11.2. 黑马程序员"></a>11.2. 黑马程序员</h2><h3 id="11-2-1-视频"><a href="#11-2-1-视频" class="headerlink" title="11.2.1. 视频"></a>11.2.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1VE411q7dX?p=8&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1VE411q7dX?p=8&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="11-2-2-资料"><a href="#11-2-2-资料" class="headerlink" title="11.2.2. 资料"></a>11.2.2. 资料</h3><p>非注解版：Spring、SpringMVC 整合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/Enterprise/<span class="hljs-number">0003</span>-Architecture/<span class="hljs-number">005</span>-分布式专题/<span class="hljs-number">2</span>、分布式开发框架Dubbo/资料--分布式开发框架Dubbo<br></code></pre></td></tr></table></figure><h2 id="11-3-微服务-dubbo-和-springcloud-如何抉择？"><a href="#11-3-微服务-dubbo-和-springcloud-如何抉择？" class="headerlink" title="11.3. 微服务 dubbo 和 springcloud 如何抉择？"></a>11.3. 微服务 dubbo 和 springcloud 如何抉择？</h2><p><a href="https://www.bilibili.com/video/BV1rJ411t7MF?p=5">https://www.bilibili.com/video/BV1rJ411t7MF?p=5</a></p><h2 id="11-4-其他"><a href="#11-4-其他" class="headerlink" title="11.4. 其他"></a>11.4. 其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">013</span>-DemoCode/JavaYouth/docs/dubbo-sourcecode-v1<br></code></pre></td></tr></table></figure><h2 id="11-5-技术文章摘抄"><a href="#11-5-技术文章摘抄" class="headerlink" title="11.5. 技术文章摘抄"></a>11.5. 技术文章摘抄</h2><h3 id="11-5-1-视频"><a href="#11-5-1-视频" class="headerlink" title="11.5.1. 视频"></a>11.5.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1Bc411V7AR?p=19&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Bc411V7AR?p=19&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="11-5-2-文档"><a href="#11-5-2-文档" class="headerlink" title="11.5.2. 文档"></a>11.5.2. 文档</h3><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/24%20%20%E4%BB%8E%20Protocol%20%E8%B5%B7%E6%89%8B%EF%BC%8C%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89.md">看服务暴露和服务引用的全流程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Volumes/Seagate Bas/<span class="hljs-number">001</span>-ArchitectureRoad/<span class="hljs-number">000</span>-极客时间/<span class="hljs-number">31</span>-从<span class="hljs-number">0</span>开始学微服务/<span class="hljs-number">03</span>-模块二 落地微服务 (<span class="hljs-number">14</span>讲)/<span class="hljs-number">14</span>丨开源RPC框架如何选型？.pdf<br></code></pre></td></tr></table></figure><h2 id="11-6-网络笔记"><a href="#11-6-网络笔记" class="headerlink" title="11.6. 网络笔记"></a>11.6. 网络笔记</h2><p>[[Dubbo基础及原理机制 - 胡小华 - 博客园]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Dubbo&quot;&gt;&lt;a href=&quot;#1-Dubbo&quot; class=&quot;headerlink&quot; title=&quot;1. Dubbo&quot;&gt;&lt;/a&gt;1. Dubbo&lt;/h1&gt;&lt;h2 id=&quot;1-1-是什么&quot;&gt;&lt;a href=&quot;#1-1-是什么&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>服务治理-10、限流熔断降级(服务保护)-Sentinel</title>
    <link href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/"/>
    <id>https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.712Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-雪崩问题"><a href="#1-雪崩问题" class="headerlink" title="1. 雪崩问题"></a>1. 雪崩问题</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1. 是什么"></a>1.1. 是什么</h2><p><span style="background-color:#ff00ff">微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</span></p><h2 id="1-2-产生原因"><a href="#1-2-产生原因" class="headerlink" title="1.2. 产生原因"></a>1.2. 产生原因</h2><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p><p>如果服务提供者 I 发生了故障，当前的应用的部分业务因为依赖于服务 I，因此也会被阻塞。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315101121.png" alt="png"></p><p>但是，依赖服务 I 的业务请求被阻塞，用户不会得到响应，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315101235.png" alt="png"></p><p><span style="background-color:#ff00ff">服务器支持的线程和并发数有限</span>，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。</p><h2 id="1-3-雪崩问题解决方案"><a href="#1-3-雪崩问题解决方案" class="headerlink" title="1.3. 雪崩问题解决方案"></a>1.3. 雪崩问题解决方案</h2><p><span style="display:none">%%<br>▶11.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-1023%%</span>❕ ^wihp2i</p><p>解决雪崩问题的常见方式有四种：<br><strong>超时处理</strong>：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待<br>**舱壁模式 (线程隔离)**：限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离<br><strong>熔断降级</strong>：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求<br><strong>流量控制</strong>：限制业务访问的 QPS，避免服务因流量的突增而故障</p><h3 id="1-3-1-超时处理"><a href="#1-3-1-超时处理" class="headerlink" title="1.3.1. 超时处理"></a>1.3.1. 超时处理</h3><p>设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315102401.png" alt="image-20210715172820438"></p><h3 id="1-3-2-舱壁模式-线程隔离"><a href="#1-3-2-舱壁模式-线程隔离" class="headerlink" title="1.3.2. 舱壁模式 (线程隔离)"></a>1.3.2. 舱壁模式 (线程隔离)</h3><p>限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此<span style="background-color:#ff00ff">也叫线程隔离。</span> <span style="display:none">%%<br>▶10.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-1018%%</span>❕ ^pshp1j</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315101900.png" alt="image-20210715173215243"></p><h3 id="1-3-3-熔断降级"><a href="#1-3-3-熔断降级" class="headerlink" title="1.3.3. 熔断降级"></a>1.3.3. 熔断降级</h3><p>由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315102516.png" alt="image.png"></p><h3 id="1-3-4-流量控制"><a href="#1-3-4-流量控制" class="headerlink" title="1.3.4. 流量控制"></a>1.3.4. 流量控制</h3><p>限制业务访问的 QPS，避免服务因流量的突增而故障<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315102655.png" alt="image.png"></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315103017.png" alt="image.png"></p><h1 id="2-微服务保护技术"><a href="#2-微服务保护技术" class="headerlink" title="2. 微服务保护技术"></a>2. 微服务保护技术</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301160639.png" alt="image ^sncpe2.png"></p><h1 id="3-限流"><a href="#3-限流" class="headerlink" title="3. 限流"></a>3. 限流</h1><h2 id="3-1-流控模式"><a href="#3-1-流控模式" class="headerlink" title="3.1. 流控模式"></a>3.1. 流控模式</h2><p>在添加限流规则时，点击高级选项，可以选择三种 <strong>流控模式</strong>：</p><ul><li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是<span style="background-color:#ff00ff">默认的模式</span></li><li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li><li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li></ul><h3 id="3-1-1-关联"><a href="#3-1-1-关联" class="headerlink" title="3.1.1. 关联"></a>3.1.1. 关联</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313080407.png" alt="image-20210715201827886"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313081158.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313081332.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313081419.png" alt="image.png"></p><h3 id="3-1-2-链路"><a href="#3-1-2-链路" class="headerlink" title="3.1.2. 链路"></a>3.1.2. 链路</h3><p>对请求来源的限流控制</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313081532.png" alt="image.png"></p><p><span style="display:none">%%<br>▶11.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230313-1428%%</span>❕ ^3uq11z</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313081639.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313083444.png" alt="image.png"></p><h2 id="3-2-流控效果"><a href="#3-2-流控效果" class="headerlink" title="3.2. 流控效果"></a>3.2. 流控效果</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313084046.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315082752.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313083851.png" alt="image.png"></p><h2 id="3-3-热点参数限流"><a href="#3-3-热点参数限流" class="headerlink" title="3.3. 热点参数限流"></a>3.3. 热点参数限流</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313084320.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313084454.png" alt="image.png"></p><p>需要使用注解 <code>@SentinelResource</code>，给热点参数限流方法再加一个资源 id 名称，比如下面的 “hot” <span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-0749%%</span>❕ ^wj1oql</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313084531.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313084625.png" alt="image.png"></p><h2 id="3-4-流量整形"><a href="#3-4-流量整形" class="headerlink" title="3.4. 流量整形"></a>3.4. 流量整形</h2><p>排队等待的流控效果，可以起到流量整形的效果</p><h1 id="4-隔离和降级"><a href="#4-隔离和降级" class="headerlink" title="4. 隔离和降级"></a>4. 隔离和降级</h1><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=145&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=145&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="4-1-线程隔离-舱壁模式"><a href="#4-1-线程隔离-舱壁模式" class="headerlink" title="4.1. 线程隔离 (舱壁模式)"></a>4.1. 线程隔离 (舱壁模式)</h2><p><span style="background-color:#ff00ff">Sentinel 默认采用信号量隔离</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313092837.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093103.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093309.png" alt="image.png"></p><h2 id="4-2-熔断降级"><a href="#4-2-熔断降级" class="headerlink" title="4.2. 熔断降级"></a>4.2. 熔断降级</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313085436.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093408.png" alt="image.png"></p><h3 id="4-2-1-断路器"><a href="#4-2-1-断路器" class="headerlink" title="4.2.1. 断路器"></a>4.2.1. 断路器</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093528.png" alt="image.png"></p><h3 id="4-2-2-熔断策略"><a href="#4-2-2-熔断策略" class="headerlink" title="4.2.2. 熔断策略"></a>4.2.2. 熔断策略</h3><h4 id="4-2-2-1-慢调用"><a href="#4-2-2-1-慢调用" class="headerlink" title="4.2.2.1. 慢调用"></a>4.2.2.1. 慢调用</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093708.png" alt="image.png"></p><h4 id="4-2-2-2-异常比例、异常数"><a href="#4-2-2-2-异常比例、异常数" class="headerlink" title="4.2.2.2. 异常比例、异常数"></a>4.2.2.2. 异常比例、异常数</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313093950.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313094217.png" alt="image.png"></p><h3 id="4-2-3-Feign-整合-Sentinel"><a href="#4-2-3-Feign-整合-Sentinel" class="headerlink" title="4.2.3. Feign 整合 Sentinel"></a>4.2.3. Feign 整合 Sentinel</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313085645.png" alt="image.png"></p><p><span style="background-color:#ff00ff">Feign 开启 Sentinel 功能后，Sentinel 就会把 Feign 的调用视作一种资源，从而能够进行熔断降级操作。</span> <span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-0903%%</span>❕ ^gdjmu1</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315090437.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315090451.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313090008.png" alt="image.png"></p><h2 id="4-3-授权规则"><a href="#4-3-授权规则" class="headerlink" title="4.3. 授权规则"></a>4.3. 授权规则</h2><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=146&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=146&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1. 作用"></a>4.3.1. 作用</h3><p><span style="background-color:#ff00ff">对请求者身份来源的校验，防止绕过网关直接调用微服务资源。只允许网关过来的请求</span> <span style="display:none">%%<br>▶14.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-1131%%</span>❕ ^krg0d5</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230315113258.png" alt="image.png"></p><p><span style="background-color:#ff00ff">流控应用后面输入框中调用方名称填写请求来源，比如我们在请求头中增加一个表示 gateway 来源的请求头，例子中我们直接简单的使用字符串 “gateway”</span></p><h3 id="4-3-2-使用方法"><a href="#4-3-2-使用方法" class="headerlink" title="4.3.2. 使用方法"></a>4.3.2. 使用方法</h3><h4 id="4-3-2-1-在-GateWay-中加请求头"><a href="#4-3-2-1-在-GateWay-中加请求头" class="headerlink" title="4.3.2.1. 在 GateWay 中加请求头"></a>4.3.2.1. 在 GateWay 中加请求头</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313094814.png" alt="image.png"><br><span style="background-color:#ff00ff">加上此配置之后，凡是从网关路由到微服务的请求中都带有名称为 origin，值为 “gateway” 的请求头</span>，而从浏览器中直接发送的请求 (企图绕过网关) 中没有约定的请求头，就会被拦截过滤掉。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322085839.png" alt="image.png"></p><h4 id="4-3-2-2-Sentinel-解析请求头"><a href="#4-3-2-2-Sentinel-解析请求头" class="headerlink" title="4.3.2.2. Sentinel 解析请求头"></a>4.3.2.2. Sentinel 解析请求头</h4><p>Sentinel 是通过 RequestOriginParser 这个接口的 parseOrigin 来获取请求的来源的。<br>所以，需要编写一个实现类，实现获取请求来源的接口 <code>RequestOriginParser</code> 的 <code>parseOrigin</code> 方法，让 Sentinel 获取到请求来源，从而让其能够做过滤判断。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313094836.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313095019.png" alt="image.png"></p><h4 id="4-3-2-3-优化"><a href="#4-3-2-3-优化" class="headerlink" title="4.3.2.3. 优化"></a>4.3.2.3. 优化</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313095354.png" alt="image.png"></p><p><span style="background-color:#00ff00">这一块可以使用 starter 引入的方式，就不需要在每个微服务中都编写同样的逻辑了</span><br><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-0928%%</span>❕ ^ez1ivw</p><h3 id="4-3-3-自定义异常"><a href="#4-3-3-自定义异常" class="headerlink" title="4.3.3. 自定义异常"></a>4.3.3. 自定义异常</h3><h1 id="5-Sentinel-原理"><a href="#5-Sentinel-原理" class="headerlink" title="5. Sentinel 原理"></a>5. Sentinel 原理</h1><p><span style="display:none">%%<br>▶12.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-1119%%</span>❕ ^htxflw</p><p>[[Sentinel源码分析.md]]</p><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=176&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=176&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>Sentinel 实现限流、隔离、降级、熔断等功能，本质要做的就是两件事情：</p><ul><li><strong>统计数据</strong>：统计某个资源的访问数据（QPS、RT 等信息）</li><li><strong>规则判断</strong>：判断限流规则、隔离规则、降级规则、熔断规则是否满足</li></ul><p>这里的 <strong>资源</strong> 就是希望被 Sentinel 保护的业务，例如项目中定义的 controller 方法就是默认被 Sentinel 保护的资源、@SentinelResource 注解标注的自定义资源。</p><h2 id="5-1-ProcessorSlotChain"><a href="#5-1-ProcessorSlotChain" class="headerlink" title="5.1. ProcessorSlotChain"></a>5.1. ProcessorSlotChain</h2><p><span style="display:none">%%<br>▶9.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230313-1136%%</span>❕ ^fazbix</p><p>实现上述功能的核心骨架是一个叫做 <code>ProcessorSlotChain</code> 的类。这个类基于<span style="background-color:#ff00ff">责任链模式</span>来设计，<span style="background-color:#ff00ff">将不同的功能（限流、降级、系统保护）封装为一个个的 Slot</span>，请求进入后逐个执行即可。<br><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230322-0713%%</span>❕ ^p5myd9</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313113025.png" alt="image-20210925092845529"></p><h3 id="5-1-1-责任链中的-Slot-分为两大类"><a href="#5-1-1-责任链中的-Slot-分为两大类" class="headerlink" title="5.1.1. 责任链中的 Slot 分为两大类"></a>5.1.1. 责任链中的 Slot 分为两大类</h3><h4 id="5-1-1-1-数据构建及统计部分（statistic）"><a href="#5-1-1-1-数据构建及统计部分（statistic）" class="headerlink" title="5.1.1.1. 数据构建及统计部分（statistic）"></a>5.1.1.1. 数据构建及统计部分（statistic）</h4><ol><li>NodeSelectorSlot：负责构建簇点链路中的节点（DefaultNode、EntranceNode，是一种特殊的 DefaultNode），将这些节点形成链路树</li><li>ClusterBuilderSlot：负责构建某个资源的 ClusterNode，ClusterNode 可以保存资源的运行信息（响应时间、QPS、block 数目、线程数、异常数等）以及来源信息（origin 名称）</li><li>StatisticSlot：负责统计实时调用数据，包括运行信息、来源信息等</li></ol><h4 id="5-1-1-2-规则判断部分（rule-checking）"><a href="#5-1-1-2-规则判断部分（rule-checking）" class="headerlink" title="5.1.1.2. 规则判断部分（rule checking）"></a>5.1.1.2. 规则判断部分（rule checking）</h4><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️⭐️】◼️⭐️-point-20230314-0747%%</span>❕ ^u9i9a5</p><ol><li>AuthoritySlot：负责授权规则（来源控制）</li><li>SystemSlot：负责系统保护规则</li><li>ParamFlowSlot：负责热点参数限流规则</li><li>FlowSlot：负责限流规则</li><li>DegradeSlot：负责降级规则</li></ol><h3 id="5-1-2-执行流程"><a href="#5-1-2-执行流程" class="headerlink" title="5.1.2. 执行流程"></a>5.1.2. 执行流程</h3><p><span style="display:none">%%<br>▶15.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-1404%%</span>❕ ^8j0qwe</p><h4 id="5-1-2-1-自动装配-SentinelWebAutoConfiguration"><a href="#5-1-2-1-自动装配-SentinelWebAutoConfiguration" class="headerlink" title="5.1.2.1. 自动装配 -SentinelWebAutoConfiguration"></a>5.1.2.1. 自动装配 -SentinelWebAutoConfiguration</h4><p>其中的 spring.factories 声明需要就是自动装配的配置类，内容如下：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131303.png" alt="image-20210925115740281"></p><p>我们先看 <code>SentinelWebAutoConfiguration</code> 这个类：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313132455.png" alt="image-20210925115824345"></p><h4 id="5-1-2-2-注册拦截器-SentinelWebInterceptor"><a href="#5-1-2-2-注册拦截器-SentinelWebInterceptor" class="headerlink" title="5.1.2.2. 注册拦截器 -SentinelWebInterceptor"></a>5.1.2.2. 注册拦截器 -SentinelWebInterceptor</h4><p>这个类实现了 WebMvcConfigurer，我们知道这个是 SpringMVC 自定义配置用到的类，可以配置 HandlerInterceptor：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313132625.png" alt="image-20210925115946064"></p><p>可以看到这里配置了一个 <code>SentinelWebInterceptor</code> 的拦截器。<br><code>SentinelWebInterceptor</code> 的声明如下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313132704.png" alt="image-20210925120119030"></p><p>发现它继承了 <code>AbstractSentinelInterceptor</code> 这个类。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313132706.png" alt="image-20210925120221883"></p><p><code>HandlerInterceptor</code> 就是我们 SpringMVC 中的拦截器了。 <span style="background-color:#ff00ff">拦截器会拦截一切进入 controller 的方法，执行 <code>preHandle</code> 前置拦截方法</span>，而 Context 的初始化就是在这里完成的。</p><h4 id="5-1-2-3-创建-Context"><a href="#5-1-2-3-创建-Context" class="headerlink" title="5.1.2.3. 创建 Context"></a>5.1.2.3. 创建 Context</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br>    <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取资源名称，一般是controller方法的@RequestMapping路径，例如/order/&#123;orderId&#125;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> getResourceName(request);<br>        <span class="hljs-keyword">if</span> (StringUtil.isEmpty(resourceName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从request中获取请求来源，将来做 授权规则 判断时会用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> parseOrigin(request);<br>        <br>        <span class="hljs-comment">// 获取 contextName，默认是sentinel_spring_web_context</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">contextName</span> <span class="hljs-operator">=</span> getContextName(request);<br>        <span class="hljs-comment">// 创建 Context</span><br>        ContextUtil.enter(contextName, origin);<br>        <span class="hljs-comment">// 创建资源，名称就是当前请求的controller方法的映射路径</span><br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> SphU.entry(resourceName, ResourceTypeConstants.COMMON_WEB, EntryType.IN);<br>        request.setAttribute(baseWebMvcConfig.getRequestAttributeName(), entry);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (BlockException e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            handleBlockException(request, response, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ContextUtil.exit();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313143228.png" alt="image.png"></p><h5 id="5-1-2-3-1-Context-作用"><a href="#5-1-2-3-1-Context-作用" class="headerlink" title="5.1.2.3.1. Context 作用"></a>5.1.2.3.1. Context 作用</h5><p>我们发现簇点链路中除了 controller 方法、service 方法两个资源外，还多了一个默认的入口节点：<br><code>sentinel_spring_web_context</code>，是一个 EntranceNode 类型的节点<br>这个节点是在初始化 Context 的时候由 Sentinel 帮我们创建的。<br>那么，什么是 Context 呢？</p><ul><li>Context 代表调用链路上下文，贯穿一次调用链路中的所有资源（ <code>Entry</code>），基于 ThreadLocal。</li><li>Context 维持着入口节点（<code>entranceNode</code>）、本次调用链路的 curNode（当前资源节点）、调用来源（<code>origin</code>）等信息。</li><li><span style="background-color:#ff00ff">后续的 Slot 都可以通过 Context 拿到 DefaultNode 或者 ClusterNode，从而获取统计数据，完成规则判断</span></li><li>Context 初始化的过程中，会创建 EntranceNode，contextName 就是 EntranceNode 的名称</li></ul><h4 id="5-1-2-4-进入执行入口-SphU-entry"><a href="#5-1-2-4-进入执行入口-SphU-entry" class="headerlink" title="5.1.2.4. 进入执行入口 -SphU.entry"></a>5.1.2.4. 进入执行入口 -SphU.entry</h4><p>首先，回到一切的入口，<code>AbstractSentinelInterceptor</code> 类的 <code>preHandle</code> 方法：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313141107.png" alt="image-20210925142313050"></p><p>还有，<code>SentinelResourceAspect</code> 的环绕增强方法：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313141252.png" alt="image-20210925142438552"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313134102.png" alt="image.png"></p><h4 id="5-1-2-5-创建-ProcessorSlotChain"><a href="#5-1-2-5-创建-ProcessorSlotChain" class="headerlink" title="5.1.2.5. 创建 ProcessorSlotChain"></a>5.1.2.5. 创建 ProcessorSlotChain</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313134315.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313134928.png" alt="image.png"></p><h3 id="5-1-3-关键配置"><a href="#5-1-3-关键配置" class="headerlink" title="5.1.3. 关键配置"></a>5.1.3. 关键配置</h3><h4 id="5-1-3-1-统一入口"><a href="#5-1-3-1-统一入口" class="headerlink" title="5.1.3.1. 统一入口"></a>5.1.3.1. 统一入口</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313142530.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313142623.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313142640.png" alt="image.png"></p><p>默认为 true，统一入口为<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313142719.png" alt="image.png"></p><p><span style="background-color:#ff00ff">但如果做链路限流时，需要禁用统一入口，分成不同的链路，那么就需要设置这个参数为 false</span>。<a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/" title="服务治理-10、限流熔断降级(服务保护)-Sentinel">服务治理-10、限流熔断降级(服务保护)-Sentinel</a></p><h2 id="5-2-Node"><a href="#5-2-Node" class="headerlink" title="5.2. Node"></a>5.2. Node</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313130918.png" alt="image-20210925103029924"></p><p>所有的节点都可以记录对资源的访问统计数据，所以都是 StatisticNode 的子类。</p><p>按照作用分为两类 Node：</p><ul><li>DefaultNode：代表链路树中的每一个资源，一个资源出现在不同链路中时，会创建不同的 DefaultNode 节点。而树的入口节点叫 EntranceNode，是一种特殊的 DefaultNode</li><li>ClusterNode：代表资源，一个资源不管出现在多少链路中，只会有一个 ClusterNode。记录的是当前资源被访问的所有统计数据之和。</li></ul><p><span style="background-color:#ff00ff">DefaultNode 记录的是资源在当前链路中的访问数据，用来实现基于链路模式的限流规则。ClusterNode 记录的是资源在所有链路中的访问数据，实现默认模式、关联模式的限流规则。</span></p><p>例如：我们在一个 SpringMVC 项目中，有两个业务：</p><ul><li>业务 1：controller 中的资源 <code>/order/query</code> 访问了 service 中的资源 <code>/goods</code></li><li>业务 2：controller 中的资源 <code>/order/save</code> 访问了 service 中的资源 <code>/goods</code></li></ul><p>创建的链路图如下：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131020.png" alt="image-20210925104726158"></p><h2 id="5-3-Entry"><a href="#5-3-Entry" class="headerlink" title="5.3. Entry"></a>5.3. Entry</h2><p>默认情况下，Sentinel <span style="background-color:#ff00ff">只会将 controller 中的方法作为被保护资源</span>，那么问题来了，我们该如何将自己的一段代码标记为一个 Sentinel 的资源呢？</p><h3 id="5-3-1-编码方式"><a href="#5-3-1-编码方式" class="headerlink" title="5.3.1. 编码方式"></a>5.3.1. 编码方式</h3><h3 id="5-3-2-基于注解标记资源"><a href="#5-3-2-基于注解标记资源" class="headerlink" title="5.3.2. 基于注解标记资源"></a>5.3.2. 基于注解标记资源</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131242.png" alt="image-20210925141507603"></p><h4 id="5-3-2-1-实现原理-SentinelAutoConfiguration"><a href="#5-3-2-1-实现原理-SentinelAutoConfiguration" class="headerlink" title="5.3.2.1. 实现原理 -SentinelAutoConfiguration"></a>5.3.2.1. 实现原理 -SentinelAutoConfiguration</h4><p><span style="display:none">%%<br>▶10.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230313-1321%%</span>❕ ^odpucd</p><p>来看下我们引入的 Sentinel 依赖包：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131300.png" alt="image-20210925115601560"></p><p>其中的 spring.factories 声明需要就是自动装配的配置类，内容如下：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131303.png" alt="image-20210925115740281"></p><p>我们来看下 <code>SentinelAutoConfiguration</code> 这个类：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230313131400.png" alt="image-20210925141553785"></p><p>可以看到，在这里声明了一个 Bean，<code>SentinelResourceAspect</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Aspect for methods with &#123;<span class="hljs-doctag">@link</span> SentinelResource&#125; annotation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Eric Zhao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelResourceAspect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSentinelAspectSupport</span> &#123;<br><span class="hljs-comment">// 切点是添加了 @SentinelResource注解的类</span><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sentinelResourceAnnotationPointcut</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕增强</span><br>    <span class="hljs-meta">@Around(&quot;sentinelResourceAnnotationPointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invokeResourceWithSentinel</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取受保护的方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">originMethod</span> <span class="hljs-operator">=</span> resolveMethod(pjp);<br><span class="hljs-comment">// 获取 @SentinelResource注解</span><br>        <span class="hljs-type">SentinelResource</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> originMethod.getAnnotation(SentinelResource.class);<br>        <span class="hljs-keyword">if</span> (annotation == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Should not go through here.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Wrong state for SentinelResource annotation&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取注解上的资源名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> getResourceName(annotation.value(), originMethod);<br>        <span class="hljs-type">EntryType</span> <span class="hljs-variable">entryType</span> <span class="hljs-operator">=</span> annotation.entryType();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resourceType</span> <span class="hljs-operator">=</span> annotation.resourceType();<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建资源 Entry</span><br>            entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());<br>            <span class="hljs-comment">// 执行受保护的方法</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pjp.proceed();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-keyword">return</span> handleBlockException(pjp, annotation, ex);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] exceptionsToIgnore = annotation.exceptionsToIgnore();<br>            <span class="hljs-comment">// The ignore list will be checked first.</span><br>            <span class="hljs-keyword">if</span> (exceptionsToIgnore.length &gt; <span class="hljs-number">0</span> &amp;&amp; exceptionBelongsTo(ex, exceptionsToIgnore)) &#123;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) &#123;<br>                traceException(ex);<br>                <span class="hljs-keyword">return</span> handleFallback(pjp, annotation, ex);<br>            &#125;<br><br>            <span class="hljs-comment">// No fallback function can handle the exception, so throw it out.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit(<span class="hljs-number">1</span>, pjp.getArgs());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>简单来说，@SentinelResource 注解就是一个标记，而 Sentinel 基于 AOP 思想，对被标记的方法做环绕增强，完成资源（<code>Entry</code>）的创建。</p><h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6. 面试题"></a>6. 面试题</h1><h2 id="6-1-Sentinel-的线程隔离与-Hystix-的线程隔离有什么差别-⭐️🔴"><a href="#6-1-Sentinel-的线程隔离与-Hystix-的线程隔离有什么差别-⭐️🔴" class="headerlink" title="6.1. Sentinel 的线程隔离与 Hystix 的线程隔离有什么差别?⭐️🔴"></a>6.1. Sentinel 的线程隔离与 Hystix 的线程隔离有什么差别?⭐️🔴</h2><p>线程池隔离：在业务请求到达 Tomcat 后，会给每一个被隔离的业务创建各自独立的线程池<br>信号量隔离：基于计数的信号量隔离</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301171403.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301171512.png" alt="image.png"></p><p>Hystix 默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的 CPU 开销，性能一般，但是隔离性更强。<br>Sentinel 是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。</p><h2 id="6-2-Sentinel-的限流与-Gateway-的限流有什么差别？"><a href="#6-2-Sentinel-的限流与-Gateway-的限流有什么差别？" class="headerlink" title="6.2. Sentinel 的限流与 Gateway 的限流有什么差别？"></a>6.2. Sentinel 的限流与 Gateway 的限流有什么差别？</h2><p><span style="display:none">%%<br>▶15.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230308-1356%%</span>❕ ^n7rdsh</p><p>限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。</p><p>Gateway 则采用了基于 Redis 实现的令牌桶算法。 ^cinpaa</p><p>而 Sentinel 内部却比较复杂：</p><ul><li><strong>默认限流模式</strong> 是基于<span style="background-color:#00ff00">滑动时间窗口算法</span></li><li><strong>排队等待限流</strong> 模式则基于<span style="background-color:#00ff00">漏桶算法 (Leaky Bucket)</span></li><li><strong>热点参数限流模式</strong> 则是基于<span style="background-color:#00ff00">令牌桶算法 (Token Bucket)</span></li></ul><h3 id="6-2-1-固定窗口计数器算法"><a href="#6-2-1-固定窗口计数器算法" class="headerlink" title="6.2.1. 固定窗口计数器算法"></a>6.2.1. 固定窗口计数器算法</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301172335.png" alt="image.png"><br>存在问题：前 1 秒的后半秒 3 个，后 1 秒的前半秒也有请求，就造成 1 秒内超过 3 个请求了，比如上图所示，前半秒 3 个后半秒 3 个达到了 6 个。</p><h3 id="6-2-2-滑动窗口计数器算法"><a href="#6-2-2-滑动窗口计数器算法" class="headerlink" title="6.2.2. 滑动窗口计数器算法"></a>6.2.2. 滑动窗口计数器算法</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301173011.png" alt="image.png"></p><p>存在问题：仍然会存在超阈值 (比如 3 个) 的情况，比如下图 850ms 内来了 4 个请求<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301173133.png" alt="image.png"></p><h3 id="6-2-3-令牌桶算法"><a href="#6-2-3-令牌桶算法" class="headerlink" title="6.2.3. 令牌桶算法"></a>6.2.3. 令牌桶算法</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301173342.png" alt="image.png"></p><h4 id="6-2-3-1-存在问题"><a href="#6-2-3-1-存在问题" class="headerlink" title="6.2.3.1. 存在问题"></a>6.2.3.1. 存在问题</h4><p>请求的时间分布不均匀时，可能出现短时间内达到阈值上限的情况。比如限流阈值为 5，设置令牌桶每秒生成 5 个令牌，前 1 秒没有任何请求过来，而第 2 秒一下子来了 10 个请求，那么第二秒总共生成的 10 个令牌就一下子被使用，而系统服务的上限是 5，那么就出现了过载现象。所以令牌桶的上限要设置为小于系统并发上线的数值，以防止出现上述情况。</p><h4 id="6-2-3-2-实现方式⭐️🔴"><a href="#6-2-3-2-实现方式⭐️🔴" class="headerlink" title="6.2.3.2. 实现方式⭐️🔴"></a>6.2.3.2. 实现方式⭐️🔴</h4><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230310-1035%%</span>❕ ^06vdeq</p><p>实际实现并没有真正去生成什么令牌，而是<span style="background-color:#ff00ff">基于计数和记录上次请求的时间</span></p><ol><li>如果本次请求时间与上次请求时间差是 1 秒内的，如果此时桶里有令牌可用，那么令牌已使用计数加 1，并且消耗 1 个令牌。如果没有令牌了则拒绝请求</li><li>如果本次请求时间与上次请求时间差大于 1 秒，就比较已使用令牌数与时间差值可以生成的令牌数的大小，如果时间差值生成令牌数大于已使用令牌数，那么说明令牌还有富余，则接受请求，否则说明超出令牌生成能力范围，则拒绝请求。</li></ol><h3 id="6-2-4-漏桶算法"><a href="#6-2-4-漏桶算法" class="headerlink" title="6.2.4. 漏桶算法"></a>6.2.4. 漏桶算法</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301174905.png" alt="image.png"></p><p>相比于令牌桶，漏桶的请求处理曲线非常平滑，也可以应对流量突发请求流量</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301175138.png" alt="image.png"></p><p><span style="background-color:#ff00ff">预期等待时长&#x3D;最近一次请求的预期等待时间 + 允许的间隔</span></p><h3 id="6-2-5-限流算法对比"><a href="#6-2-5-限流算法对比" class="headerlink" title="6.2.5. 限流算法对比"></a>6.2.5. 限流算法对比</h3><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230310-1116%%</span>❕ ^6pp17h</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230310104317.png" alt="image.png"></p><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><h2 id="8-1-黑马程序员"><a href="#8-1-黑马程序员" class="headerlink" title="8.1. 黑马程序员"></a>8.1. 黑马程序员</h2><h3 id="8-1-1-视频"><a href="#8-1-1-视频" class="headerlink" title="8.1.1. 视频"></a>8.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=144&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=144&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-1-2-资料"><a href="#8-1-2-资料" class="headerlink" title="8.1.2. 资料"></a>8.1.2. 资料</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/Users/taylor/Nutstore Files/Obsidian_data/pages/002-schdule/001-Arch/001-Subject/005-分布式专题/微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程/day01-微服务保护/讲义/微服务保护.md<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-雪崩问题&quot;&gt;&lt;a href=&quot;#1-雪崩问题&quot; class=&quot;headerlink&quot; title=&quot;1. 雪崩问题&quot;&gt;&lt;/a&gt;1. 雪崩问题&lt;/h1&gt;&lt;h2 id=&quot;1-1-是什么&quot;&gt;&lt;a href=&quot;#1-1-是什么&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-1、基本原理</title>
    <link href="https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.680Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-SpringBoot-的特性"><a href="#1-SpringBoot-的特性" class="headerlink" title="1. SpringBoot 的特性"></a>1. SpringBoot 的特性</h1><p><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=117&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=117&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="1-1-依赖管理"><a href="#1-1-依赖管理" class="headerlink" title="1.1. 依赖管理"></a>1.1. 依赖管理</h2><h3 id="1-1-1-父项目做依赖管理"><a href="#1-1-1-父项目做依赖管理" class="headerlink" title="1.1.1. 父项目做依赖管理"></a>1.1.1. 父项目做依赖管理</h3><p>   1、无需关注版本号，自动版本仲裁<br>   2、可以修改默认版本号</p><h3 id="1-1-2-starter-场景启动器"><a href="#1-1-2-starter-场景启动器" class="headerlink" title="1.1.2. starter 场景启动器"></a>1.1.2. starter 场景启动器</h3><p>  <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230226073735.png" alt="image.png"></p><p>1、见到很多 spring-boot-starter-xxx ： xxx 就某种场景<br>2、只要引入 starter，这个场景的所有常规需要的依赖我们都自动引入<br>3、SpringBoot 所有支持的场景<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a><br>4、见到的 xxx-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。<br>5、所有场景启动器最底层的依赖</p><h2 id="1-2-自动配置"><a href="#1-2-自动配置" class="headerlink" title="1.2. 自动配置"></a>1.2. 自动配置</h2><p>● 自动配好 Tomcat<br>          ○ 引入 Tomcat 依赖。<br>          ○ 配置 Tomcat<br>       ● 自动配好 SpringMVC<br>          ○ 引入 SpringMVC 全套组件<br>          ○ 自动配好 SpringMVC 常用组件（功能）<br>● 自动配好 Web 常见功能，如：字符编码问题<br>          ○ SpringBoot 帮我们配置好了所有 web 开发的常见场景<br>● 默认的包结构<br>          ○ 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来<br>          ○ 无需以前的包扫描配置<br>          ○ 想要改变扫描路径，@SpringBootApplication(scanBasePackages&#x3D;”com.atguigu”)<br>       ● 或者@ComponentScan 指定扫描路径<br>       ● 各种配置拥有默认值<br>          ○ 默认配置最终都是映射到某个类上，如：MultipartProperties<br>          ○ 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象<br>       ● 按需加载所有自动配置项<br>          ○ 非常多的 starter<br>          ○ 引入了哪些场景这个场景的自动配置才会开启<br>          ○ SpringBoot 所有的自动配置功能都在 spring-boot-autoconfigure 包里面</p><h1 id="2-谈谈你对-SpringBoot-的理解-优点特性"><a href="#2-谈谈你对-SpringBoot-的理解-优点特性" class="headerlink" title="2. 谈谈你对 SpringBoot 的理解 (优点特性)"></a>2. 谈谈你对 SpringBoot 的理解 (优点特性)</h1><p>SpringBoot 的用来快速开发 Spring 应用的一个脚手架、其设计目的是用来简新 Spring 应用的初始搭建以及开发过程。</p><ol><li>SpringBoot 提供了很多内置的 Starter 结合自动配置，实现了对主流框架的<span style="background-color:#00ff00">无配置集成</span>、开箱即用；</li><li>SpringBoot 简化了开发，采用 JavaConfig 的方式可以使用<span style="background-color:#00ff00">零 xml</span>的方式进行开发；</li><li>SpringBoot<span style="background-color:#00ff00">内置 Web 容器</span>无需依赖外部 Web 服务器，省略了 Web.xml，直接运行 jar 文件就可以启动 web 应用；</li><li>SpringBoot 帮我管理了常用的第三方依赖的版本，<span style="background-color:#00ff00">减少出现版本冲突</span>的问题；</li><li>SpringBoot<span style="background-color:#00ff00">自带了监控功能</span>，可以监控应用程序的运行状况，或者内存、线程池、Http 请求统计等，同时还提供了优雅关闭应用程序等功能。</li></ol><h1 id="3-SpringBoot-自动配置原理-SpringBootApplication-⭐️🔴"><a href="#3-SpringBoot-自动配置原理-SpringBootApplication-⭐️🔴" class="headerlink" title="3. SpringBoot 自动配置原理 -@SpringBootApplication ⭐️🔴"></a>3. SpringBoot 自动配置原理 -@SpringBootApplication ⭐️🔴</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230303-0844%%</span><br>^py2rrk<br><a href="https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM">https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM</a> ^c46210</p><h2 id="3-1-引导加载自动配置类"><a href="#3-1-引导加载自动配置类" class="headerlink" title="3.1. 引导加载自动配置类"></a>3.1. 引导加载自动配置类</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230326-2214%%</span>❕ ^dxovlh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication&#123;&#125;   <br></code></pre></td></tr></table></figure><h3 id="3-1-1-SpringBootConfiguration"><a href="#3-1-1-SpringBootConfiguration" class="headerlink" title="3.1.1. @SpringBootConfiguration"></a>3.1.1. @SpringBootConfiguration</h3><p>@Configuration。代表当前是一个配置类</p><h3 id="3-1-2-ComponentScan"><a href="#3-1-2-ComponentScan" class="headerlink" title="3.1.2. @ComponentScan"></a>3.1.2. @ComponentScan</h3><p>指定扫描哪些，是一个 Spring 注解；<br>在 SpringBoot 中，在该注解属性中配置了排除规则：排除 2 种类型：<br>①继承了 TypeExcludeFilter 的类<br>②SpringBoot 的自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  </span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></code></pre></td></tr></table></figure><h3 id="3-1-3-EnableAutoConfiguration"><a href="#3-1-3-EnableAutoConfiguration" class="headerlink" title="3.1.3. @EnableAutoConfiguration"></a>3.1.3. @EnableAutoConfiguration</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222142714.png" alt="image.png"></p><h4 id="3-1-3-1-AutoConfigurationPackage"><a href="#3-1-3-1-AutoConfigurationPackage" class="headerlink" title="3.1.3.1. @AutoConfigurationPackage"></a>3.1.3.1. @AutoConfigurationPackage</h4><p><span style="display:none">%%<br>▶6.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-1703%%</span>❕ ^j6d450</p><p><code>@Import(AutoConfigurationPackages.Registrar.class)</code><br>自动配置包，指定了默认的包规则，将指定的<span style="background-color:#ff00ff">一个包下的所有组件</span>导入进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span>  <br><span class="hljs-comment">//给容器中导入一个组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br><span class="hljs-comment">//利用Registrar给容器中导入一系列组件</span><br><span class="hljs-comment">//将指定的一个包下的所有组件导入进来，MainApplication 所在包下。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326072101.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222160725.png" alt="image.png"></p><h4 id="3-1-3-2-Import-AutoConfigurationImportSelector-class"><a href="#3-1-3-2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="3.1.3.2. @Import(AutoConfigurationImportSelector.class)"></a>3.1.3.2. @Import(AutoConfigurationImportSelector.class)</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230324173014.png" alt="image.png"></p><p>selectImports→getAutoConfigurationEntry 获取到所有需要导入到容器中的配置类</p><p><span style="background-color:#ff00ff">方法调用路径</span><br>    AutoConfigurationImportSelector. <code>getAutoConfigurationEntry</code> &#x3D;&#x3D;→&#x3D;&#x3D;  <span style="background-color:#ff00ff">SpringFactoriesLoader</span>. <code>loadSpringFactories</code> &#x3D;&#x3D;→&#x3D;&#x3D;<br>    classLoader.getResources(“<code>META-INF/spring.factories</code>“)</p><p><span style="background-color:#ff00ff">默认扫描当前系统里面所有 META-INF&#x2F;spring.factories 位置的文件</span> ❕<span style="display:none">%%<br>▶2.🏡⭐️◼️自定义 starter 就是依靠这种策略 ?🔜MSTM📝 可以被扫描到需要注入的组件◼️⭐️-point-20230226-0847%%</span></p><p>比如 <code>spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件<br><span class="hljs-number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类<br><span class="hljs-number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span>；得到所有的组件<br><span class="hljs-number">4</span>、从META-INF/spring.factories位置来加载一个文件。<br>默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件<br>    spring-boot-autoconfigure-<span class="hljs-number">2.3</span><span class="hljs-number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories<br>    <br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222162310.png" alt="image.png"></p><h5 id="3-1-3-2-1-SPI-原理"><a href="#3-1-3-2-1-SPI-原理" class="headerlink" title="3.1.3.2.1. SPI 原理"></a>3.1.3.2.1. SPI 原理</h5><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-0804%%</span>❕ ^bypdob</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304124004.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304132455.png" alt="image.png"></p><h2 id="3-2-按需开启自动配置项"><a href="#3-2-按需开启自动配置项" class="headerlink" title="3.2. 按需开启自动配置项"></a>3.2. 按需开启自动配置项</h2><p>虽然我们 127 个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration，但按照条件装配规则（@Conditional），最终会按需配置。</p><h2 id="3-3-修改默认配置"><a href="#3-3-修改默认配置" class="headerlink" title="3.3. 修改默认配置"></a>3.3. 修改默认配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="hljs-comment">//容器中有这个类型组件</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="hljs-comment">//容器中没有这个名字 multipartResolver 的组件</span><br><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> &#123;<br>            <span class="hljs-comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span><br>            <span class="hljs-comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span><br><span class="hljs-comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span><br><span class="hljs-keyword">return</span> resolver;<br>&#125;<br>给容器中加入了文件上传解析器；<br><br></code></pre></td></tr></table></figure><p><span style="background-color:#00ff00">SpringBoot 默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</span></p><h2 id="3-4-与-SpringMVC-配置的区别"><a href="#3-4-与-SpringMVC-配置的区别" class="headerlink" title="3.4. 与 SpringMVC 配置的区别"></a>3.4. 与 SpringMVC 配置的区别</h2><h3 id="3-4-1-关于-JSON-编码配置"><a href="#3-4-1-关于-JSON-编码配置" class="headerlink" title="3.4.1. 关于 JSON 编码配置"></a>3.4.1. 关于 JSON 编码配置</h3><p>Spring 整合 SpringMVC 时需要设置 JSON 格式<br>Springboot 不需要，因为在<artifactId>spring-boot-starter-web</artifactId>中<br>自动配置了 jacjson-databind，使用的是 <code>MappingJackson2HttpMessageConverter</code></p><h3 id="3-4-2-EnableAspectJAutoProxy⭐️🔴"><a href="#3-4-2-EnableAspectJAutoProxy⭐️🔴" class="headerlink" title="3.4.2. @EnableAspectJAutoProxy⭐️🔴"></a>3.4.2. @EnableAspectJAutoProxy⭐️🔴</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302142824.png" alt="image.png"></p><p>在 Spring 中，如果不在配置类中添加@EnableAspectJAutoProxy，那么所有 <a href="https://so.csdn.net/so/search?q=%E5%88%87%E9%9D%A2&spm=1001.2101.3001.7020">切面</a> 注解是不生效的（springboot 因为有自动配置，所以不需要开发人员手工配置@EnableAspectJAutoProxy）</p><h2 id="3-5-自动配置总结"><a href="#3-5-自动配置总结" class="headerlink" title="3.5. 自动配置总结"></a>3.5. 自动配置总结</h2><ul><li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties 里面拿。xxxProperties 和配置文件进行了绑定</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置<ul><li>用户直接自己@Bean 替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt;</strong> <strong>xxxxProperties 里面拿值 —-&gt; application.properties</strong></p><h2 id="3-6-黑马补充"><a href="#3-6-黑马补充" class="headerlink" title="3.6. 黑马补充"></a>3.6. 黑马补充</h2><p><a href="https://www.bilibili.com/video/BV15b4y117RJ?p=172&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y117RJ?p=172&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325121857.png" alt="image.png"></p><h1 id="4-SpringBoot-的启动原理⭐️🔴"><a href="#4-SpringBoot-的启动原理⭐️🔴" class="headerlink" title="4. SpringBoot 的启动原理⭐️🔴"></a>4. SpringBoot 的启动原理⭐️🔴</h1><p><span style="display:none">%%<br>▶15.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1327%%</span>❕ ^ro0jas<br><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0703%%</span>❕ ^214fh8</p><p><strong>概述</strong></p><ol><li>运行 main 方法： 初始化 new SpringApplication  从 spring.factories  读取 ApplicationListener、ApplicationContextInitializer</li><li>运行 run 方法</li><li>读取环境变量配置信息</li><li>创建 springApplication 上下文： ServletWebServerApplicationContext</li><li>预初始化上下文 </li><li>调用 refresh 加载 ioc 容器 <br><code>invokeBeanFactoryPostProcessor </code>  <span style="background-color:#00ff00">解析@Import</span>:  加载所有的自动配置类<br><code>onRefresh</code>  <span style="background-color:#00ff00">创建 (内置)servlet 容器</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224181156.png" alt="image.png"></li></ol><p>在这个过程中 springboot 会调用很多监听器对外进行扩展<br><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=196&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=196&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="4-1-创建-SpringApplication"><a href="#4-1-创建-SpringApplication" class="headerlink" title="4.1. 创建 SpringApplication"></a>4.1. 创建 SpringApplication</h2><p>   <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224142822.png" alt="image.png"></p><ol><li>判定当前应用的类型。ClassUtils.isPresent → WebApplicationType.SERVLET</li><li>使用系统方法 <code>getSpringFactoriesInstances</code> 分别查找以下类型：<br>○ 查找 <font color=#ff0000>bootstrappers</font>：&#x3D;&#x3D;初始启动引导器&#x3D;&#x3D;<br>  去 <code>spring.factories</code> 文件中找 org.springframework.boot. <code>Bootstrapper</code><br>  放入 <code>List&lt;Bootstrapper&gt;</code><br>○ 查找 <font color=#ff0000>ApplicationContextInitializer</font>：&#x3D;&#x3D;初始化器&#x3D;&#x3D;<br>    去 spring.factories 找 ApplicationContextInitializer<br>    放入 <code>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers</code><br>○ 查找 <font color=#ff0000>ApplicationListener</font>  ：&#x3D;&#x3D;应用监听器&#x3D;&#x3D;<br>    去 spring.factories 找 ApplicationListener<br>    放入 <code>List&lt;ApplicationListener&lt;?&gt;&gt; listeners</code></li><li><span style="background-color:#ff00ff">保存当前启动类为配置类</span></li></ol><h2 id="4-2-运行-SpringApplication"><a href="#4-2-运行-SpringApplication" class="headerlink" title="4.2. 运行 SpringApplication"></a>4.2. 运行 SpringApplication</h2><h3 id="4-2-1-记录应用的启动时间-创建引导上下文-bootstrappers-intitialize"><a href="#4-2-1-记录应用的启动时间-创建引导上下文-bootstrappers-intitialize" class="headerlink" title="4.2.1. 记录应用的启动时间 - 创建引导上下文 -bootstrappers.intitialize"></a>4.2.1. 记录应用的启动时间 - 创建引导上下文 -bootstrappers.intitialize</h3><p>  ○ <strong>StopWatch</strong>，记录应用的启动时间<br>  ○ 创建引导上下文（Context 环境）createBootstrapContext()<br>    ■ <span style="background-color:#ff00ff">获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置</span><br>  ○ 让当前应用进入 headless 模式。java.awt.headless</p><h3 id="4-2-2-发布-ApplicationStartingEvent-事件"><a href="#4-2-2-发布-ApplicationStartingEvent-事件" class="headerlink" title="4.2.2. 发布 ApplicationStartingEvent 事件"></a>4.2.2. 发布 ApplicationStartingEvent 事件</h3><p>  ○ <span style="background-color:#ff00ff">获取所有 RunListener（运行监听器）</span><span style="background-color:#00ff00">【为了方便所有 Listener 进行事件感知】</span><br>    ■ getSpringFactoriesInstances 去 spring.factories 找 SpringApplicationRunListener.<br>  ○ <span style="background-color:#ff00ff">遍历 SpringApplicationRunListener 调用 starting 方法</span>；<br>    ■ 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</p><h3 id="4-2-3-读取环境配置信息发布-environmentPreparedEvent"><a href="#4-2-3-读取环境配置信息发布-environmentPreparedEvent" class="headerlink" title="4.2.3. 读取环境配置信息发布 environmentPreparedEvent"></a>4.2.3. 读取环境配置信息发布 environmentPreparedEvent</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180423.png" alt="image.png"></p><p>  ○ <span style="background-color:#ff00ff">保存命令行参数</span>；ApplicationArguments<br>  ○ 准备环境 prepareEnvironment（）;<br>    ■ 返回或者创建基础环境信息对象。StandardServletEnvironment<br>    ■ 配置环境信息对象。<br><span style="background-color:#ff00ff"> ● 读取所有的配置源的配置属性值：<br><code>ConfigFileApplicationListener</code> 会监听 <code>onApplicationEnvironmentPreparedEvent</code> 事件来加载配置文件 <code>application.properties</code> 的环境变量</span><br>    ■ 绑定环境信息<br>    ■ 监听器调用 listener.environmentPrepared()；<span style="background-color:#ff00ff">通知所有的监听器当前环境准备完成</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227132255.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227124928.png" alt="image.png"></p><h3 id="4-2-4-根据项目类型创建-IOC-容器⭐️🔴"><a href="#4-2-4-根据项目类型创建-IOC-容器⭐️🔴" class="headerlink" title="4.2.4. 根据项目类型创建 IOC 容器⭐️🔴"></a>4.2.4. 根据项目类型创建 IOC 容器⭐️🔴</h3><p>  ○ <span style="background-color:#ff00ff">实例化 Spring 上下文（createApplicationContext（））</span><br>    ■ 根据项目类型（Servlet）创建相应的 WEB 容器<br>    ■ 当前会创建 <code>AnnotationConfigServletWebServerApplicationContext</code></p><h3 id="4-2-5-准备-IOC-容器基本信息-刷新前准备-contextPrepared-loaded"><a href="#4-2-5-准备-IOC-容器基本信息-刷新前准备-contextPrepared-loaded" class="headerlink" title="4.2.5. 准备 IOC 容器基本信息 (刷新前准备 -contextPrepared-loaded)"></a>4.2.5. 准备 IOC 容器基本信息 (刷新前准备 -contextPrepared-loaded)</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180542.png" alt="image.png"></p><p>  ○ 准备 ApplicationContext IOC 容器的基本信息 prepareContext()<br>    ■ 保存环境信息<br>    ■ IOC 容器的后置处理流程。<br>    ■ 应用初始化器；applyInitializers；<br>      ● <span style="background-color:#ff00ff">遍历所有的 ApplicationContextInitializer 。调用 initialize</span>。来对 ioc 容器进行初始化扩展功能<br>      ● <span style="background-color:#ff00ff">遍历所有的 listener 调用 contextPrepared</span>。EventPublishRunListenr；通知所有的监听器 <code>contextPrepared</code><br>      <span style="background-color:#ffff00">● 将启动类作为配置类进行读取 –&gt;将配置注册为 BeanDefinition</span> <span style="background-color:#ff0000">未看到有这块代码</span><br>       ■ 所有的监听器调用 <code>contextLoaded</code>。<span style="background-color:#ff00ff">通知所有的监听器 contextLoaded</span>；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227132333.png" alt="image.png"></p><h3 id="4-2-6-刷新-IOC-容器⭐️🔴"><a href="#4-2-6-刷新-IOC-容器⭐️🔴" class="headerlink" title="4.2.6. 刷新 IOC 容器⭐️🔴"></a>4.2.6. 刷新 IOC 容器⭐️🔴</h3><p>  ○ <span style="background-color:#ff00ff">刷新 IOC 容器。refreshContext</span><br>    ■ 创建容器中的所有组件（Spring 注解）<br>  ○ 容器刷新完成后工作 afterRefresh 无实现，可扩展</p><p><code>AnnotationConfigServletWebServerApplicationContext.refresh</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180854.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180945.png" alt="image.png"></p><h4 id="4-2-6-1-invokeBeanFactoryPostProcessors"><a href="#4-2-6-1-invokeBeanFactoryPostProcessors" class="headerlink" title="4.2.6.1. invokeBeanFactoryPostProcessors"></a>4.2.6.1. invokeBeanFactoryPostProcessors</h4><p><code>invokeBeanFactoryPostProcessor </code>  <span style="background-color:#00ff00">解析@Import</span>:  加载所有的自动配置类<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️SpringBoot 启动时配置类解析的时机 ?🔜MSTM📝 跟 Spring 是相同的，都是在第 5 步 invokeBeanFactoryPostProcessors。而且在 onrefresh 方法中创建了 Servlet 容器◼️⭐️-point-20230224-1821%%</span></p><h4 id="4-2-6-2-onrefresh-创建子容器"><a href="#4-2-6-2-onrefresh-创建子容器" class="headerlink" title="4.2.6.2. onrefresh 创建子容器"></a>4.2.6.2. onrefresh 创建子容器</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224173708.png" alt="image.png"><br><code>onRefresh</code>  <span style="background-color:#00ff00">创建 (内置)servlet 容器</span></p><h3 id="4-2-7-记录启动结束时间并输出"><a href="#4-2-7-记录启动结束时间并输出" class="headerlink" title="4.2.7. 记录启动结束时间并输出"></a>4.2.7. 记录启动结束时间并输出</h3><h3 id="4-2-8-发布-ApplicationStartedEvent"><a href="#4-2-8-发布-ApplicationStartedEvent" class="headerlink" title="4.2.8. 发布 ApplicationStartedEvent"></a>4.2.8. 发布 ApplicationStartedEvent</h3><p>  ○ 所有监听器调用 listeners.started(context); <span style="background-color:#ff00ff">通知所有的监听器 started</span></p><h3 id="4-2-9-调用所有-runners"><a href="#4-2-9-调用所有-runners" class="headerlink" title="4.2.9. 调用所有 runners"></a>4.2.9. 调用所有 runners</h3><p>  ○ 调用所有 runners；callRunners()<br>    ■ 获取容器中的 ApplicationRunner<br>    ■ 获取容器中的 CommandLineRunner<br>    ■ 合并所有 runner 并且按照@Order 进行排序<br>    ■ 遍历所有的 runner。调用 run 方法<br>  ○ 如果以上有异常，<br>    ■ 调用 Listener 的 failed</p><h3 id="4-2-10-如果启动异常则发送-ApplicationFailedEvent"><a href="#4-2-10-如果启动异常则发送-ApplicationFailedEvent" class="headerlink" title="4.2.10. 如果启动异常则发送 ApplicationFailedEvent"></a>4.2.10. 如果启动异常则发送 ApplicationFailedEvent</h3><p>  ○ 调用所有监听器的 running 方法 listeners.running(context); <span style="background-color:#ff00ff">通知所有的监听器 running</span><br>  ○ running 如果有问题。继续通知 failed 。调用所有 Listener 的 failed；<span style="background-color:#ff00ff">通知所有的监听器 failed</span></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/584866-20201221110418589-124191923.jpg" alt="img"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/1032567-20160930171658625-1237959183.png" alt="img"></p><h1 id="5-嵌入式-Servlet-容器启动原理-V2"><a href="#5-嵌入式-Servlet-容器启动原理-V2" class="headerlink" title="5. 嵌入式 Servlet 容器启动原理 V2"></a>5. 嵌入式 Servlet 容器启动原理 V2</h1><p><span style="display:none">%%<br>▶4.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0706%%</span>❕ ^kb445n</p><p>SpringBoot_V1:  <a href="https://www.bilibili.com/video/BV1mf4y1c7cV/?p=79&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV/?p=79&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>SpringBoot_V2:  <a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222110234.png" alt="image.png"></p><h2 id="5-1-引入依赖触发自动配置"><a href="#5-1-引入依赖触发自动配置" class="headerlink" title="5.1. 引入依赖触发自动配置"></a>5.1. 引入依赖触发自动配置</h2><h3 id="5-1-1-容器工厂自动配置类⭐️🔴"><a href="#5-1-1-容器工厂自动配置类⭐️🔴" class="headerlink" title="5.1.1. 容器工厂自动配置类⭐️🔴"></a>5.1.1. 容器工厂自动配置类⭐️🔴</h3><p>当引入 <code>spring-boot-starter-web</code> 依赖时会在 SpringBoot 中添加并生效<br>servlet 容器工厂自动配置类： <code>ServletWebServerFactoryAutoConfiguration</code><br>(生效原理： <code>@ConditionalOnWebApplication(type = Type.SERVLET)</code>)<br>V1: EmbeddedServletContainerAutoConfiguration</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227100508.png" alt="image.png"></p><h3 id="5-1-2-Web-容器工厂-默认-Tomcat"><a href="#5-1-2-Web-容器工厂-默认-Tomcat" class="headerlink" title="5.1.2. Web 容器工厂 - 默认 Tomcat"></a>5.1.2. Web 容器工厂 - 默认 Tomcat</h3><p>该自动配置类通过@Import 导入了 (通过@ConditionalOnClass 判断决定使用哪一个) 一个 Web 容器工厂（默认 web-starter 会导入 tomcat 包)，即 <code>TomcatServletWebServerFactory</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325201425.png" alt="image.png"></p><h3 id="5-1-3-Web-容器工厂定制化器的后置处理器"><a href="#5-1-3-Web-容器工厂定制化器的后置处理器" class="headerlink" title="5.1.3. Web 容器工厂定制化器的后置处理器"></a>5.1.3. Web 容器工厂定制化器的后置处理器</h3><h4 id="5-1-3-1-BeanPostProcessorsRegistrar"><a href="#5-1-3-1-BeanPostProcessorsRegistrar" class="headerlink" title="5.1.3.1. BeanPostProcessorsRegistrar"></a>5.1.3.1. BeanPostProcessorsRegistrar</h4><p>在 <code>ServletWebServerFactoryAutoConfiguration</code> 中还通过 <code>BeanPostProcessorsRegistrar</code> 引入了<span style="background-color:#ff00ff">容器工厂定制化器的后置处理器</span> <code>WebServerFactoryCustomizerBeanPostProcessor</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090251.png" alt="image.png"></p><p><code>WebServerFactoryCustomizerBeanPostProcessor</code>，会获取所有的定制器，调用每个定制器的 customer 方法，<span style="background-color:#ff00ff">用来给 Servlet 容器进行赋值</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090135.png" alt="image.png"></p><p>V1: <code>EmbeddedServletContainerCustomizerBeanPostProcessor</code></p><h4 id="5-1-3-2-WebServerFactoryCustomizer-容器工厂定制化器-⭐️🔴"><a href="#5-1-3-2-WebServerFactoryCustomizer-容器工厂定制化器-⭐️🔴" class="headerlink" title="5.1.3.2. WebServerFactoryCustomizer(容器工厂定制化器)⭐️🔴"></a>5.1.3.2. WebServerFactoryCustomizer(容器工厂定制化器)⭐️🔴</h4><p>我们在自定义容器配置时，也可以使用这个 <code>WebServerFactoryCustomizer</code><br>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizationBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableServletWebServerFactory&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory server)</span> &#123;<br>        server.setPort(<span class="hljs-number">9000</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-SpringBoot-应用执行-Run-方法"><a href="#5-2-SpringBoot-应用执行-Run-方法" class="headerlink" title="5.2. SpringBoot 应用执行 Run 方法"></a>5.2. SpringBoot 应用执行 Run 方法</h2><p><code>SpringApplication.run(Boot05WebAdminApplication.class, args);</code></p><h3 id="5-2-1-创建-IOC-容器"><a href="#5-2-1-创建-IOC-容器" class="headerlink" title="5.2.1. 创建 IOC 容器"></a>5.2.1. 创建 IOC 容器</h3><p>【创建 IOC 容器对象，并初始化容器，创建容器的每一个组件】；如果是 web 环境则创建 AnnotationConfig&#x3D;&#x3D;ServletWebServer&#x3D;&#x3D;ApplicationContext。如果不是 web 环境则创建 AnnotationConfigApplicationContext</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224184939.png" alt="image.png"></p><p>SpringBoot_V2:<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190131.png" alt="image.png"></p><p>SpringBoot_V1:<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222190659.png" alt="image.png"></p><h3 id="5-2-2-调用父类-refresh"><a href="#5-2-2-调用父类-refresh" class="headerlink" title="5.2.2. 调用父类 refresh()"></a>5.2.2. 调用父类 refresh()</h3><p>刷新创建好的 IOC 容器<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222191503.png" alt="image.png"></p><h3 id="5-2-3-执行重写的-onRefresh-方法"><a href="#5-2-3-执行重写的-onRefresh-方法" class="headerlink" title="5.2.3. 执行重写的 onRefresh() 方法"></a>5.2.3. 执行重写的 onRefresh() 方法</h3><p>刷新 12 步中的第 9 步：web 的 IOC 容器 <code>ServletWebServerApplicationContext</code> <span style="background-color:#ff00ff">重写了 onRefresh 方法</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227090720.png" alt="image.png"><br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️新技能 get ?🔜MSTM📝 前面的图标都点点看看◼️⭐️-point-20230227-0907%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222191532.png" alt="image.png"></p><h3 id="5-2-4-从容器中获取-TomcatServletWebServerFactory"><a href="#5-2-4-从容器中获取-TomcatServletWebServerFactory" class="headerlink" title="5.2.4. 从容器中获取 TomcatServletWebServerFactory"></a>5.2.4. 从容器中获取 TomcatServletWebServerFactory</h3><p>V1：EmbeddedServletContainerFactory<br>因为前面有@Bean 注解注入，所以可以从 IOC 容器中获取嵌入式的 Servlet 容器工厂 TomcatServletWebServerFactory，然后就可以用来创建 Servlet 容器<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090820.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091509.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091355.png" alt="image.png"></p><h3 id="5-2-5-后置处理器执行配置定制"><a href="#5-2-5-后置处理器执行配置定制" class="headerlink" title="5.2.5. 后置处理器执行配置定制"></a>5.2.5. 后置处理器执行配置定制</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302095054.png" alt="image.png"></p><p>当 TomcatServletWebServerFactory 创建 Servlet 容器对象时，后置处理器看这个对象，就来获取所有的定制器来定制 Servlet 容器的相关配置；</p><h3 id="5-2-6-创建-Servlet-容器并启动"><a href="#5-2-6-创建-Servlet-容器并启动" class="headerlink" title="5.2.6. 创建 Servlet 容器并启动"></a>5.2.6. 创建 Servlet 容器并启动</h3><p>通过 <code>getWebServer</code> 创建嵌入式的 Servlet 容器；<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091847.png" alt="image.png"></p><h3 id="5-2-7-顺序总结"><a href="#5-2-7-顺序总结" class="headerlink" title="5.2.7. 顺序总结"></a>5.2.7. 顺序总结</h3><p>IOC 容器启动时创建 Servlet 容器，然后先启动嵌入式的 Servlet 容器，最后再将 IOC 容器中剩下的没有创建出的对象创建出来</p><h2 id="5-3-概述"><a href="#5-3-概述" class="headerlink" title="5.3. 概述"></a>5.3. 概述</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190813.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190858.png" alt="image.png"><br>❕<span style="display:none">%%<br>▶2.🏡⭐️◼️SpringBoot 中 SpringMVC 与 Spring 整合的 SpringMVC 区别 ?🔜MSTM📝 一般的 SpringMVC 是需要启动子容器的，而 SpringBoot 中只有 1 个容器，SpringMVC 是通过注入自动配置类生成的◼️⭐️-point-20230224-1911%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227093856.png" alt="image.png"></p><h1 id="6-SpringBoot-外置-Tomcat-启动原理⭐️🔴"><a href="#6-SpringBoot-外置-Tomcat-启动原理⭐️🔴" class="headerlink" title="6. SpringBoot 外置 Tomcat 启动原理⭐️🔴"></a>6. SpringBoot 外置 Tomcat 启动原理⭐️🔴</h1><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0704%%</span>❕ ^er3z4j</p><p><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="6-1-操作步骤⭐️🔴"><a href="#6-1-操作步骤⭐️🔴" class="headerlink" title="6.1. 操作步骤⭐️🔴"></a>6.1. 操作步骤⭐️🔴</h2><p>1、必须创建一个 war 项目；<br>2、将嵌入式的 Tomcat 指定为 <code>provided</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、必须编写一个 <code>SpringBootServletInitializer</code> 的子类，并重写 configure 方法里面的写法，遵照固定写法，将 SpringBoot 的启动类放入 <code>application.sources </code> 的方法参数中。 ❕<span style="display:none">%%<br>▶13.🏡⭐️◼️使用外置的 Tomcat 启动 SpringBoot 项目的方法 ?🔜MSTM📝 需要编写一个 SpringBootServletInitializer 的子类，并将 SpringBoot 启动类放入到重写的 Configurer 方法中 application.sources 的入参中。◼️⭐️-point-20230302-1656%%</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalServletInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder application)</span> &#123;<br>        <span class="hljs-comment">//传入SpringBoot的主程序，</span><br>        <span class="hljs-keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4、启动服务器就可以；</p><h2 id="6-2-底层原理⭐️🔴"><a href="#6-2-底层原理⭐️🔴" class="headerlink" title="6.2. 底层原理⭐️🔴"></a>6.2. 底层原理⭐️🔴</h2><p>利用了 servlet3.0 规范官方文档：  当 servlet 容器启动时候就会去所有 jar 包中的 <code>META-INF/services</code>  文件夹中找到 <code>javax.servlet.ServletContainerInitializer</code>，有的 jar 包中存在这个文件并在里面会绑定一个 <code>ServletContainerInitializer</code>.   当 servlet 容器启动时候就会去该文件中找到 ServletContainerInitializer 的实现类，从而 <code>创建它的实例并调用其 onstartUp 方法</code><br>❕<span style="display:none">%%<br>▶14.🏡⭐️◼️标准的 SPI 机制：Tomcat 启动后会遍历查看所有 jar 包中 META-INF&#x2F;services 目录下的 javax.servlet.ServletContainerInitializer 文件中配置的全限定名为 <code>org.springframework.web.SpringServletContainerInitializer</code>，new Instance 并放入感兴趣的类集合中，遍历调用他们的 onstartup 方法；伪 SPI 机制：SpringBoot 的自动配置类的加载方式，启动时查找 META-INF&#x2F;spring.factories 文件中 enableAutoConfiguration&#x3D;xxx,\，根据每个类上@ConditionalOn 等条件判断，将 xxx 加载并创建 Bean◼️⭐️-point-20230302-1827%%</span></p><h2 id="6-3-执行流程"><a href="#6-3-执行流程" class="headerlink" title="6.3. 执行流程"></a>6.3. 执行流程</h2><p><span style="display:none">%%<br>▶9.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1054%%</span>❕ ^7d9w7<br>1、启动 Tomcat 服务器<br>2、spring web 模块里有这个文件</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224210917.png" alt="image.png"></p><p>文件内容是： <code>org.springframework.web.SpringServletContainerInitializer</code><br>3、SpringServletContainerInitializer 将 handlerTypes 标注的所有类型的类传入到 onStartip 方法的 <code>Set&lt;Class&lt;?&gt;&gt;</code> 中，并为这些感兴趣类创建实例<br>4、每个创建好的 WebApplicationInitializer 调用自己的 onStratup<br>5、因为有下图所示的继承关系，我们编写的 <code>ExternalServletInitializer</code> 和 <code>SpringBootServletInitializer</code> 都会被创建实例，并执行各自的 <code>StartUp</code> 方法，然而 ExternalServletInitializer 没有该方法，所以会调用其父类 SpringBootServletInitializer 的 onstartUp 方法。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224204100.png" alt="image.png"></p><p>6、<code>SpringBootServletInitializer</code> 执行 onStartup 方法会执行 createRootApplicationContext，在调用其中的 <code>Configure</code> 时，由于其子类 <code>ExternalServletInitializer</code> 重写了这个方法，所以会调用子类重写的这个方法，那么就会将 SpringBoot 的主程序类传入进来。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224210646.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224204134.png" alt="image.png"></p><p>7、build SpringApplication 并启动；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325223837.png" alt="image.png"></p><h2 id="6-4-其他"><a href="#6-4-其他" class="headerlink" title="6.4. 其他"></a>6.4. 其他</h2><p><a href="https://www.bilibili.com/video/BV1gW411W76m?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1gW411W76m?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>嵌入式的 Servlet 容器：应用打成 jar 包<br>​优点：简单、便携<br>​缺点：默认不支持 JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂）</p><p>外置的 Servlet 容器：外面安装 Tomcat 是以 war 包的方式打包。<br><a href="https://www.bilibili.com/video/BV1gW411W76m?p=52&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1gW411W76m?p=52&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h1 id="7-SpringBoot-的核心注解"><a href="#7-SpringBoot-的核心注解" class="headerlink" title="7. SpringBoot 的核心注解"></a>7. SpringBoot 的核心注解</h1><p>1. @SpringBootApplication 注解：这个注解标识了一个 SpringBoot 工程，它实际上是另外三个注解的组合，这三个注解是：<br>        ① @SpringBootConfiguration ：这个注解实际就是一个@Configuration，表示启动类也是一个配置类<br>        ② @EnableAutoConfiguration：向 Spring 容器中导入了一个 Selector，用来加载 ClassPath 下 SpringFactories 中所定义的自动配置类，将这些自动加载为配置 Bean  <br>        ③ @ComponentScan，但这个注解是 Spring 提供的<br>2.  @Conditional 也很关键，如果没有它我们无法在自定义应用中进行定制开发<br>@ConditionalOnBean、 <br>@ConditionalOnClass、<br>@ConditionalOnExpression、<br>@ConditionalOnMissingBean 等。</p><h1 id="8-为什么-SpringBoot-的-jar-可以直接运行⭐️🔴"><a href="#8-为什么-SpringBoot-的-jar-可以直接运行⭐️🔴" class="headerlink" title="8. 为什么 SpringBoot 的 jar 可以直接运行⭐️🔴"></a>8. 为什么 SpringBoot 的 jar 可以直接运行⭐️🔴</h1><p><span style="display:none">%%<br>▶5.🏡⭐️◼️【fatjar, spring-boot-loader.jar, MANIFEST-MF, mainclass, jarlauncher, startclass】◼️⭐️-point-20230303-1616%%</span> ^lf3ecs</p><h2 id="8-1-spring-boot-maven-plugin-打-Fat-jar"><a href="#8-1-spring-boot-maven-plugin-打-Fat-jar" class="headerlink" title="8.1. spring-boot-maven-plugin 打 Fat jar"></a>8.1. spring-boot-maven-plugin 打 Fat jar</h2><p><span style="display:none">%%<br>▶5.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-0847%%</span>❕ ^s0yjgz</p><ol><li><p>SpringBoot 提供了一个插件 <code>spring-boot-maven-plugin</code> 用于把程序打包成一个可执行的 jar 包。</p></li><li><p>SpringBoot 应用打包之后，生成一个 Fat jar(jar 包中包含 jar)，包含了<span style="background-color:#ff00ff">应用依赖的 jar 包和 <code>Spring Boot loader</code> 相关的类</span>。❕<span style="display:none">%%<br>▶10.🏡⭐️◼️与自定义 starter 里的类 spring-boot-starter 类对比记忆◼️⭐️-point-20230302-1516%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133452.png" alt="image.png"></p></li></ol><p><span style="background-color:#ffff00">如果我们要看 spring-boot-loader 源码，那么就需要自己引入依赖</span><br>   <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133402.png" alt="image.png"></p><h2 id="8-2-MANIFEST-MF-文件"><a href="#8-2-MANIFEST-MF-文件" class="headerlink" title="8.2. MANIFEST.MF 文件"></a>8.2. MANIFEST.MF 文件</h2><ol start="3"><li>java -jar 会去找 jar 中的 <code>MANIFEST.MF</code> 文件，在那里面找到真正的启动类（<code>Main-Class</code>），Fat jar 的启动 Main 函数是 <code>JarLauncher</code>，在 <code>spring-boot-loader.jar</code> 中</li></ol><p>[[JVM源码分析之JVM启动流程_猿灯塔_InfoQ写作社区#^qwkqfc]]</p><p> <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224123155.png" alt="image.png"></p><p>在 JarLauncher 类中的 main 方法中有 <code>launch</code> 方法，进入之后有 2 个非常重要的方法： <code>createClassLoader</code> 和 <code>launch</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133833.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133951.png" alt="image.png"></p><h2 id="8-3-LaunchedURLClassLoader"><a href="#8-3-LaunchedURLClassLoader" class="headerlink" title="8.3. LaunchedURLClassLoader"></a>8.3. LaunchedURLClassLoader</h2><ol start="4"><li><code>createClassLoader</code> 负责创建一 <code>LaunchedURLClassLoader</code> 来<span style="background-color:#ff00ff">加载 BOOT-INF\lib 下面的 jar</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224132056.png" alt="image.png"></li></ol><p> <img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224123526.png" alt="image.png"></p><h2 id="8-4-launch"><a href="#8-4-launch" class="headerlink" title="8.4. launch"></a>8.4. launch</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224132303.png" alt="image.png"></p><p><span style="background-color:#ff00ff"><code>launch</code> 负责以一个新线程启动应用的启动类的 Main 函数（找到 manifest 中的 Start-Class）</span></p><h1 id="9-自定义-starter⭐️🔴"><a href="#9-自定义-starter⭐️🔴" class="headerlink" title="9. 自定义 starter⭐️🔴"></a>9. 自定义 starter⭐️🔴</h1><p><span style="display:none">%%<br>▶76.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230306-1507%%</span>📙❕ ^5tcs5g</p><p><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=70&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=70&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="9-1-使用场景⭐️🔴"><a href="#9-1-使用场景⭐️🔴" class="headerlink" title="9.1. 使用场景⭐️🔴"></a>9.1. 使用场景⭐️🔴</h2><p>在我们的日常开发工作中，经常会有一些独立于业务之外的配置模块，我们经常将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，只需要将其在 pom 中引用依赖即可，利用 SpringBoot 为我们完成自动装配即可。</p><p>常见的自定义 Starter 场景比如:</p><p>动态数据源<br>登录模块<br>基于 AOP 技术实现日志切面<br><span style="display:none">%%<br>▶4.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-0932%%</span>❕ ^xbsang</p><p><strong>场景一：简化多服务公用框架集成</strong>- 封装 swagger 配置<br>众所周知，springboot 或者其他第三方所提供的 starter，都是<span style="background-color:#00ff00">做框架集成，通过简化配置，提高开发效率</span>，所以我们自定义 starter 的第一个应用场景也是基于这个思路。那我们日常开发工作中，有哪些框架是多个服务共用的，并且 springboot 或者其他第三方暂未提供，或者嫌弃第三方写的太烂，想自己重新实现的，都可以通过编写自定义 starter 来简化工作。我们公司采用微服务架构，每个服务都会使用 swagger 来生成在线接口文档。<span style="background-color:#ffff00">未封装 swagger-starter 之前，那么在每个服务里边，都需要增加 swagger 的配置类</span>。而封装 swagger-starter 之后，可以省去这一步的操作，还可以通过增加自定义配置来实现一些自定义的功能。比如我们公司安全部门要求生产环境不能对外开放 swagger 接口文档地址，那么我们就可以添加一个 enabled 的参数来代表 swagger 是否启用，默认启用，在生产环境的配置中将 enabled 设为 false 即可达到这个目的。类似的额外功能还有很多，比如增加请求头等等，其他的读者自行发掘。<br>上面提到的是业务无关性的 starter 应用场景，那么我们抛出一个问题，是否有业务相关且多个业务场景或者多个服务会使用的应用场景？根据这个问题的描述，我们至少可以列出以下几个业务相关场景。  <a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/" title="服务治理-10、限流熔断降级(服务保护)-Sentinel">服务治理-10、限流熔断降级(服务保护)-Sentinel</a><br><strong>场景二：服务间调用的鉴权。</strong><br>我们<span style="background-color:#ff00ff">公司内部服务之间互相调用需要进行鉴权</span>（还是安全部门的要求），由于服务间是通过 feign 来实现相互调用，所以无法通过网关来进行统一鉴权。实现方案是通过新增 feign 拦截器，&#x3D;&#x3D;在源头服务发起调用之前增加鉴权参数，请求到达目标服务后通过鉴权参数进行鉴权&#x3D;&#x3D;。这两步操作很明显是每个服务都需要的，那么这种情况下，我们就可以把这两步操作封装成 starter，达到简化开发的目的。同时，我们还可以通过增加配置，实现更细粒度的调用权限控制，比如订单服务只能调用库存服务的查询商品库存接口，而无法调用更新商品库存的接口。<br><strong>场景三：邮件，短信，验证码功能。</strong><br>  这些功能，在某些公司可能会放在 common 包里，但是这样其实会导致 common 包的臃肿，因为并不是所有服务都会使用到。有些公司（还是我们公司）可能对邮件服务器的访问有严格权限控制的，而且权限开通流程比较繁复的，那么会考虑做成服务，部署在已经具有访问权限的主机上，减去重复申请权限工作。如果除去这些限制，那么将这些功能封装成 starter 还是挺不错的，<span style="background-color:#ff00ff">可以避免 common 包的臃肿</span></p><h2 id="9-2-操作步骤"><a href="#9-2-操作步骤" class="headerlink" title="9.2. 操作步骤"></a>9.2. 操作步骤</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225092241.png" alt="image.png"></p><h3 id="9-2-1-确定场景需要使用依赖"><a href="#9-2-1-确定场景需要使用依赖" class="headerlink" title="9.2.1. 确定场景需要使用依赖"></a>9.2.1. 确定场景需要使用依赖</h3><h3 id="9-2-2-使用注解编写自动配置"><a href="#9-2-2-使用注解编写自动配置" class="headerlink" title="9.2.2. 使用注解编写自动配置"></a>9.2.2. 使用注解编写自动配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//指定这个类是一个配置类</span><br><span class="hljs-meta">@ConditionalOnXXX</span> <span class="hljs-comment">//在指定条件下成立的情况下自动配置类生效</span><br><span class="hljs-meta">@AutoConfigureAfter</span> <span class="hljs-comment">//指定自动配置类的顺序</span><br><span class="hljs-meta">@Bean</span> <span class="hljs-comment">//给容器中添加组件</span><br><br><span class="hljs-meta">@ConfigurationProperties</span> <span class="hljs-comment">//结合相关xxxProperties类来绑定相关的配置</span><br><span class="hljs-meta">@EnableConfigurationProperties</span> <span class="hljs-comment">//让xxxProperties生效加到容器中</span><br><br>自动配置类要能加载<br>将需要启动就加载的自动配置类，配置在META-INF/spring.factories<br># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225100054.png" alt="image.png"></p><h3 id="9-2-3-编写-2-个模块"><a href="#9-2-3-编写-2-个模块" class="headerlink" title="9.2.3. 编写 2 个模块"></a>9.2.3. 编写 2 个模块</h3><p><span style="display:none">%%<br>▶12.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1118%%</span>❕ ^8m431i</p><ol><li><p>启动器空的 jar 只需要做依赖管理导入；比如 <code>xxx-spring-boot-starter</code>，使用方只需要引入这个启动器即可<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326085427.png" alt="image.png"></p></li><li><p>专门写一个自动配置模块；比如 <code>xxx-spring-boot-starter-autoconfigurer</code>，所有的依赖项都放在这个模块的 <code>META-INF/spring.factories</code> 中，key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code><br>  同时 pom 中需要添加基础依赖 <code>spring-boot-starter</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326085456.png" alt="image.png"></p></li><li><p>启动器依赖自动配置，别人只需要引入 starter<br>xxx-spring-boot-starter<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️如果自定义 starter 中用到了属性信息 ?🔜MSTM📝 可以编写一个属性类，使用注解@ConfigurationProperties，然后使用 setter 方法或者构造导入的方法关联到 Service 类上，在 Configurer 类里直接注入使用◼️⭐️-point-20230226-0812%%</span></p></li></ol><h2 id="9-3-与-common-包对比"><a href="#9-3-与-common-包对比" class="headerlink" title="9.3. 与 common 包对比"></a>9.3. 与 common 包对比</h2><ol><li>common 包不灵活，需要不需要的内容都在一个 common 包里，不需要的内容也随着 common 包引入到工程中</li><li>单个功能增加太多，common 包容易变的臃肿</li></ol><h2 id="9-4-示例代码"><a href="#9-4-示例代码" class="headerlink" title="9.4. 示例代码"></a>9.4. 示例代码</h2><p>[[SpringBoot-V1-入门简介#^u6byiq]]<br>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;springboot2&#x2F;boot-09-customer-starter&#x2F;atguigu-hello-spring-boot-starter-autoconfigure&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;atguigu&#x2F;hello&#x2F;auto&#x2F;HelloServiceAutoConfiguration.java]]</p><p>[[SpringBoot-V1-入门简介#8 1 新建一个 starter]]</p><h1 id="10-配置读取原理和优先级规则⭐️🔴"><a href="#10-配置读取原理和优先级规则⭐️🔴" class="headerlink" title="10. 配置读取原理和优先级规则⭐️🔴"></a>10. 配置读取原理和优先级规则⭐️🔴</h1><p><span style="display:none">%%<br>▶7.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230303-1851%%</span> ^uxezha</p><h2 id="10-1-读取原理"><a href="#10-1-读取原理" class="headerlink" title="10.1. 读取原理"></a>10.1. 读取原理</h2><p>通过事件监听的方式读取的配置文件：<code>ConfigFileApplicationListener</code><br>优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。<br><code>ConfigFileApplicationListener</code> 会监听 <code>onApplicationEnvironmentPreparedEvent</code> 事件来加载配置文件 <code>application.properties</code> 的环境变量<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225112751.png" alt="image.png"></p><h2 id="10-2-优先级规则"><a href="#10-2-优先级规则" class="headerlink" title="10.2. 优先级规则"></a>10.2. 优先级规则</h2><h3 id="10-2-1-文件优先级"><a href="#10-2-1-文件优先级" class="headerlink" title="10.2.1. 文件优先级"></a>10.2.1. 文件优先级</h3><h4 id="10-2-1-1-外部配置源"><a href="#10-2-1-1-外部配置源" class="headerlink" title="10.2.1.1. 外部配置源"></a>10.2.1.1. 外部配置源</h4><p>常用：properties 文件、YAML 文件、环境变量、命令行参数；</p><h4 id="10-2-1-2-properties-优于-ymal"><a href="#10-2-1-2-properties-优于-ymal" class="headerlink" title="10.2.1.2. properties 优于 ymal"></a>10.2.1.2. properties 优于 ymal</h4><p>正常的情况是先加载 yml，接下来加载 properties 文件。如果相同的配置存在于两个文件中。最后会使用 properties 中的配置。最后读取的优先级最高。</p><p>两个配置文件中的端口号不一样会读取 properties 中的端口号</p><h3 id="10-2-2-查找覆盖优先级"><a href="#10-2-2-查找覆盖优先级" class="headerlink" title="10.2.2. 查找覆盖优先级"></a>10.2.2. 查找覆盖优先级</h3><p>配置文件查找位置：<span style="background-color:#ff00ff">查找覆盖顺序：优先级逐级变高</span></p><pre><code>        1. classpath 根路径        2. classpath 根路径下 config 目录        3. jar 包当前目录        4. jar 包当前目录的 config 目录        5. /config 子目录的直接子目录</code></pre><h3 id="10-2-3-加载生效优先级"><a href="#10-2-3-加载生效优先级" class="headerlink" title="10.2.3. 加载生效优先级"></a>10.2.3. 加载生效优先级</h3><p>配置文件加载顺序：<span style="background-color:#ff00ff">加载顺序：外部&gt;内部、加 profile&gt;不加 profile</span></p><pre><code>        1.  当前 jar 包内部的 application.properties 和 application.yml    　2.  当前 jar 包内部的 application-&#123;profile&#125;.properties 和 application-&#123;profile&#125;.yml    　3. 引用的外部 jar 包的 application.properties 和 application.yml    　4. 引用的外部 jar 包的 application-&#123;profile&#125;.properties 和 application-&#123;profile&#125;.yml</code></pre><h3 id="10-2-4-官方文档"><a href="#10-2-4-官方文档" class="headerlink" title="10.2.4. 官方文档"></a>10.2.4. 官方文档</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225114206.png" alt="image.png"></p><p><span style="background-color:#ff00ff">指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</span></p><h3 id="10-2-5-案例"><a href="#10-2-5-案例" class="headerlink" title="10.2.5. 案例"></a>10.2.5. 案例</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225112420.png" alt="image.png"></p><h1 id="11-SpringBoot-的默认日志实现框架及切换"><a href="#11-SpringBoot-的默认日志实现框架及切换" class="headerlink" title="11. SpringBoot 的默认日志实现框架及切换"></a>11. SpringBoot 的默认日志实现框架及切换</h1><p><a href="https://www.bilibili.com/video/BV1mf4y1c7cV?p=82&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV?p=82&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=23&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=23&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225115626.png" alt="image.png"></p><h2 id="11-1-SpringBoot-日志框架"><a href="#11-1-SpringBoot-日志框架" class="headerlink" title="11.1. SpringBoot 日志框架"></a>11.1. SpringBoot 日志框架</h2><p>1. SpringBoot 底层使用 slf4j+logback 的方式进行日志记录<br>            logback 桥接：logback-classic<br>2. SpringBoot 同时也把其他的日志都替换成了 slf4j；<br>            a. log4j2 适配： log4j-over-slf4j   (默认提供了适配器，如果切换 log4j2 只需要更换场景启动器即可)<br>            b. jul 适配：jul-to-slf4j <br>            c. jcl 适配：jcl-over-slf4j<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326121315.png"></p><h2 id="11-2-将-logback-切换成-log4j2"><a href="#11-2-将-logback-切换成-log4j2" class="headerlink" title="11.2. 将 logback 切换成 log4j2"></a>11.2. 将 logback 切换成 log4j2</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326130656.png" alt="image.png"></p><p>1. 将 logback 的场景启动器排除（slf4j 只能运行有 1 个桥接器）<br>2. 添加 log4j2 的场景启动器<br>3. 添加 log4j2 的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 排除掉logback的依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 添加log4j2依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="11-3-将-logback-切换成-log4j"><a href="#11-3-将-logback-切换成-log4j" class="headerlink" title="11.3. 将 logback 切换成 log4j"></a>11.3. 将 logback 切换成 log4j</h2><p>1. 要将 logback 的桥接器排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2. 添加 log4j 的桥接器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j‐log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3. 添加 log4j 的配置文件</p><h1 id="12-容器"><a href="#12-容器" class="headerlink" title="12. 容器"></a>12. 容器</h1><p> 在 Web 环境中是由 Spring 和 SpringMvc 两个容器组成的，在 SpringBoot 环境中只有一个容器 AnnotationConfigEmbeddedWebApplicationContext。也就是可以说是由 SpringBoot 容器管理的。</p><h2 id="12-1-配置嵌入式-Servlet-容器"><a href="#12-1-配置嵌入式-Servlet-容器" class="headerlink" title="12.1. 配置嵌入式 Servlet 容器"></a>12.1. 配置嵌入式 Servlet 容器</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222080746.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222080710.png" alt="image.png"></p><h2 id="12-2-嵌入式-Servlet-容器自动配置原理-v1⭐️🔴"><a href="#12-2-嵌入式-Servlet-容器自动配置原理-v1⭐️🔴" class="headerlink" title="12.2. 嵌入式 Servlet 容器自动配置原理 v1⭐️🔴"></a>12.2. 嵌入式 Servlet 容器自动配置原理 v1⭐️🔴</h2><p><span style="display:none">%%<br>▶8.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230302-1057%%</span><br><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=48&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=48&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230223220427.png" alt="image.png"> ^17d8bq</p><h3 id="12-2-1-引入依赖触发自动配置"><a href="#12-2-1-引入依赖触发自动配置" class="headerlink" title="12.2.1. 引入依赖触发自动配置"></a>12.2.1. 引入依赖触发自动配置</h3><p> 当加入 <code>Spring-boot-starter-web</code> 场景启动器依赖时，<code>@ConditionalOnWebApplication</code> 注解会触发 EmbeddedServletContainerAutoConfiguration 自动配置类开启嵌入式 Servlet 容器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@Import(BeanPostProcessorsRegistrar.class)</span><br><span class="hljs-comment">//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedServletContainerAutoConfiguration</span> &#123;<br>    <span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)</span><span class="hljs-comment">//当前是否引入tomcat依赖</span><br>    <span class="hljs-comment">//判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedTomcat</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="hljs-title function_">tomcatEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TomcatEmbeddedServletContainerFactory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-2-创建默认的嵌入式容器-EmbeddedServletContainerFactory"><a href="#12-2-2-创建默认的嵌入式容器-EmbeddedServletContainerFactory" class="headerlink" title="12.2.2. 创建默认的嵌入式容器 -EmbeddedServletContainerFactory"></a>12.2.2. 创建默认的嵌入式容器 -EmbeddedServletContainerFactory</h3><p>如果当前容器没有用户自定义 EmbeddedServletContainerFactory，就会创建一个默认的 TomcatEmbeddedServletContainerFactory，用来创建嵌入式容器，默认为 Tomcat，也支持其他嵌入式容器，3 种工厂分别可以创建 3 种 EmbeddedServletContainer，继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222085416.jpg" alt="24.EmdServletFactory"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222085423.jpg" alt="25.EmdServletContainer"></p><p>以 TomcatEmbeddedServletContainerFactory 为例，<span style="background-color:#00ff00">new 了一个 Tomcat 出来</span>并配置，然后传入 <code>getTomcatEmbeddedServletContainer</code> 方法，在该方法中会启动 Tomcat。SpringBoot2 中该方法名字为 getWebServer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> EmbeddedServletContainer <span class="hljs-title function_">getEmbeddedServletContainer</span><span class="hljs-params">(</span><br><span class="hljs-params">      ServletContextInitializer... initializers)</span> &#123;<br>   <span class="hljs-type">Tomcat</span> <span class="hljs-variable">tomcat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tomcat</span>();<br>    <span class="hljs-comment">//配置tomcat的基本环节</span><br>   <span class="hljs-type">File</span> <span class="hljs-variable">baseDir</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.baseDirectory != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.baseDirectory<br>         : createTempDir(<span class="hljs-string">&quot;tomcat&quot;</span>));<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   <span class="hljs-type">Connector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connector</span>(<span class="hljs-built_in">this</span>.protocol);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(<span class="hljs-literal">false</span>);<br>   configureEngine(tomcat.getEngine());<br>   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-built_in">this</span>.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>    <span class="hljs-comment">//将配置好的tomcat传入进去；并且启动tomcat容器</span><br>   <span class="hljs-keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-3-嵌入式配置自动解析方式-EmbeddedServletContainerCustomizerBeanPostProcessor"><a href="#12-2-3-嵌入式配置自动解析方式-EmbeddedServletContainerCustomizerBeanPostProcessor" class="headerlink" title="12.2.3. 嵌入式配置自动解析方式 -EmbeddedServletContainerCustomizerBeanPostProcessor"></a>12.2.3. 嵌入式配置自动解析方式 -EmbeddedServletContainerCustomizerBeanPostProcessor</h3><p>有 2 种方式：ServerProperties、EmbeddedServletContainerCustomizer</p><p><strong>EmbeddedServletContainerCustomizer 自动应用 Servlet 容器配置原理</strong>：<br>是通过 <strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong> 来完成的</p><p>容器在配置类 <code>EmbeddedServletContainerAutoConfiguration</code> 中通过 <code>@Import(BeanPostProcessorsRegistrar.class)</code> 导入了 <strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong>，在 <code>postProcessBeforeInitialization</code> 方法中，判断如果当前初始化的是一个 ConfigurableEmbeddedServletContainer，就会获取所有的定制器，调用每个定制器的 customer 方法给 Servlet 容器进行赋值。</p><p><code>BeanPostProcessorsRegistrar.registerBeanDefinitions</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span><br><span class="hljs-params">      BeanDefinitionRegistry registry)</span> &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   registerSyntheticBeanIfMissing(registry,<br>         <span class="hljs-string">&quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;</span>,<br>         EmbeddedServletContainerCustomizerBeanPostProcessor.class);<br>   registerSyntheticBeanIfMissing(registry,<br>         <span class="hljs-string">&quot;errorPageRegistrarBeanPostProcessor&quot;</span>,<br>         ErrorPageRegistrarBeanPostProcessor.class);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>EmbeddedServletContainerCustomizerBeanPostProcessor.postProcessBeforeInitialization</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer</span><br>   <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;<br>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);<br>   &#125;<br>   <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(</span><br><span class="hljs-params">    ConfigurableEmbeddedServletContainer bean)</span> &#123;<br>    <span class="hljs-comment">//获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值</span><br>    <span class="hljs-keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;<br>        customizer.customize(bean);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="hljs-title function_">getCustomizers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.customizers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Look up does not include the parent context</span><br>        <span class="hljs-built_in">this</span>.customizers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;EmbeddedServletContainerCustomizer&gt;(<br>            <span class="hljs-built_in">this</span>.beanFactory<br>            <span class="hljs-comment">//从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer</span><br>            <span class="hljs-comment">//定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span><br>            .getBeansOfType(EmbeddedServletContainerCustomizer.class,<br>                            <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>            .values());<br>        Collections.sort(<span class="hljs-built_in">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);<br>        <span class="hljs-built_in">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-built_in">this</span>.customizers);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.customizers;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="background-color:#00ff00">而 ServerProperties 也是 EmbeddedServletContainerCustomizer 实现类，所以也会被自动配置</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222094902.png" alt="image.png"></p><h3 id="12-2-4-总结"><a href="#12-2-4-总结" class="headerlink" title="12.2.4. 总结"></a>12.2.4. 总结</h3><p>1）、SpringBoot 根据导入的依赖情况，给容器中添加响应的容器工厂比如 tomcat<br>对应的 <code>TomcatEmbeddedServletContainerFactory</code></p><p>2）、容器中某个组件要创建对象就要通过后置处理器；<br><code>EmbeddedServletContainerCustomizerBeanPostProcessor</code><br>只要是嵌入式的 Servlet 容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取的所有的 EmbeddedServletContainerCustomizer，调用定制器的定制方法</p><h2 id="12-3-定制化原理"><a href="#12-3-定制化原理" class="headerlink" title="12.3. 定制化原理"></a>12.3. 定制化原理</h2><ol><li>修改配置文件；</li><li>xxxxxCustomizer；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebServerFactoryCustomizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableServletWebServerFactory&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory server)</span> &#123;<br>        server.setPort(<span class="hljs-number">9000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>编写自定义的配置类 xxxConfiguration；+ @Bean 替换、增加容器中默认组件；视图解析器</li><li>Web 应用编写一个配置类实现 <code>WebMvcConfigurer</code> 即可定制化 web 功能；+ <code>@Bean</code> 给容器中再扩展一些组件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminWebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span><br></code></pre></td></tr></table></figure><ol start="5"><li>@EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管 SpringMVC，所有规则全部自己重新配置；实现定制和扩展功能<br>  ○ 原理<br>   ○ 1、WebMvcAutoConfiguration 默认的 SpringMVC 的自动配置功能类。静态资源、欢迎页…..<br>   ○ 2、一旦使用 @EnableWebMvc 会@Import(<code>DelegatingWebMvcConfiguration.class</code>)<br>   ○ 3、DelegatingWebMvcConfiguration 的作用，只保证 SpringMVC 最基本的使用<br> ■ 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效<br> ■ 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取<br> ■ public class DelegatingWebMvcConfiguration extends <code>WebMvcConfigurationSupport</code><br>   ○ 4、WebMvcAutoConfiguration 里面的配置要能生效必须  <span style="background-color:#ff00ff">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br>   ○ 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。</li></ol><h1 id="13-Java-Config"><a href="#13-Java-Config" class="headerlink" title="13. Java Config"></a>13. Java Config</h1><h2 id="13-1-Configuration-proxyBeanMethods-x3D-false"><a href="#13-1-Configuration-proxyBeanMethods-x3D-false" class="headerlink" title="13.1. @Configuration(proxyBeanMethods &#x3D; false)"></a>13.1. @Configuration(proxyBeanMethods &#x3D; false)</h2><p>lite 模式下，直接返回新实例对象，不用生成代理。</p><p>Spring 5.2.0+ 的版本，建议你的配置类均采用 Lite 模式去做，即显示设置 <code>proxyBeanMethods = false</code>。Spring Boot 在 2.2.0 版本（依赖于 Spring 5.2.0）起就把它的所有的自动配置类的此属性改为了 false，即@Configuration(proxyBeanMethods &#x3D; false)，目的是为了提高 Spring 启动速度</p><p><a href="https://blog.csdn.net/yunxing323/article/details/108655250">https://blog.csdn.net/yunxing323/article/details/108655250</a></p><h2 id="13-2-Import"><a href="#13-2-Import" class="headerlink" title="13.2. @Import"></a>13.2. @Import</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921204122547.png" alt="image-20210921204122547"></p><h1 id="14-Rest-原理"><a href="#14-Rest-原理" class="headerlink" title="14. Rest 原理"></a>14. Rest 原理</h1><h2 id="14-1-filter-wrapper"><a href="#14-1-filter-wrapper" class="headerlink" title="14.1. filter+wrapper"></a>14.1. filter+wrapper</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921060612553.png" alt="image-20210921060612553"><br>Rest 原理（表单提交要使用 REST 的时候）<br>● 表单提交会带上 <code>_method=PUT</code><br>● 请求过来被 <code>HiddenHttpMethodFilter</code> 拦截<br>  ○ 请求是否正常，并且是 POST<br>    ■ 获取到 _method 的值。<br>    ■ 兼容以下请求；<code>PUT、DELETE、PATCH</code><br>    ■ 原生 request（post），包装模式 <code>requesWrapper</code> 重写了 getMethod 方法，返回的是传入的值。<br>    ■ 过滤器链放行的时候用 wrapper。以后的方法调用 getMethod 是调用 requesWrapper 的。</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921060523227.png" alt="image-20210921060523227"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230324190828.png" alt="image.png"></p><p>Rest 使用客户端工具，<br>● 如 PostMan 直接发送 Put、delete 等方式请求，无需 Filter，但要注意方式可用取值为 <code>GET、PUT、DELETE、PATCH</code>。</p><h2 id="14-2-自定义隐藏域名称"><a href="#14-2-自定义隐藏域名称" class="headerlink" title="14.2. 自定义隐藏域名称"></a>14.2. 自定义隐藏域名称</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HiddenHttpMethodFilter <span class="hljs-title function_">hiddenHttpMethodFilter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HiddenHttpMethodFilter</span> <span class="hljs-variable">methodFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HiddenHttpMethodFilter</span>();<br>        methodFilter.setMethodParam(<span class="hljs-string">&quot;_m&quot;</span>);<br>        <span class="hljs-keyword">return</span> methodFilter;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="15-请求映射原理⭐️🔴"><a href="#15-请求映射原理⭐️🔴" class="headerlink" title="15. 请求映射原理⭐️🔴"></a>15. 请求映射原理⭐️🔴</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230410-0835%%</span>❕ ^ijjhr0</p><p><a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=139&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=139&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>DispatchServlet</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921061541902.png" alt="image-20210921061541902"></p><h2 id="15-1-请求路径"><a href="#15-1-请求路径" class="headerlink" title="15.1. 请求路径"></a>15.1. 请求路径</h2><p><code>HttpServlet.doGet</code> →  <code>FrameworkServlet.processRequest</code> → <code>FrameworkServlet.doService</code> → <code>DispatcherServlet.doService</code> → <code>DispatcherServlet.doDispatch</code> (每个请求都会调用这个方法)</p><h2 id="15-2-执行逻辑"><a href="#15-2-执行逻辑" class="headerlink" title="15.2. 执行逻辑"></a>15.2. 执行逻辑</h2><h3 id="15-2-1-handlerMappings"><a href="#15-2-1-handlerMappings" class="headerlink" title="15.2.1. handlerMappings"></a>15.2.1. handlerMappings</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011085954656.png" alt="image-20211011085954656"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011091433222.png" alt="image-20211011091433222"></p><p>● 请求进来，挨个尝试所有的 HandlerMapping 看是否有请求信息。<br>          ○ 如果有就找到这个请求对应的 handler<br>          ○ 如果没有就是下一个 HandlerMapping</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090131565.png" alt="image-20211011090131565"></p><h3 id="15-2-2-RequestMappingHeaderMapping"><a href="#15-2-2-RequestMappingHeaderMapping" class="headerlink" title="15.2.2. RequestMappingHeaderMapping"></a>15.2.2. RequestMappingHeaderMapping</h3><p>保存了所有@RequestMapping 和对应 handler 的所有映射关系</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090316527.png" alt="image-20211011090316527"></p><h3 id="15-2-3-获取-handler-逻辑"><a href="#15-2-3-获取-handler-逻辑" class="headerlink" title="15.2.3. 获取 handler 逻辑"></a>15.2.3. 获取 handler 逻辑</h3><h3 id="15-2-4-mappingRegistry"><a href="#15-2-4-mappingRegistry" class="headerlink" title="15.2.4. mappingRegistry"></a>15.2.4. mappingRegistry</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227103610.png" alt="image-20211011090316527"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090729432.png" alt="image-20211011090729432"></p><h1 id="16-其他"><a href="#16-其他" class="headerlink" title="16. 其他"></a>16. 其他</h1><h2 id="16-1-jar-包引入方式"><a href="#16-1-jar-包引入方式" class="headerlink" title="16.1. jar 包引入方式"></a>16.1. jar 包引入方式</h2><p><a href="https://cloud.tencent.com/developer/article/1500334">https://cloud.tencent.com/developer/article/1500334</a></p><h3 id="16-1-1-spring-boot-starter-parent"><a href="#16-1-1-spring-boot-starter-parent" class="headerlink" title="16.1.1. spring-boot-starter-parent"></a>16.1.1. spring-boot-starter-parent</h3><h3 id="16-1-2-spring-boot-dependencies"><a href="#16-1-2-spring-boot-dependencies" class="headerlink" title="16.1.2. spring-boot-dependencies"></a>16.1.2. spring-boot-dependencies</h3><p><a href="https://blog.csdn.net/haohao_g/article/details/99695535">https://blog.csdn.net/haohao_g/article/details/99695535</a></p><p><strong>使用场景</strong>：可能有自己的企业标准 parent</p><p>或者你可能只是比较喜欢明确声明所有的 Maven 配置</p><h2 id="16-2-多继承问题"><a href="#16-2-多继承问题" class="headerlink" title="16.2. 多继承问题"></a>16.2. 多继承问题</h2><p><a href="https://www.jianshu.com/p/7145f01ac3ad">https://www.jianshu.com/p/7145f01ac3ad</a></p><h2 id="16-3-dependencyManagement"><a href="#16-3-dependencyManagement" class="headerlink" title="16.3. dependencyManagement"></a>16.3. dependencyManagement</h2><p>dependencyManagement 节点的作用是统一 maven 引入依赖 JAR 包的版本号，可以看出 spring-boot-dependencies 最重要的一个作用就是对 springboot 可能用到的依赖 JAR 包做了版本号的控制管理</p><h1 id="17-与-Spring-的不同之处"><a href="#17-与-Spring-的不同之处" class="headerlink" title="17. 与 Spring 的不同之处"></a>17. 与 Spring 的不同之处</h1><h2 id="17-1-动态代理"><a href="#17-1-动态代理" class="headerlink" title="17.1. 动态代理"></a>17.1. 动态代理</h2><ol><li>Spring 是动态选择的，有接口就用 JDK 动态代理，否则使用 cglib 动态代理<br>可以通过 <code>exproxy-target-class</code><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/" title="1、Spring-基础">1、Spring-基础</a></li><li>SpringBoot 默认是 cglib 动态代理</li></ol><h2 id="17-2-SpringMVC-容器⭐️🔴"><a href="#17-2-SpringMVC-容器⭐️🔴" class="headerlink" title="17.2. SpringMVC 容器⭐️🔴"></a>17.2. SpringMVC 容器⭐️🔴</h2><ol><li>Spring 集成 SpringMVC 是通过 SPI 方式注册子容器来实现集成</li><li>SpringBoot 通过@Bean 注册了 DispatcherServlet，并没有像 Spring 集成 SpringMVC 中那样，通过 SPI 的方式创建子容器</li></ol><h1 id="18-参考与感谢"><a href="#18-参考与感谢" class="headerlink" title="18. 参考与感谢"></a>18. 参考与感谢</h1><h2 id="18-1-SpringBoot"><a href="#18-1-SpringBoot" class="headerlink" title="18.1. SpringBoot"></a>18.1. SpringBoot</h2><h3 id="18-1-1-视频"><a href="#18-1-1-视频" class="headerlink" title="18.1.1. 视频"></a>18.1.1. 视频</h3><p>01、P112–P198 为雷神 2021 版 springboot2 教程 &lt;– 建议直接看新版 02、2021 版直达链接: <a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4">https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4</a><br>&#x2F;Volumes&#x2F;Seagate Bas&#x2F;001-ArchitectureRoad&#x2F;尚硅谷 Springboot 经典版（核心技术 and 整合篇）&#x2F;核心技术篇&#x2F;视频 3&#x2F;视频 3 ^yfxc8z</p><h3 id="18-1-2-代码"><a href="#18-1-2-代码" class="headerlink" title="18.1.2. 代码"></a>18.1.2. 代码</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;SpringBoot</p><h3 id="18-1-3-笔记"><a href="#18-1-3-笔记" class="headerlink" title="18.1.3. 笔记"></a>18.1.3. 笔记</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;002- 框架源码专题&#x2F;000-Spring&#x2F;SpringBoot<br>[[SpringBoot]]</p><h2 id="18-2-SpringBoot2"><a href="#18-2-SpringBoot2" class="headerlink" title="18.2. SpringBoot2"></a>18.2. SpringBoot2</h2><h3 id="18-2-1-视频"><a href="#18-2-1-视频" class="headerlink" title="18.2.1. 视频"></a>18.2.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=58&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV19K4y1L7MT?p=58&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="18-2-2-笔记"><a href="#18-2-2-笔记" class="headerlink" title="18.2.2. 笔记"></a>18.2.2. 笔记</h3><p>语雀： <a href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></p><h3 id="18-2-3-代码"><a href="#18-2-3-代码" class="headerlink" title="18.2.3. 代码"></a>18.2.3. 代码</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;springboot2</p><h2 id="18-3-汇总"><a href="#18-3-汇总" class="headerlink" title="18.3. 汇总"></a>18.3. 汇总</h2><blockquote><p>01、P112–P198 为雷神 2021 版 springboot2 教程 &lt;– 建议直接看新版 02、2021 版直达链接: <a href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4">https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4</a></p></blockquote><hr><p>2021 版配套笔记及源码：<br>          配套源码 - 雷神码云地址： <a href="https://gitee.com/leifengyang/springboot2">https://gitee.com/leifengyang/springboot2</a><br>      配套笔记 - 语雀地址： <a href="https://yuque.com/atguigu/springboot">https://yuque.com/atguigu/springboot</a></p><hr><p>旧版配套源码、文档等：<br>尚硅谷 springboot 核心篇 + 整合篇配套资料<br>链接: <a href="https://pan.baidu.com/s/1Yfv05ncJoP_gOHB6cm9jdg">https://pan.baidu.com/s/1Yfv05ncJoP_gOHB6cm9jdg</a> 提取码: 9h5i</p><h2 id="18-4-其他"><a href="#18-4-其他" class="headerlink" title="18.4. 其他"></a>18.4. 其他</h2><p><a href="https://www.bilibili.com/video/BV1zh411H79h?p=4">https://www.bilibili.com/video/BV1zh411H79h?p=4</a></p><h2 id="18-5-Spring"><a href="#18-5-Spring" class="headerlink" title="18.5. Spring"></a>18.5. Spring</h2><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/" title="1、Spring-基础">1、Spring-基础</a><h2 id="18-6-黑马⭐️🔴✅"><a href="#18-6-黑马⭐️🔴✅" class="headerlink" title="18.6. 黑马⭐️🔴✅"></a>18.6. 黑马⭐️🔴✅</h2><h3 id="18-6-1-视频"><a href="#18-6-1-视频" class="headerlink" title="18.6.1. 视频"></a>18.6.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=169&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y1a7yG?p=169&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="18-6-2-资料"><a href="#18-6-2-资料" class="headerlink" title="18.6.2. 资料"></a>18.6.2. 资料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">000</span>-Spring/SpringBoot/原理篇-资料<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-SpringBoot-的特性&quot;&gt;&lt;a href=&quot;#1-SpringBoot-的特性&quot; class=&quot;headerlink&quot; title=&quot;1. SpringBoot 的特性&quot;&gt;&lt;/a&gt;1. SpringBoot 的特性&lt;/h1&gt;&lt;p&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>1、Spring-基础</title>
    <link href="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/"/>
    <id>https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.915Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Spring-基本概念"><a href="#1-Spring-基本概念" class="headerlink" title="1. Spring 基本概念"></a>1. Spring 基本概念</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131132514.png" alt="image.png"></p><p><strong>POJO</strong>: 基于 POJO 的轻量级和最小侵入性编程；<br><strong>DI</strong>: 通过依赖注入和面向接口实现松耦合；<br><strong>AOP</strong>: 基于切面和惯例进行声明式编程；<br><strong>Template</strong>: 通过切面和模板减少样板式代码。</p><blockquote><p>比如我们要写 JDBC 这种牵扯到大量样板式的代码。我们其实只关注我们的 sql 语句（也就是它要实现什么功能），我们可不想看到他是如何连接的。等我们写好核心之后再去用切面进行连接，断开等。</p></blockquote><h2 id="1-1-POJO"><a href="#1-1-POJO" class="headerlink" title="1.1. POJO"></a>1.1. POJO</h2><a href="/2022/11/11/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-0%E3%80%81Java%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="基本原理-0、Java相关名词">基本原理-0、Java相关名词</a><p>POJO 的全称是 Plain Old Java Object，简单又老的 Java 对象。这里的简单是相对来讲的。 EJB 2. x 的 Entity Beans 比较重量，需要实现 <code>javax.ejb</code> 的一些接口。而 POJO 就比较轻量，就是一个 Java 对象，不需要实现任何的接口。POJO 专指只有 private 属性以及 setter&#x2F;getter&#x2F;toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</p><p>所以 POJO 本质上也是可以方便沟通的术语。</p><p>有了 POJO 这个名字，相比框架里面各种的对象概念，就容易理解多了，所以这个概念被很广地使用开来。可以用 POJO 来解释 JavaBean 这个惯例 (约定): <span style="background-color:#00ff00">JavaBean 就是可以序列化的 POJO，并且有无参构造器，可以使用 getter&#x2F;setter 来读写属性。</span>❕<span style="display:none">%%<br>0737-🏡⭐️◼️POJO 是一个约定，约定为只有 private 属性以及 getter、setter、toString 方法的简单的类，相对于 EJB 的 Entity Beans 是简单轻量的。也是领域模型中 DO,DTO,VO,BO 的统称。慢慢变成一种术语，可以用来解释 JavaBeans 这个约定，就是序列化且有无参构造的 POJO◼️⭐️-point-202302020737%%</span></p><p>Spring 的非侵入编程模型意味着使用 POJO 这种类在 Spring 应用和非 Spring 应用中都可以发挥同样的作用。</p><h2 id="1-2-约定-惯例"><a href="#1-2-约定-惯例" class="headerlink" title="1.2. 约定 (惯例)"></a>1.2. 约定 (惯例)</h2><p><span style="background-color:#ff00ff">约定优于配置</span><br>convention over configuration</p><h2 id="1-3-依赖注入和面向接口"><a href="#1-3-依赖注入和面向接口" class="headerlink" title="1.3. 依赖注入和面向接口"></a>1.3. 依赖注入和面向接口</h2><p>就是使用聚合 + 构造导入 (或者 setter 导入) 的方式扩展<br>设计模式中大量使用这种方式</p><h2 id="1-4-Spring-的核心"><a href="#1-4-Spring-的核心" class="headerlink" title="1.4. Spring 的核心"></a>1.4. Spring 的核心</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131135415.png" alt="image.png"><br>❕<span style="display:none">%%<br>0709-🏡⭐️◼️Spring 通过 IOC 实现依赖反转，由容器创建管理 Javabean 并维护 Javabean 之间清晰松散的耦合关系，解放程序员的精力放在业务逻辑编码上，同时通过 AOP 实现面向接口编程，可以无侵入的增强业务功能，进一步减少对业务代码的侵入性◼️⭐️-point-202302010709%%</span></p><h2 id="1-5-Spring-的优缺点"><a href="#1-5-Spring-的优缺点" class="headerlink" title="1.5. Spring 的优缺点"></a>1.5. Spring 的优缺点</h2><h3 id="1-5-1-优点"><a href="#1-5-1-优点" class="headerlink" title="1.5.1. 优点"></a>1.5.1. 优点</h3><ol><li><p><strong>方便解耦，简化开发</strong><br>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p></li><li><p><strong>AOP 编程的支持</strong><br>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p></li><li><p><strong>声明式事务的支持</strong><br>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p></li><li><p><strong>方便程序的测试</strong><br>Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序。</p></li><li><p><strong>方便集成各种优秀框架</strong><br>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。</p></li><li><p><strong>降低 JavaEE API 的使用难度</strong><br>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。</p></li><li><p><strong>Java 源码是经典学习范例</strong><br>Spring 的源码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。Spring 框架源码无疑是 Java 技术的最佳实践范例。</p></li></ol><h3 id="1-5-2-缺点"><a href="#1-5-2-缺点" class="headerlink" title="1.5.2. 缺点"></a>1.5.2. 缺点</h3><ol><li>Spring 明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring 依赖反射，反射影响性能</li><li>使用门槛升高，入门 Spring 需要较长时间</li></ol><h2 id="1-6-Spring-的核心模块"><a href="#1-6-Spring-的核心模块" class="headerlink" title="1.6. Spring 的核心模块"></a>1.6. Spring 的核心模块</h2><p>^ob40ki<br>^hasxle<br>大约 20 几个模块，总共 1300 多个文件，这些组件被分别整合在：核心容器、AOP、Aspect、Instrumentation、Messing、DataAccess、Web、Test 等几大模块中<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131144911.png" alt="image.png"></p><ol><li>spring core：提供了框架的基本组成部分，<span style="background-color:#00ff00">包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能</span>。</li><li>spring beans：提供了 BeanFactory，是<span style="background-color:#00ff00">工厂模式的一个经典实现</span>，Spring 将管理对象称为 Bean。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring jdbc：提供了一个 JDBC 的抽象层，消除了烦琐的 JDBC 编码和数据库厂商特有的错误代码解析， 用于简化 JDBC。</li><li>spring aop：提供了面向切面的编程实现，让你可以<span style="background-color:#00ff00">自定义拦截器、切点等</span>。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring test：主要为测试提供支持的，支持使用 JUnit 或 TestNG 对 Spring 组件进行单元测试和集成测试。</li></ol><h1 id="2-IOC-相关"><a href="#2-IOC-相关" class="headerlink" title="2. IOC 相关"></a>2. IOC 相关</h1><h2 id="2-1-什么是-IOC-容器"><a href="#2-1-什么是-IOC-容器" class="headerlink" title="2.1. 什么是 IOC 容器"></a>2.1. 什么是 IOC 容器</h2><p>控制反转即 IOC (Inversion of Control)，它把传统上<span style="background-color:#00ff00">由程序代码</span>直接操控的对象的调用权交给容器，<span style="background-color:#00ff00">通过容器来实现对象组件的装配和管理</span>。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。<br><span style="background-color:#00ff00">Spring IOC 负责创建对象，管理对象（通过依赖注入（DI）），装配对象，配置对象，并且管理这些对象的整个生命周期。</span></p><h2 id="2-2-IOC-的作用和意义"><a href="#2-2-IOC-的作用和意义" class="headerlink" title="2.2. IOC 的作用和意义"></a>2.2. IOC 的作用和意义</h2><p><strong>作用</strong></p><ol><li>管理对象的创建和依赖关系的维护</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的生成过程，比如我们无需去关心类是如何完成代理的</li></ol><blockquote><p> 控制反转    控制了什么？<br>UserService service&#x3D;new UserService();   &#x2F;&#x2F; 耦合度太高 、维护不方便<br>引入 Ioc   就将创建对象的控制权交给 Spring 的 Ioc.   以前由程序员自己控制对象创建， 现在交给 Spring 的 Ioc 去创建， <br>如果要去使用对象需要通过 DI（依赖注入）@Autowired 自动注入 就可以使用对象 ;</p></blockquote><p><strong>意义</strong><br><span style="background-color:#00ff00">1. IOC 容器以最小的代价和最小的侵入性使松散耦合得以实现。</span><br><span style="background-color:#00ff00">2. IOC 容器支持加载服务时的饿汉式初始化和懒加载。</span><br>❕<span style="display:none">%%<br>▶10.🏡⭐️◼️IOC 容器的意义◼️⭐️-point-20230226-2231%%</span></p><h2 id="2-3-IOC-的实现机制"><a href="#2-3-IOC-的实现机制" class="headerlink" title="2.3. IOC 的实现机制"></a>2.3. IOC 的实现机制</h2><p>工厂模式 + 反射</p><h2 id="2-4-什么是-Spring-的依赖注入-DI-？IOC-和-DI-的区别是什么"><a href="#2-4-什么是-Spring-的依赖注入-DI-？IOC-和-DI-的区别是什么" class="headerlink" title="2.4. 什么是 Spring 的依赖注入 (DI)？IOC 和 DI 的区别是什么"></a>2.4. 什么是 Spring 的依赖注入 (DI)？IOC 和 DI 的区别是什么</h2><p>很多人把 IOC 和 DI 说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的，希望大家能够严谨一点，IOC 和 DI 是从不同的角度描述的同一件事，<span style="background-color:#00ff00">IOC 是从容器的角度描述，而 DI 是从应用程序的角度来描述，也可以这样说，IOC 是依赖倒置原则的设计思想，而 DI 是具体的实现方式</span></p><h2 id="2-5-BeanDefinition-的作用"><a href="#2-5-BeanDefinition-的作用" class="headerlink" title="2.5. BeanDefinition 的作用"></a>2.5. BeanDefinition 的作用</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131200612.png" alt="image.png"></p><p>它主要负责存储 Bean 的定义信息，包括 beanClass、scope、lazyInit、dependsOn、autowireMode 等信息，决定 Bean 的生产方式。后续 BeanFactory 根据这些信息就行生产 Bean： 比如实例化 ，通过 class 进行反射进而得到实例对象 ， 比如 lazy  则不会在 ioc 加载时创建 Bean。</p><p>举例：由 BeanDefinition 中 Object 类型的 beanClass 强转为 String，然后通过反射得到 Class 对象<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131201517.png" alt="image.png"></p><h2 id="2-6-BeanFactory-和-ApplicationContext-有什么区别"><a href="#2-6-BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="2.6. BeanFactory 和 ApplicationContext 有什么区别"></a>2.6. BeanFactory 和 ApplicationContext 有什么区别</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131120831.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131120859.png" alt="image.png"></p><h3 id="2-6-1-答案-2"><a href="#2-6-1-答案-2" class="headerlink" title="2.6.1. 答案 2"></a>2.6.1. 答案 2</h3><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p><h4 id="2-6-1-1-功能大小"><a href="#2-6-1-1-功能大小" class="headerlink" title="2.6.1.1. 功能大小"></a>2.6.1.1. 功能大小</h4><ol><li>BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。</li><li>ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，<span style="background-color:#00ff00">还提供了更完整的框架功能</span>：<blockquote><p>继承 MessageSource，因此支持国际化。<br>统一的资源文件访问方式。<br>提供在监听器中注册 bean 的事件。<br>同时加载多个配置文件。<br>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。</p></blockquote></li></ol><p>资源文件访问方式： <a href="https://www.cnblogs.com/kongbubihai/p/15915434.html">https://www.cnblogs.com/kongbubihai/p/15915434.html</a></p><h4 id="2-6-1-2-加载方式"><a href="#2-6-1-2-加载方式" class="headerlink" title="2.6.1.2. 加载方式"></a>2.6.1.2. 加载方式</h4><ol><li>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，<span style="background-color:#ff00ff">即只有在使用到某个 Bean 时 (调用 getBean())，才对该 Bean 进行加载实例化</span>。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调 getBean 方法才会抛出异常。</li><li>ApplicationContext，它是<span style="background-color:#ff00ff">在容器启动时，一次性创建了所有的 Bean</span>。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ，确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131212230.png" alt="image.png"></p><p>下面的 3 个绿色的，都是功能扩展接口。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：<span style="background-color:#00ff00">支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）</span>。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><h2 id="2-7-BeanFactory-和-FactoryBean-有什么区别"><a href="#2-7-BeanFactory-和-FactoryBean-有什么区别" class="headerlink" title="2.7. BeanFactory 和 FactoryBean 有什么区别"></a>2.7. BeanFactory 和 FactoryBean 有什么区别</h2><ol><li>BeanFactory 是一个工厂，也就是一个容器，是来管理和生产 bean 的；</li><li>Spring 中有两种类型的 bean，一种是普通 bean，另一种是工厂 bean，即 FactoryBean。工厂 bean 跟普通 bean 不同，其返回的对象不是指定类的一个实例，其返回的是该工厂 bean 的 <code>getObject</code> 方法所返回的对象。工厂 bean 必须实现 <code>org.springframework.beans.factory.FactoryBean</code> 接口。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131210539.png" alt="image.png"></p><h2 id="2-8-有哪些不同类型的依赖注入实现方式"><a href="#2-8-有哪些不同类型的依赖注入实现方式" class="headerlink" title="2.8. 有哪些不同类型的依赖注入实现方式"></a>2.8. 有哪些不同类型的依赖注入实现方式</h2><p>依赖注入是时下最流行的 IOC 实现方式，依赖注入分为接口注入（Interface Injection），Setter 方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。<span style="background-color:#ff0000">其中接口注入由于在灵活性和易用性比较差，现在从 Spring4 开始已被废弃。</span><br><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br><strong>Setter 方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131214444.png" alt="image.png"></p><p>最佳实践<br>两种依赖方式都可以使用，构造器注入和 Setter 方法注入。<span style="background-color:#ff00ff">最好的解决方案是用构造器参数实现强制依赖，即组合的方式；setter 方法实现可选依赖，即聚合的方式。</span></p><h2 id="2-9-Spring-中配置-注册-Bean-的方式⭐️🔴"><a href="#2-9-Spring-中配置-注册-Bean-的方式⭐️🔴" class="headerlink" title="2.9. Spring 中配置 (注册)Bean 的方式⭐️🔴"></a>2.9. Spring 中配置 (注册)Bean 的方式⭐️🔴</h2><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><h2 id="2-10-BeanDefinition-的加载过程"><a href="#2-10-BeanDefinition-的加载过程" class="headerlink" title="2.10. BeanDefinition 的加载过程"></a>2.10. BeanDefinition 的加载过程</h2><h1 id="3-生命周期相关"><a href="#3-生命周期相关" class="headerlink" title="3. 生命周期相关"></a>3. 生命周期相关</h1><h2 id="3-1-Spring-框架中-bean-的生命周期⭐️🔴⭐️🔴"><a href="#3-1-Spring-框架中-bean-的生命周期⭐️🔴⭐️🔴" class="headerlink" title="3.1. Spring 框架中 bean 的生命周期⭐️🔴⭐️🔴"></a>3.1. Spring 框架中 bean 的生命周期⭐️🔴⭐️🔴</h2><p>^fkjjz0</p><h3 id="3-1-1-BD-相关"><a href="#3-1-1-BD-相关" class="headerlink" title="3.1.1. BD 相关"></a>3.1.1. BD 相关</h3><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><h3 id="3-1-2-整体流程"><a href="#3-1-2-整体流程" class="headerlink" title="3.1.2. 整体流程"></a>3.1.2. 整体流程</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131224135.png" alt="image.png"></p><ol><li>Spring 对 bean 进行实例化；</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中；</li><li>如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给 setBean-Name() 方法；</li><li>如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，BeanFactory 容器实例传入；</li><li>如果 bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization() 方法；</li><li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 after-PropertiesSet() 方法。类似地，如果 bean 使用 initmethod 声明了初始化方法，该方法也会被调用；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 post-ProcessAfterInitialization() 方法；</li></ol><p>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；<br>如果 bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy() 接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用。</p><h3 id="3-1-3-后置处理器相关⭐️🔴⭐️🔴"><a href="#3-1-3-后置处理器相关⭐️🔴⭐️🔴" class="headerlink" title="3.1.3. 后置处理器相关⭐️🔴⭐️🔴"></a>3.1.3. 后置处理器相关⭐️🔴⭐️🔴</h3><p>^n9drb6<br><span style="display:none">%%<br>▶10.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230321-2309%%</span>❕ ^jyw4v5</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230206174637.png" alt="image.png"><br>❕<span style="display:none">%%<br>1056-🏡⭐️◼️记忆方式 ?🔜MSTM📝 AutowiredAnnotationBPP&#x2F;CommonAnnotationBPP&#x3D;MI; AbstractAutoproxyCreator&#x3D;SB◼️⭐️-point-202302081056%%</span></p><ol><li><p>&#x3D;&#x3D;doCreateBean 之前&#x3D;&#x3D;，<code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation()</code><br> ①可以提前返回一个代理对象，而终止 bean 的创建给 BeanPostProcessors 一个机会来返回代理来替代真正的实例，应用实例化前的前置处理器，用户自定义动态代理的方式，针对于当前的被代理类需要经过标准的代理流程来创建对象。如果使用该扩展点，可以直接返回代理对象。<br> ② <a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></p></li><li><p>&#x3D;&#x3D;在实例化之前&#x3D;&#x3D;，即 <code>createBeanInstance</code> 之前还可以利用 <code>SmartInstantiationAwareBeanPostProcessor</code> 的 <code>determineCandidateConstructors</code> 方法来指定构造函数</p><hr></li><li><p>①在<span style="background-color:#00ff00">实例化之后属性赋值之前</span>，在 <code>MergedBeanDefinitionPostProcessor</code> 的子实现接口 <code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessMergedBeanDefinition</code> 方法中，解析@Autowired @Value 转换为 InjectionMetadata 并缓存在 <code>injectionMetadataCache</code> 中</p></li></ol> <a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a><p>  注意：<span style="background-color:#ff00ff">@Lazy 是 BD 属性，不是 Bean 属性，所以没有预解析的逻辑，只有 BeanDefinition 的解析逻辑，在第 5 大步中，不在 9 大后置处理器中。</span><br>  <a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a></p><p>②在<span style="background-color:#00ff00">实例化之后属性赋值之前</span>，在 <code>MergedBeanDefinitionPostProcessor</code> 的子实现接口 <code>InitDestroyAnnotationBeanPostProcessor</code> 的子类 <code>CommonAnnotationBeanPostProcessor</code> 的 <code>postProcessMergedBeanDefinition</code> 方法中，处理@PostConstruct 和@PreDestroy 注解，调用父类 <code>InitDestroyAnnotationBeanPostProcessor</code> 的 <code>findLifecycleMetadata</code> 方法构建 lifecycleMetadata 并缓存在 <code>lifecycleMetadataCache</code> 中<br>   <a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a></p><ol start="4"><li><p>在<span style="background-color:#00ff00">实例化之后属性赋值之前</span>，将 <code>SmartInstantiationAwareBeanPostProcessor</code> 的子实现接口 <code>AbstractAutoProxyCreator</code> 的 <code>getEarlyBeanReference</code> 方法作为钩子函数放入三级缓存，待到依赖方真正赋值时，调用 <code>singletonFactory.getObject()</code> 就会返回被依赖方的动态代理对象，从而解决了 AOP 的循环依赖问题 ❕<span style="display:none">%%<br>1925-🏡⭐️◼️AbstractAutoProxyCreator 的作用原理 ?🔜MSTM📝 实例化之后属性赋值之前，将 AbstractAutoProxyCreator 的 getEarlyReferenceBean 方法作为钩子函数放入三级缓存，在依赖方属性填充时会获取到三级缓存并执行 singletonFactory. getObject，届时会调用 getEarlyReferenceBean，如果有 aop 的 BPP，就会返回一个动态代理对象◼️⭐️-point-202302051925%%</span></p><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/" title="Spring-2、IOC">Spring-2、IOC</a></li><li><p>在 <code>applyPropertyValues</code> <span style="background-color:#00ff00">真正赋值之前</span>，与 1 相同的，<code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessAfterInstantiation</code>，如果实现改接口重写该方法，可以跳过属性赋值的步骤</p></li><li><p>在 <code>applyPropertyValues</code> <span style="background-color:#00ff00">真正赋值之前</span>，与 3-①相对应的，<code>InstantiationAwareBeanPostProcessor</code> 的子实现接口 <code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessProperties</code> 方法中完成 bean 中@Autowired，@Inject，@Value 注解的解析并注入<br><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a></p><a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a>  @Lazy 的赋值是在这里</li></ol><hr><ol start="7"><li>在 <code>invokeInitMethods</code> <span style="background-color:#ff00ff">初始化之前</span>，与 3-②相对应的，BeanPostProcessor 的子类 <code>InitDestroyAnnotationBeanPostProcessor</code> 会调用 <code>postProcessBeforeInitialization</code> 方法，此时 <code>@PostConstruct</code> 注解的方法会被调用。确切的说应该是在 <code>afterPropertiesSet</code> 之前调用，这与 xml 方式配置的方式不同，后者是在 <code>afterPropertiesSet</code> 之后，执行 <code>invokeInitMethods</code> 之前调用<a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a></li></ol><hr><ol start="8"><li>在<span style="background-color:#ff0000">初始化完成之后</span>，如果有用到，则会调用 <code>BeanPostProcessor</code> 的子实现类 <code>AbstractAutoProxyCreator</code> 的 <code>postProcessAfterInitialization()</code> 方法来生成动态代理</li></ol><p>❕<span style="display:none">%%<br>0720-🏡⭐️◼️解析切面的地方 ?🔜MSTM📝 第一个 PP，InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 中，解析切面并缓存所有通知到 advisorsCache 中◼️⭐️-point-202302120720%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230303112858.png"></p><h3 id="3-1-4-生命周期回调相关"><a href="#3-1-4-生命周期回调相关" class="headerlink" title="3.1.4. 生命周期回调相关"></a>3.1.4. 生命周期回调相关</h3><h4 id="3-1-4-1-初始化之前执行的生命周期的回调"><a href="#3-1-4-1-初始化之前执行的生命周期的回调" class="headerlink" title="3.1.4.1. 初始化之前执行的生命周期的回调"></a>3.1.4.1. 初始化之前执行的生命周期的回调</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230205210842.png" alt="image.png"></p><p><span style="background-color:#ff00ff">真正初始化之前执行的生命周期回调</span>  ❕<span style="display:none">%%<br>2116-🏡⭐️◼️扩展点 7 中的 3 个都在哪里 ?🔜MSTM📝 ApplicationContextAwareBPP、ImportAwareBPP、InitDestoryAnnotationBPP 都是在真正初始方法执行之前执行◼️⭐️-point-202302052116%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230201134805.png" alt="image.png"><br>❕<span style="display:none">%%<br>2237-🏡⭐️◼️invokeAwareMethods 方法有个重要点 ?🔜MSTM📝 就是对于实现 BeanFactoryAware 接口的 BPP，会设置 BeanFactory，在这个地方，AOP 设置了重要的属性 advisorRetrievalHelper、aspectJAdvisorsBuilder、aspectJAdvisorFactory，用于在后面实例化之前解析切面缓存通知◼️⭐️-point-20230216-2237%%</span></p><h4 id="3-1-4-2-初始化之后的生命周期的回调"><a href="#3-1-4-2-初始化之后的生命周期的回调" class="headerlink" title="3.1.4.2. 初始化之后的生命周期的回调"></a>3.1.4.2. 初始化之后的生命周期的回调</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230201134931.png" alt="image.png"></p><h2 id="3-2-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#3-2-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="3.2. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>3.2. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h2><h3 id="3-2-1-XML"><a href="#3-2-1-XML" class="headerlink" title="3.2.1. XML"></a>3.2.1. XML</h3><p>在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用 autowire 来配置自动装载模式。<br>在 Spring 框架 xml 配置中共有 5 种自动装配：</p><ol><li>no：<span style="background-color:#ffff00">默认的方式是不进行自动装配的</span>，通过手工设置 ref 属性来进行装配 bean。</li><li>byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。</li></ol><h3 id="3-2-2-注解"><a href="#3-2-2-注解" class="headerlink" title="3.2.2. 注解"></a>3.2.2. 注解</h3><h4 id="3-2-2-1-Autowired-与-Qualifier"><a href="#3-2-2-1-Autowired-与-Qualifier" class="headerlink" title="3.2.2.1. @Autowired 与@Qualifier"></a>3.2.2.1. @Autowired 与@Qualifier</h4><ol><li>@Autowired 是<span style="background-color:#ff0000">根据类型自动装配</span>的，加上@Qualifier 则可以根据 byName 的方式自动装配。</li><li>@Qualifier 不能单独使用。</li></ol><h4 id="3-2-2-2-Autowired-与-Resource-异同"><a href="#3-2-2-2-Autowired-与-Resource-异同" class="headerlink" title="3.2.2.2. @Autowired 与@Resource 异同"></a>3.2.2.2. @Autowired 与@Resource 异同</h4><ol><li>@Autowired 与@Resource 都可以用来装配 bean。都可以写在字段上，或写在 setter 方法上。</li><li><span style="background-color:#ff00ff">@Autowired 默认按类型装配</span>（属于 Spring 规范），默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false，如：@Autowired(required&#x3D;false)。<span style="background-color:#ff00ff">如果我们想使用名称装配可以结合@Qualifier 注解进行使用</span></li><li>@Resource（属于 J2EE 复返），<span style="background-color:#ff00ff">默认按照名称进行装配</span>，名称可以通过 name 属性进行指定。如果没有指定 name 属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter 方法上默认取属性名进行装配。<span style="background-color:#00ff00">当找不到与名称匹配的 bean 时才按照类型进行装配</span>。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。</li><li>它们的作用相同都是用注解方式注入对象，但执行顺序不同。<span style="background-color:#ff00ff">@Autowired 先 byType，@Resource 先 byName。</span></li></ol><p>PS: Autowired 根据类型装配的原因：<br>!<a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a></p><p><a href="https://blog.csdn.net/King_weng/article/details/122057561">https://blog.csdn.net/King_weng/article/details/122057561</a></p><h2 id="3-3-哪些是重要的-bean-生命周期方法-能否重载"><a href="#3-3-哪些是重要的-bean-生命周期方法-能否重载" class="headerlink" title="3.3. 哪些是重要的 bean 生命周期方法 能否重载"></a>3.3. 哪些是重要的 bean 生命周期方法 能否重载</h2><p>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</p><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><h2 id="3-4-使用-Autowired-注解自动装配的过程是怎样的⭐️🔴"><a href="#3-4-使用-Autowired-注解自动装配的过程是怎样的⭐️🔴" class="headerlink" title="3.4. 使用@Autowired 注解自动装配的过程是怎样的⭐️🔴"></a>3.4. 使用@Autowired 注解自动装配的过程是怎样的⭐️🔴</h2><p>^ov9bn5</p><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a><h2 id="3-5-PostConstruct-原理⭐️🔴⭐️🔴"><a href="#3-5-PostConstruct-原理⭐️🔴⭐️🔴" class="headerlink" title="3.5. @PostConstruct 原理⭐️🔴⭐️🔴"></a>3.5. @PostConstruct 原理⭐️🔴⭐️🔴</h2><p>^ry6di8</p><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a><h2 id="3-6-如何在-Spring-创建完所有-bean-之后做扩展"><a href="#3-6-如何在-Spring-创建完所有-bean-之后做扩展" class="headerlink" title="3.6. 如何在 Spring 创建完所有 bean 之后做扩展"></a>3.6. 如何在 Spring 创建完所有 bean 之后做扩展</h2><h3 id="3-6-1-基于-SmartInitializingSingleton-接口"><a href="#3-6-1-基于-SmartInitializingSingleton-接口" class="headerlink" title="3.6.1. 基于 SmartInitializingSingleton 接口"></a>3.6.1. 基于 SmartInitializingSingleton 接口</h3><p>在创建所有单例 Bean 的方法中： </p><p>1 finishBeanFactoryInitialization(beanFactory);<br>SmartInitializingSingleton 接口是在所有的 Bean 实例化完成以后，Spring 回调的方法, <br>所以这里也是一个扩展点，可以在单例 bean 全部完成实例化以后做处理。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202161432.png" alt="image.png"></p><h3 id="3-6-2-基于-Spring-事件监听"><a href="#3-6-2-基于-Spring-事件监听" class="headerlink" title="3.6.2. 基于 Spring 事件监听"></a>3.6.2. 基于 Spring 事件监听</h3><p>生命周期的最后一步是 finishRefresh();，这里面中有一个方法是 publishEvent<br>所以这里也可以进行扩展，监听 ContextRefreshedEvent 事件 。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202161549.png" alt="image.png"></p><h2 id="3-7-Spring-容器启动时，为什么先加载-BeanFactoryPostProcess"><a href="#3-7-Spring-容器启动时，为什么先加载-BeanFactoryPostProcess" class="headerlink" title="3.7. Spring 容器启动时，为什么先加载 BeanFactoryPostProcess"></a>3.7. Spring 容器启动时，为什么先加载 BeanFactoryPostProcess</h2><ol><li>因为 BeanDefinition 会在 ioc 容器加载的先注册， 而 BeanFactoryPostProcess 就是在所有的 BeanDefinition 注册完后做扩展的，所以要先加载 BeanFactoryPostProcess</li><li>解析配置类的组件  它就实现 BeanFactoryPostProcess， 所以要先去加载 BeanFactoryPostProcess</li></ol><h1 id="4-BeanDefinition-相关"><a href="#4-BeanDefinition-相关" class="headerlink" title="4. BeanDefinition 相关"></a>4. BeanDefinition 相关</h1><h2 id="4-1-BeanDefinition-的注册顺序"><a href="#4-1-BeanDefinition-的注册顺序" class="headerlink" title="4.1. BeanDefinition 的注册顺序"></a>4.1. BeanDefinition 的注册顺序</h2><p>1. @Configuration   <br>2. @Component <br>3. @Import—类<br>4. @Bean<br>5. @Import—ImportBeanDefinitionRegistrar</p><p>详细版<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202171228.png" alt="image.png"></p><h1 id="5-线程相关"><a href="#5-线程相关" class="headerlink" title="5. 线程相关"></a>5. 线程相关</h1><h2 id="5-1-Spring-如何处理线程并发问题⭐️🔴"><a href="#5-1-Spring-如何处理线程并发问题⭐️🔴" class="headerlink" title="5.1. Spring 如何处理线程并发问题⭐️🔴"></a>5.1. Spring 如何处理线程并发问题⭐️🔴</h2><p>^yqybkq<br>在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题。</p><p>&#x3D;&#x3D;ThreadLocal&#x3D;&#x3D; 和 &#x3D;&#x3D;线程同步机制&#x3D;&#x3D;都是为了解决多线程中相同变量的访问冲突问题。<span style="background-color:#00ff00">同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队</span>。<span style="background-color:#ff00ff">而 ThreadLocal 采用了“空间换时间”的方式</span>。</p><p>ThreadLocal 会为每一个线程提供一个<span style="background-color:#00ff00">独立的变量副本</span>，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal</p><h1 id="6-设计模式相关"><a href="#6-设计模式相关" class="headerlink" title="6. 设计模式相关"></a>6. 设计模式相关</h1><h2 id="6-1-Spring-中用到了哪些设计模式⭐️🔴⭐️🔴"><a href="#6-1-Spring-中用到了哪些设计模式⭐️🔴⭐️🔴" class="headerlink" title="6.1. Spring 中用到了哪些设计模式⭐️🔴⭐️🔴"></a>6.1. Spring 中用到了哪些设计模式⭐️🔴⭐️🔴</h2><ol><li>单例模式：Bean 默认为单例模式 [[内功心法专题-设计模式-3、单例模式]] ^4jhz9m</li><li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例 [[内功心法专题-设计模式-4、工厂模式]]</li><li>原型模式: [[内功心法专题-设计模式-5、原型模式]]</li><li>建造者模式: [[内功心法专题-设计模式-6、建造者模式]]</li><li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；<a href="/2023/01/12/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="设计模式-7、代理模式">设计模式-7、代理模式</a></li><li>适配器模式: <a href="/2023/01/13/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-8、适配器模式">设计模式-8、适配器模式</a></li><li>装饰者模式: [[内功心法专题-设计模式-9、装饰者模式]]</li><li>桥接模式: <a href="/2023/01/14/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="设计模式-10、桥接模式">设计模式-10、桥接模式</a></li><li>组合模式：[[内功心法专题-设计模式-12、组合模式]]</li><li>享元模式：[[内功心法专题-设计模式-13、享元模式]]</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate [[内功心法专题-设计模式-14、模板方法模式]]</li><li>策略模式：[[内功心法专题-设计模式-15、策略模式]]</li><li>命令模式：[[内功心法专题-设计模式-16、命令模式]]</li><li>责任链模式：[[内功心法专题-设计模式-17、责任链模式]]</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring 中 listener 的实现 ApplicationListener [[内功心法专题-设计模式-19、观察者模式]]</li><li>迭代器模式：[[内功心法专题-设计模式-21、迭代器模式]]</li><li>解释器模式：[[内功心法专题-设计模式-24、解释器模式]]<br>❕<span style="display:none">%%<br>2129-🏡⭐️◼️Spring 中用到了哪些设计模式 ?🔜MSTM📝 23 种设计模式中用到了 17 种，其中抽象工厂模式、外观模式、状态模式、中介者模式、访问者模式、备忘录模式 6 种没有使用到◼️⭐️-point-202302052129%%</span></li></ol><h2 id="6-2-单例-bean-的优势"><a href="#6-2-单例-bean-的优势" class="headerlink" title="6.2. 单例 bean 的优势"></a>6.2. 单例 bean 的优势</h2><ol><li>减少了新生成实例的消耗。新生成实例消耗包括两方面：第一，spring 会通过反射或者 cglib 来生成 bean 实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。 提供服务器内存的利用率 ，减少服务器内存消耗  </li><li>减少 jvm 垃圾回收由于不会给每个请求都新生成 bean 实例，所以自然回收的对象少了。</li><li>可以快速获取到 bean 因为单例的获取 bean 操作除了第一次生成之外其余的都是从缓存里获取的所以很快。❕<span style="display:none">%%<br>2135-🏡⭐️◼️单例 bean 有哪些好处 ?🔜MSTM📝 1. 减少了生成新实例的性能消耗，包括两部分：Spring 通过反射或者 cglib 方式生成对象的性能消耗、为对象分配内存的性能消耗。2. 减少 JVM 的 GC 和 STW。3. 可以快速获得 bean ◼️⭐️-point-202302052135%%</span></li></ol><h1 id="7-注解相关"><a href="#7-注解相关" class="headerlink" title="7. 注解相关"></a>7. 注解相关</h1><h2 id="7-1-Spring-有哪几种配置方式"><a href="#7-1-Spring-有哪几种配置方式" class="headerlink" title="7.1. Spring 有哪几种配置方式"></a>7.1. Spring 有哪几种配置方式</h2><p> 这里有三种重要的方法给 Spring 容器提供配置元数据。</p><p>1. XML 配置文件。  spring 诞生<br>spring.xml    <code> &lt;bean&gt;</code></p><p>2. 基于注解的配置。  Spring2.5+<br>spring.xml  + @Component  @Autowired</p><p>3. 基于 java 的配置。 JavaConfig  Spring3.0+<br>@Configuration   @Bean   ….</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230321224533.png" alt="image.png"></p><h2 id="7-2-JavaConfig-与-XML-方式-Spring-配置的不同⭐️🔴"><a href="#7-2-JavaConfig-与-XML-方式-Spring-配置的不同⭐️🔴" class="headerlink" title="7.2. JavaConfig 与 XML 方式 Spring 配置的不同⭐️🔴"></a>7.2. JavaConfig 与 XML 方式 Spring 配置的不同⭐️🔴</h2><p>^b5hhm9</p><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230203164128.png" alt="image.png"></p><h3 id="7-2-1-JavaConfig"><a href="#7-2-1-JavaConfig" class="headerlink" title="7.2.1. JavaConfig"></a>7.2.1. JavaConfig</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204122011.png" alt="image.png"></p><p><a href="https://www.processon.com/diagraming/63dd8eb4b59543238fa3a6a5">https://www.processon.com/diagraming/63dd8eb4b59543238fa3a6a5</a></p><h4 id="7-2-1-1-注册核心-BPP"><a href="#7-2-1-1-注册核心-BPP" class="headerlink" title="7.2.1.1. 注册核心 BPP"></a>7.2.1.1. 注册核心 BPP</h4><ol><li>在 <code>new AnnotationConfigApplicationContext(MainConfig.class)</code> 中的 <code>this</code> 方法中 <code>AnnotatedBeanDefinitionReader</code> 为工厂注册 6 大内置核心组件，其中 <code>ConfigurationClassPostProcessor</code> 是用来处理配置类的</li><li><code>刷新第5步：invokeBeanFactoryPostProcessors()</code><br><span style="background-color:#ff00ff">getBean</span> <code>ConfigurationClassPostProcessor</code></li></ol><h4 id="7-2-1-2-读取配置类-注册配置类"><a href="#7-2-1-2-读取配置类-注册配置类" class="headerlink" title="7.2.1.2. 读取配置类 (注册配置类)"></a>7.2.1.2. 读取配置类 (注册配置类)</h4><p>在 <code>new AnnotationConfigApplicationContext(MainConfig.class)</code> 中的 <code>register(componentClasses)</code> 方法中使用 <code>AnnotatedBeanDefinitionReader</code> 注册配置类</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230203195618.png" alt="image.png"></p><h4 id="7-2-1-3-解析配置类-扫描注册引入类"><a href="#7-2-1-3-解析配置类-扫描注册引入类" class="headerlink" title="7.2.1.3. 解析配置类 (扫描注册引入类)"></a>7.2.1.3. 解析配置类 (扫描注册引入类)</h4><p>执行 <code>ConfigurationClassPostProcessor</code> 的 <code>postProcessor.postProcessBeanDefinitionRegistry()</code> 方法，把【配置类中的】所有 bean 的定义信息导入进来。由 ConfigurationClassParser 解析每一个配置类</p><p>核心方法，将完全填充好的 ConfigurationClass 实例转化为 BeanDefinition 注册入 IOC 容器 <code>this.reader.loadBeanDefinitions(configClasses)</code></p><h3 id="7-2-2-XML"><a href="#7-2-2-XML" class="headerlink" title="7.2.2. XML"></a>7.2.2. XML</h3><p><a href="https://www.processon.com/diagraming/63ddb70fc12afe0cadb59d2c">https://www.processon.com/diagraming/63ddb70fc12afe0cadb59d2c</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204121938.png" alt="image.png"></p><h4 id="7-2-2-1-读取配置文件"><a href="#7-2-2-1-读取配置文件" class="headerlink" title="7.2.2.1. 读取配置文件"></a>7.2.2.1. 读取配置文件</h4><h5 id="7-2-2-1-1-XmlBeanDefinitionReader"><a href="#7-2-2-1-1-XmlBeanDefinitionReader" class="headerlink" title="7.2.2.1.1. XmlBeanDefinitionReader"></a>7.2.2.1.1. XmlBeanDefinitionReader</h5><h5 id="7-2-2-1-2-DefaultDocumentLoader"><a href="#7-2-2-1-2-DefaultDocumentLoader" class="headerlink" title="7.2.2.1.2. DefaultDocumentLoader"></a>7.2.2.1.2. DefaultDocumentLoader</h5><p>此处获取 xml 文件的 document 对象，这个解析过程是由 documentLoader 完成的，最终开始将 resource 读取成一个 document 文档<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204095148.png" alt="image.png"></p><h4 id="7-2-2-2-解析配置类"><a href="#7-2-2-2-解析配置类" class="headerlink" title="7.2.2.2. 解析配置类"></a>7.2.2.2. 解析配置类</h4><h5 id="7-2-2-2-1-DefaultBeanDefinitionDocumentReader"><a href="#7-2-2-2-1-DefaultBeanDefinitionDocumentReader" class="headerlink" title="7.2.2.2.1. DefaultBeanDefinitionDocumentReader"></a>7.2.2.2.1. <strong>DefaultBeanDefinitionDocumentReader</strong></h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204095229.png" alt="image.png"></p><h2 id="7-3-Component-Controller-Repository-Service"><a href="#7-3-Component-Controller-Repository-Service" class="headerlink" title="7.3. Component Controller Repository Service"></a>7.3. Component Controller Repository Service</h2><ol><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ol><h2 id="7-4-Import-可以有几种用法-注册-BD-方法"><a href="#7-4-Import-可以有几种用法-注册-BD-方法" class="headerlink" title="7.4. @Import 可以有几种用法 (注册 BD 方法)"></a>7.4. @Import 可以有几种用法 (注册 BD 方法)</h2><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><p><strong>4 种</strong><br>1. 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成 Bean)<br>2. 通过<span style="background-color:#00ff00">实现 ImportSelector 接口</span> 可以一次性注册多个，返回一个 string[]  每一个值就是类的完整类路径<br>a. 通过<span style="background-color:#00ff00">实现 DeferredImportSelector 接口</span>可以一次性注册多个，返回一个 string[]  每一个值就是类的完整类路径<br>i. 区别：DeferredImportSelector 顺序靠后<br>3. 通过<span style="background-color:#00ff00">实现 ImportBeanDefinitionRegistrar 接口</span>可以一次性注册多个，通过 BeanDefinitionRegistry 来动态注册 BeanDefinition</p><h2 id="7-5-Configuration-的作用解析原理"><a href="#7-5-Configuration-的作用解析原理" class="headerlink" title="7.5. @Configuration 的作用解析原理"></a>7.5. @Configuration 的作用解析原理</h2><p>@Configuration 用来代替 xml 配置方式 spring.xml 配置文件 bean 的吗？不全对<br>因为没有@Configuration 也是可以配置@Bean</p><h3 id="7-5-1-Configuration-加与不加有什么区别"><a href="#7-5-1-Configuration-加与不加有什么区别" class="headerlink" title="7.5.1. @Configuration 加与不加有什么区别"></a>7.5.1. @Configuration 加与不加有什么区别</h3><p><strong>作用：</strong><br>加了@Configuration 会为配置类创建 cglib 动态代理（保证配置类@Bean 方法调用 Bean 的单例），@Bean 方法的调用就会通过容器 getBean 进行获取<br><strong>原理：</strong></p><ol><li>创建 Spring 上下文的时候会在 this() 方法中注册一个解析配置的处理器 ConfigurationClassPostProcessor（它实现了 BeanFactoryPostProcessor 和<br>BeanDefinitionRegistryPostProcessor)</li><li>在 refresh () 方法第 5 步中，调用 <code>invokeBeanFactoryPostProcessor</code>，就会去调用<br><code>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</code> 进行解析配置（解析配置类就是去解析并注册各种注解的 BeanDefinition，比如@Bean @Configuration @Import @Component … 把这些注解的 BeanDefinition 解析并放入 BeanDefinitionMap 中</li><li>调用 invokeBeanFactoryPostProcessors，还会调用 <code>ConfigurationClassPostProcessor.postProcessBeanFactory</code>，在里面会调用 <code>enhanceConfigurationClasses(beanFactory)</code> 方法来创建 cglib 动态代理</li></ol><h2 id="7-6-Bean-之间的方法调用是怎么保证单例的"><a href="#7-6-Bean-之间的方法调用是怎么保证单例的" class="headerlink" title="7.6. @Bean 之间的方法调用是怎么保证单例的"></a>7.6. @Bean 之间的方法调用是怎么保证单例的</h2><p><a href="https://www.bilibili.com/video/BV1t44y1C73F?p=45&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1t44y1C73F?p=45&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>（ @Configuration 加与不加的区别是什么？）<br>1.如果希望@bean 的方法返回是对象是单例  需要在类上面加上@Configuration,<br>2.Spring 会在 invokeBeanFactoryPostProcessor  通过内置 BeanFactoryPostProcessor 中会 CGLib 生成动态代理代理<br>3.当@Bean 方法进行互调时， 则会通过 CGLIB 进行增强，通过调用的方法名作为 bean 的名称去 ioc 容器中获取，进而保证了@Bean 方法的单例</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202191415.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202191651.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204165509.png" alt="image.png"></p><h1 id="8-AOP-相关"><a href="#8-AOP-相关" class="headerlink" title="8. AOP 相关"></a>8. AOP 相关</h1><h2 id="8-1-是什么做什么"><a href="#8-1-是什么做什么" class="headerlink" title="8.1. 是什么做什么"></a>8.1. 是什么做什么</h2><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p>可用于权限认证、日志、事务处理等。</p><p>AOP、OOP 在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP(面向对象编程) 针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而 AOP 作为面向对象的一种补充，则是针对业务处理过程中的切面进行提取， 已达到业务代码和公共行为代码之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p><h2 id="8-2-各种概念关系"><a href="#8-2-各种概念关系" class="headerlink" title="8.2. 各种概念关系"></a>8.2. 各种概念关系</h2><ol><li>AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。<a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></li><li>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理</li><li>Objenesis 是 CGLIB 的增强，不需要构造函数就可以代理</li></ol><blockquote><p>   <span style="background-color:#ff00ff">直接使用注入的代理类的属性是不行的</span><br>   当我们@Autowired 注入了代理类，如果想当然的直接使用被注入对象的属性，则一定会报空指针，而我们正常情况为什么没有发生问题呢，原因是我们一般都是调用该对象的方法，而不是直接使用其中的属性的，而调用其中的方法，则代理类处理完切面任务之后，会进入到真正的对象，而真正的对象里的各个属性都是有值的，不会发生空指针。</p></blockquote><p><a href="https://blog.csdn.net/qq_30095631/article/details/108086616">https://blog.csdn.net/qq_30095631/article/details/108086616</a></p><h2 id="8-3-解释一下-Spring-AOP-里面的几个名词"><a href="#8-3-解释一下-Spring-AOP-里面的几个名词" class="headerlink" title="8.3. 解释一下 Spring AOP 里面的几个名词"></a>8.3. 解释一下 Spring AOP 里面的几个名词</h2><p>（1）<strong>连接点（Join point</strong>）： 指定就是被增强的业务方法<br>（2）<strong>切面（Aspect）</strong>：  在 Spring Aop 指定就是“切面类” ，<span style="background-color:#00ff00">切面类管理着切点、通知</span>。<br>（3）<strong>切点（Pointcut）</strong>：  <span style="background-color:#00ff00">由他决定哪些方法需要增强、哪些不需要增强，  结合切点表达式进行实现</span><br>（4）<strong>通知（Advice）</strong>：     <span style="background-color:#00ff00">就是需要增加到业务方法中的公共代码，通知有很多种类型分别可以在需要增加的业务方法</span><br>不同位置进行执行（前置通知、后置通知、异常通知、返回通知、环绕通知）<br>（5）目标对象（Target Object）：  指定是增强的对象<br>（6）<strong>织入（Weaving）</strong> ：  spring aop 用的织入方式：动态代理。  就是为目标对象创建动态代理的过程就叫织入。</p><h2 id="8-4-Spring-通知有哪些类型？"><a href="#8-4-Spring-通知有哪些类型？" class="headerlink" title="8.4. Spring 通知有哪些类型？"></a>8.4. Spring 通知有哪些类型？</h2><p>在 AOP 术语中，在的某个特定的连接点上执行的动作<br>Spring 切面可以应用 5 种类型的通知：<br>1. 前置通知（Before）：在目标方法被调用之前调用通知功能；<br>2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；<br>3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；<br>4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p><p>执行顺序：</p><p>1、正常执行：<br>@Around &gt; @Before ­­­&gt;方法 &gt; @After ­­­­&gt; @AfterReturning ­­­ &gt; @Around<br>2、异常执行：<br>@Around &gt; @Before­­­&gt;方法 &gt; @After­­­­ &gt; @AfterThrowing­­­</p><p>Spring 在<span style="background-color:#ff00ff">5.2.7 之后</span>就改变的 advice 的执行顺序</p><p>1、正常执行：<br>@Around &gt; @Before ­­­&gt;方法 ­­­­&gt; @AfterReturning ­­­&gt; @After &gt; @Around<br>2、异常执行：<br>@Around &gt; @Before­­­&gt;方法­­­­ &gt; @AfterThrowing­­­ &gt; @After</p><h2 id="8-5-Spring-AOP-与-AspectJ-AOP-有什么区别？"><a href="#8-5-Spring-AOP-与-AspectJ-AOP-有什么区别？" class="headerlink" title="8.5. Spring AOP 与 AspectJ AOP 有什么区别？"></a>8.5. Spring AOP 与 AspectJ AOP 有什么区别？</h2><h3 id="8-5-1-关系"><a href="#8-5-1-关系" class="headerlink" title="8.5.1. 关系"></a>8.5.1. 关系</h3><p>当在 Spring 中要使用@Aspect、@Before 等这些注解的时候， 就需要添加 AspectJ 相关依赖</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202211531.png" alt="image.png"></p><p>Spring Aop 提供了 AspectJ 的支持，但只用到的 AspectJ 的切点解析和匹配。 @Aspect、@Before 等这些注解都是由 AspectJ 发明的<br><span style="background-color:#ff00ff">AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。</span></p><h3 id="8-5-2-区别"><a href="#8-5-2-区别" class="headerlink" title="8.5.2. 区别"></a>8.5.2. 区别</h3><p>（1）AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为<span style="background-color:#ff00ff">编译时增强</span>，他会在编译阶段将 AspectJ(切面) 织入到 Java 字节码中，运行的时候就是增强之后的 AOP 对象。<br>（2）Spring AOP 使用的动态代理，它基于动态代理来实现。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。</p><h2 id="8-6-JDK-动态代理和-CGLIB-动态代理的区别"><a href="#8-6-JDK-动态代理和-CGLIB-动态代理的区别" class="headerlink" title="8.6. JDK 动态代理和 CGLIB 动态代理的区别"></a>8.6. JDK 动态代理和 CGLIB 动态代理的区别</h2><p>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理：</p><ol><li>JDK 动态代理<span style="background-color:#00ff00">只提供接口的代理，不支持类的代理</span>。<br>JDK 会在运行时为目标类生成一个动态代理类 $proxy*.class  . <br>  该代理类是实现了目标类接口， 并且代理类会<span style="background-color:#00ff00">实现接口所有的方法</span>增强代码。 <br> 调用时通过代理类先去调用处理类进行增强，再通过<span style="background-color:#ff00ff">反射</span>的方式进行调用目标方法。从而实现 AOP</li><li>如果代理类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。<br>CGLIB 的底层是<span style="background-color:#00ff00">通过 ASM 在运行时动态的生成目标类的一个子类</span>。（还有其他相关类，主要是为增强调用时效率）会生成多个 ，并且会重写父类所有的方法增强代码，调用时先通过代理类进行增强，再<span style="background-color:#ff00ff">直接调用父类对应的方法</span>进行调用目标方法。从而实现AOP。<br> <span style="background-color:#ffff00">CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final</span>，那么它是无法使用 CGLIB 做动态代理的。CGLIB 除了生成目标子类代理类，<span style="background-color:#00ff00">还有一个 FastClass(路由类)，可以（但不是必须）让本类方法调用进行增强，而不会像 jdk 代理那样本类方法调用增强会失效</span>，但是为了 AOP 整体一致性，这个特性并未对外使用</li><li>在老版本 CGLIB 的速度是 JDK 速度的 10 倍左右, 但是实际上 JDK 的速度在版本升级的时候每次都提高很多性能,而 CGLIB 仍止步不前。在对 JDK 动态代理与 CGlib 动态代理的代码实验中看，1W 次执行下，JDK7 及 8 的动态代理性能比 CGlib 要好 20% 左右。</li></ol><h2 id="8-7-JavaConfig-方式如何启用-AOP-如何强制使用-cglib"><a href="#8-7-JavaConfig-方式如何启用-AOP-如何强制使用-cglib" class="headerlink" title="8.7. JavaConfig 方式如何启用 AOP? 如何强制使用 cglib"></a>8.7. JavaConfig 方式如何启用 AOP? 如何强制使用 cglib</h2><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230323-0744%%</span>❕ ^sn8xbz</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@EnableAspectJAutoProxy</span><br>(proxyTargetClass = <span class="hljs-literal">true</span>) <span class="hljs-comment">//强制CGLIB</span><br>(exposeProxy = <span class="hljs-literal">true</span>) 在线程中暴露代理对象<span class="hljs-meta">@EnableAspectJAutoProxy</span><br></code></pre></td></tr></table></figure><p>^lcbyzk</p><blockquote><ol><li>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。</li><li>SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。<span style="background-color:#ffff00">目标类没有实现接口或者接收代理类的类型不是共同父接口就会导致类型转换异常。</span></li><li>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项 <code>spring.aop.proxy-target-class=false</code> 来进行修改，<code>proxyTargetClass</code> 配置已无效。<br>❕<span style="display:none">%%<br>1211-🏡⭐️◼️强制开启 CGLIB 代理的方法 ?🔜MSTM📝 增加配置参数 proxy-target-class&#x3D;”true”◼️⭐️-point-202302091211%%</span></li></ol></blockquote><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a><p>对比记忆：<a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><br>❕<span style="display:none">%%<br>0653-🏡⭐️◼️CGLIB 相关的 2 个配置 ?🔜MSTM📝 都是 proxy 开头，一个用于 AOP 中指定使用 cglib 作为动态代理的生成方式：proxytargetclass。一个用于方法 bean 是否需要 full 模式，即是否需要生成一个 cglib 动态代理：proxybeanmethod。◼️⭐️-point-202302100653%%</span></p><p>^1k8ap0</p><h2 id="8-8-AOP-失效-or-如何在同一个-service-中使用传播行为"><a href="#8-8-AOP-失效-or-如何在同一个-service-中使用传播行为" class="headerlink" title="8.8. AOP 失效 or 如何在同一个 service 中使用传播行为"></a>8.8. AOP 失效 or 如何在同一个 service 中使用传播行为</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230608-1708%%</span>❕ ^tzh2qj</p><p>解决方式：必须走代理， 重新拿到代理对象再次执行方法才能进行增强</p><p>1. 在本类中自动注入当前的 bean<br>2. 设置暴露当前代理对象到本地线程， 可以通过 AopContext.currentProxy() 拿到当前正在调用的动态代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy=true)</span><br><span class="hljs-type">SpuInfoService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (SpuInfoService) AopContext.currentProxy();<br></code></pre></td></tr></table></figure><h2 id="8-9-介绍-AOP-有几种实现方式"><a href="#8-9-介绍-AOP-有几种实现方式" class="headerlink" title="8.9. 介绍 AOP 有几种实现方式"></a>8.9. 介绍 AOP 有几种实现方式</h2><ol><li>Spring 1.2 基于接口的配置：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。</li><li>Spring 2.0 schema-based 配置：Spring 2.0 以后使用 XML 的方式来配置，使用命名空间 <aop ></aop></li><li>Spring 2.0 @AspectJ 配置：使用注解的方式来配置最方便的，还有，这里虽然叫做 @AspectJ，但是这个和 AspectJ 其实没啥关系。</li><li>AspectJ  方式，这种方式其实和 Spring 没有关系，采用 AspectJ 进行动态织入的方式实现 AOP，需要用 AspectJ 单独编译。</li></ol><h2 id="8-10-Spring-的-AOP-是在哪里创建的动态代理？"><a href="#8-10-Spring-的-AOP-是在哪里创建的动态代理？" class="headerlink" title="8.10. Spring 的 AOP 是在哪里创建的动态代理？"></a>8.10. Spring 的 AOP 是在哪里创建的动态代理？</h2><p>1. 正常的 Bean 会在 Bean 的生命周期的‘初始化’后， 通过 BeanPostProcessor.postProcessAfterInitialization 创建 aop 的动态代理<br>2. 还有一种特殊情况： 循环依赖的 Bean 会在 Bean 的生命周期‘属性注入’时存在的循环依赖的情况下， 也会为循环依赖的 Bean<br>通过 MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 创建 aop</p><h2 id="8-11-Spring-的-Aop-的完整实现流程？"><a href="#8-11-Spring-的-Aop-的完整实现流程？" class="headerlink" title="8.11. Spring 的 Aop 的完整实现流程？"></a>8.11. Spring 的 Aop 的完整实现流程？</h2><p>^f9oy7j<br>Aop 的实现大致分为三大步：JavaConfig<br>当@EnableAspectJAutoProxy 会通过@Import 注册一个 BeanPostProcessor 处理 AOP</p><ol><li><p><strong>解析切面</strong>： 在 Bean 创建之前的第一个 Bean 后置处理器会去解析切面（解析切面中通知、切点，一个通知就会解析成一个 advisor(通知、切点)） <br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209132856.png" alt="image.png"></p></li><li><p><strong>创建动态代理</strong>：正常的 Bean 初始化后调用 BeanPostProcessor  拿到之前缓存的 advisor ，再通过 advisor 中 pointcut  判断当前 Bean 是否被切点表达式匹配，如果匹配，就会为 Bean 创建动态代理（创建方式：1.jdk 动态代理、 2.cglib)。</p></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209133211.png" alt="image.png"></p><ol start="3"><li><strong>调用</strong>：拿到动态代理对象，调用方法就会判断当前方法是否增强的方法，就会通过调用链的方式依次去执行通知<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209133351.png" alt="image.png"></li></ol><h1 id="9-事务相关"><a href="#9-事务相关" class="headerlink" title="9. 事务相关"></a>9. 事务相关</h1><h1 id="10-参考与感谢"><a href="#10-参考与感谢" class="headerlink" title="10. 参考与感谢"></a>10. 参考与感谢</h1><h2 id="10-1-图灵徐庶"><a href="#10-1-图灵徐庶" class="headerlink" title="10.1. 图灵徐庶"></a>10.1. 图灵徐庶</h2><p><a href="https://www.bilibili.com/video/BV1mf4y1c7cV/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>[[Spring全家桶面试题—图灵徐庶.pdf]]<br><a href="https://www.processon.com/view/link/5f5075c763768959e2d109df#map">https://www.processon.com/view/link/5f5075c763768959e2d109df#map</a> ^b7goye</p><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Spring-基本概念&quot;&gt;&lt;a href=&quot;#1-Spring-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. Spring 基本概念&quot;&gt;&lt;/a&gt;1. Spring 基本概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://r</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>经验专题-序列化与反序列化-1、选型比较</title>
    <link href="https://taylorluo.github.io/2023/04/26/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1%E3%80%81%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>https://taylorluo.github.io/2023/04/26/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1%E3%80%81%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83/</id>
    <published>2023-04-26T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:43.043Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Java-序列化"><a href="#1-Java-序列化" class="headerlink" title="1. Java 序列化"></a>1. Java 序列化</h1><p><a href="https://cloud.tencent.com/developer/article/1752784">https://cloud.tencent.com/developer/article/1752784</a></p><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1. 是什么"></a>1.1. 是什么</h2><p>如今大部分的后端服务都是基于微服务架构实现的，服务按照业务划分被拆分，实现了服务的解耦，同时也带来了一些新的问题，比如不同业务之间的通信需要通过接口实现调用。<span style="background-color:#ff00ff">两个服务之间要共享一个数据对象，就需要从对象转换成二进制流，通过网络传输，传送到对方服务，再转换成对象，供服务方法调用。这个编码和解码的过程我们称之为序列化和反序列化</span>。</p><p>在高并发系统中，序列化的速度快慢，会影响请求的响应时间，序列化后的传输数据体积大，会导致网络吞吐量下降，所以，一个优秀的序列化框架可以提高系统的整体性能。</p><p>我们都知道 Java 提供了 RMI 框架可以实现服务与服务之间的接口暴露和调用，RMI 中对数据对象的序列化采用的是 Java 序列化。而目前主流的框架却很少使用到 Java 序列化，如 SpringCloud 使用的 Json 序列化，Dubbo 虽然兼容了 Java 序列化，但是默认还是使用的 Hessian 序列化。</p><p>Java 序列化</p><p>首先，来看看什么是 Java 序列化和实现原理。Java 提供了一种序列化机制，这种机制能<span style="background-color:#ff00ff">将一个对象序列化成二进制形式</span>，用于写入磁盘或输出到网络，同时将从网络或者磁盘中读取的字节数组，反序列化成对象，在程序中使用。</p><a href="/2022/10/25/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%8E%A5%E5%8F%A3-1%E3%80%81Serializable%E6%8E%A5%E5%8F%A3/" title="关键字和接口-1、Serializable接口">关键字和接口-1、Serializable接口</a><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2. 特性"></a>1.2. 特性</h2><ol><li>JDK 提供的两个输入、输出流对象 ObjectInputStream 和 ObjectOutputStream，它们<span style="background-color:#ff00ff">只能对实现了 Serializable 接口</span>的类的对象进行反序列化和序列化。</li><li>ObjectOutputStream 的默认序列化方式，仅对对象的非 transient 的实例变量进行序列化，<span style="background-color:#ff00ff">而不会序列化对象的 transient 的实例变量，也不会序列化静态变量</span>。</li><li>在实现了 Serializable 接口的类的对象中，会生成一个 serialVersionUID 的版本号，这个版本号有什么用呢？它会在反序列化过程中来验证序列化对象是否加载了反序列化的类，<span style="background-color:#ff00ff">如果是具有相同类名的不同版本号的类，在反序列化中是无法获取对象的</span>。</li><li>具体实现序列化的是 <span style="background-color:#ff00ff">writeObject 和 readObject</span>，通常这两个方法是默认的，我们也可以在实现 Serializable 接口的类中对其重写，定制属于自己的序列化和反序列化机制。</li><li>Java 序列化类中还定义了两个重写方法：writeReplace() 和 readResolve()，前者是用来在序列化之前替换序列化对象的，后者是用来在序列化之后对返回对象进行处理的。</li></ol><h2 id="1-3-缺陷"><a href="#1-3-缺陷" class="headerlink" title="1.3. 缺陷"></a>1.3. 缺陷</h2><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230519-1946%%</span>❕ ^st48nr</p><h3 id="1-3-1-无法跨语言"><a href="#1-3-1-无法跨语言" class="headerlink" title="1.3.1. 无法跨语言"></a>1.3.1. 无法跨语言</h3><p>而 Java 序列化目前只支持 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议，因此，如果两个基于不同语言编写的应用程序之间通信，使用 Java 序列化，则无法实现两个应用服务之间传输对象的序列化和反序列化。</p><h3 id="1-3-2-容易被攻击"><a href="#1-3-2-容易被攻击" class="headerlink" title="1.3.2. 容易被攻击"></a>1.3.2. 容易被攻击</h3><p>我们知道对象是<span style="background-color:#ff00ff">通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的</span>，这个方法其实是一个神奇的构造器，<span style="background-color:#ffff00">它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化</span>。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。</p><p>对于需要长时间进行反序列化的对象，不需要执行任何代码，也可以发起一次攻击。攻击者可以<span style="background-color:#ff00ff">创建循环对象链，然后将序列化后的对象传输到程序中反序列化，这种情况会导致 hashCode 方法被调用次数呈次方爆发式增长, 从而引发栈溢出异常。</span>例如下面这个案例就可以很好地说明。</p><p>之前 FoxGlove Security 安全团队的一篇论文中提到的：通过 Apache Commons Collections，Java 反序列化漏洞可以实现攻击，一度横扫了 WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 的最新版，各大 Java Web Server 纷纷躺枪。</p><p>其实，Apache Commons Collections 就是一个第三方基础库，它扩展了 Java 标准库里的 Collection 结构，提供了很多强大的数据结构类型，并且实现了各种集合工具类。</p><p>实现攻击的原理：Apache Commons Collections 允许链式的任意的类函数反射调用，攻击者通过实现了 Java 序列化协议的端口，把攻击代码上传到服务器上，再由 Apache Commons Collections 里的 TransformedMap 来执行。</p><p><strong>如何解决这个漏洞？</strong></p><p>很多序列化协议都制定了一套数据结构来保存和获取对象。例如，JSON 序列化、ProtocolBuf 等，它们<span style="background-color:#ff00ff">只支持一些基本类型和数组数据类型，这样可以避免反序列化创建一些不确定的实例</span>。虽然它们的设计简单，但足以满足当前大部分系统的数据传输需求。我们也可以<span style="background-color:#ff00ff">通过反序列化对象白名单</span>来控制反序列化对象，可以重写 resolveClass 方法，并在该方法中校验对象名字。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(ObjectStreamClass desc)</span> <span class="hljs-keyword">throws</span> IOException,ClassNotFoundException &#123;<br>  <span class="hljs-keyword">if</span> (!desc.getName().equals(Bicycle.class.getName())) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidClassException</span>(<br>    <span class="hljs-string">&quot;Unauthorized deserialization attempt&quot;</span>, desc.getName());<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.resolveClass(desc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-3-序列化流大"><a href="#1-3-3-序列化流大" class="headerlink" title="1.3.3. 序列化流大"></a>1.3.3. 序列化流大</h3><p>序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</p><h3 id="1-3-4-性能太差"><a href="#1-3-4-性能太差" class="headerlink" title="1.3.4. 性能太差"></a>1.3.4. 性能太差</h3><p>上边说了 4 个 Java 序列化的缺点，其实业界有很多可以代替 Java 序列化的序列化框架，大部分都避免了 Java 默认序列化的一些缺陷，例如比较流行的 FastJson、Kryo、Protobuf、Hessian 等，这里就来简单的介绍一下 Protobuf 序列化框架。</p><h1 id="2-Protobuf"><a href="#2-Protobuf" class="headerlink" title="2. Protobuf"></a>2. Protobuf</h1><p><span style="background-color:#ff00ff">Protobuf 是由 Google 推出且支持多语言的序列化框架，目前在主流网站上的序列化框架性能对比测试报告中，Protobuf 无论是编解码耗时，还是二进制流压缩大小，都名列前茅。</span></p><p>Protobuf 以一个 .proto 后缀的文件为基础，这个文件描述了字段以及字段类型，通过工具可以生成不同语言的数据结构文件。在序列化该数据对象的时候，Protobuf 通过.proto 文件描述来生成 Protocol Buffers 格式的编码。</p><h1 id="3-选型"><a href="#3-选型" class="headerlink" title="3. 选型"></a>3. 选型</h1><p>Java 默认的序列化是通过 Serializable 接口实现的，只要类实现了该接口，同时生成一个默认的版本号，我们无需手动设置，该类就会自动实现序列化与反序列化。<br>Java 默认的序列化虽然实现方便，但却存在<span style="background-color:#ff0000">安全漏洞、不跨语言以及性能差等缺陷</span>，所以我强烈建议你避免使用 Java 序列化。<br>纵观主流序列化框架，FastJson、Protobuf、Kryo 是比较有特点的，而且性能以及安全方面都得到了业界的认可，我们可以结合自身业务来选择一种适合的序列化框架，来优化系统的序列化性能</p><h2 id="3-1-SpringBoot-集成-ES"><a href="#3-1-SpringBoot-集成-ES" class="headerlink" title="3.1. SpringBoot 集成 ES"></a>3.1. SpringBoot 集成 ES</h2><p>在集成 SpringBoot 与 ElasticSearch 时，关于 LocalDateTime 类型的序列化与反序列化报错，SpringBoot 默认的 Jackson 用起来不是很顺手（需要实例化 ObjectMapper），便计划使用 FastJson，然而，直接引入 FastJson 后，会与默认的 Jackson 发生冲突。。</p><p>原文链接： <a href="https://blog.csdn.net/u013810234/article/details/106975976">https://blog.csdn.net/u013810234/article/details/106975976</a></p><h1 id="4-实战经验"><a href="#4-实战经验" class="headerlink" title="4. 实战经验"></a>4. 实战经验</h1><h1 id="5-参考与感谢"><a href="#5-参考与感谢" class="headerlink" title="5. 参考与感谢"></a>5. 参考与感谢</h1><p><a href="https://cloud.tencent.com/developer/article/1752784">https://cloud.tencent.com/developer/article/1752784</a></p><p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a><br><a href="https://www.cnblogs.com/mic112/p/15559723.html">https://www.cnblogs.com/mic112/p/15559723.html</a><br><a href="https://developer.afengblog.com/rear-end/java/798.html">https://developer.afengblog.com/rear-end/java/798.html</a><br><a href="https://juejin.cn/post/6974565210161954829">https://juejin.cn/post/6974565210161954829</a><br><a href="https://developer.aliyun.com/article/1136866">https://developer.aliyun.com/article/1136866</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-Java-序列化&quot;&gt;&lt;a href=&quot;#1-Java-序列化&quot; class=&quot;headerlink&quot; title=&quot;1. Java 序列化&quot;&gt;&lt;/a&gt;1. Java 序列化&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>性能调优专题-进阶-1、调优汇总</title>
    <link href="https://taylorluo.github.io/2023/04/25/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E8%BF%9B%E9%98%B6-3%E3%80%81%E6%9E%B6%E6%9E%84%E8%B0%83%E4%BC%98%E6%B1%87%E6%80%BB/"/>
    <id>https://taylorluo.github.io/2023/04/25/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E8%BF%9B%E9%98%B6-3%E3%80%81%E6%9E%B6%E6%9E%84%E8%B0%83%E4%BC%98%E6%B1%87%E6%80%BB/</id>
    <published>2023-04-25T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.755Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-性能评价指标"><a href="#1-性能评价指标" class="headerlink" title="1. 性能评价指标"></a>1. 性能评价指标</h1><h2 id="1-1-响应时间"><a href="#1-1-响应时间" class="headerlink" title="1.1. 响应时间"></a>1.1. 响应时间</h2><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。<br>常用操作的响应时间列表:<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230426083110.png" alt="image.png"></p><h2 id="1-2-并发数"><a href="#1-2-并发数" class="headerlink" title="1.2. 并发数"></a>1.2. 并发数</h2><p>同一时刻，对服务器有实际交互的请求数。<br>和网站在线用户数的关联:1000 个同时在线用户数，可以估计并发数在 5% 到 15% 之间， 也就是同时并发数在 50~150 之间。</p><h2 id="1-3-吞吐量"><a href="#1-3-吞吐量" class="headerlink" title="1.3. 吞吐量"></a>1.3. 吞吐量</h2><h1 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h1><h2 id="2-1-避免过早优化"><a href="#2-1-避免过早优化" class="headerlink" title="2.1. 避免过早优化"></a>2.1. 避免过早优化</h2><p>不应该把大量的时间耗费在小的性能改进上，过早考虑优化是所有噩梦的根源。</p><p>所以，我们应该编写清晰，直接，易读和易理解的代码，真正的优化应该留到以后，等到 性能分析表明优化措施有巨大的收益时再进行。 但是过早优化，不表示我们应该编写已经知道的对性能不好的的代码结构。</p><h2 id="2-2-进行系统性能测试"><a href="#2-2-进行系统性能测试" class="headerlink" title="2.2. 进行系统性能测试"></a>2.2. 进行系统性能测试</h2><p>所有的性能调优，都有应该建立在性能测试的基础上，直觉很重要，但是要用数据说话，<br>可以推测，但是要通过测试求证</p><h2 id="2-3-寻找系统瓶颈，分而治之，逐步优化"><a href="#2-3-寻找系统瓶颈，分而治之，逐步优化" class="headerlink" title="2.3. 寻找系统瓶颈，分而治之，逐步优化"></a>2.3. 寻找系统瓶颈，分而治之，逐步优化</h2><p>性能测试后，对整个请求经历的各个环节进行分析，排查出现性能瓶颈的地方，定位问题，分析影响性能的的主要因素是什么?内存、磁盘 IO、网络、CPU，还是代码问题?架构设计不足?或者确实是系统资源不足?</p><h1 id="3-优化方案"><a href="#3-优化方案" class="headerlink" title="3. 优化方案"></a>3. 优化方案</h1><h2 id="3-1-前端优化"><a href="#3-1-前端优化" class="headerlink" title="3.1. 前端优化"></a>3.1. 前端优化</h2><h3 id="3-1-1-减少请求数"><a href="#3-1-1-减少请求数" class="headerlink" title="3.1.1. 减少请求数"></a>3.1.1. 减少请求数</h3><p>合并 CSS，Js，图片</p><h3 id="3-1-2-使用客户端缓冲"><a href="#3-1-2-使用客户端缓冲" class="headerlink" title="3.1.2. 使用客户端缓冲"></a>3.1.2. 使用客户端缓冲</h3><p>静态资源文件缓存在浏览器中，有关的属性 Cache-Control 和 Expires 如果文件发生了变化，需要更新，则通过改变文件名来解决。</p><h3 id="3-1-3-启用压缩"><a href="#3-1-3-启用压缩" class="headerlink" title="3.1.3. 启用压缩"></a>3.1.3. 启用压缩</h3><p>减少网络传输量，但会给浏览器和服务器带来性能的压力，需要权衡使用</p><h3 id="3-1-4-资源文件加载顺序"><a href="#3-1-4-资源文件加载顺序" class="headerlink" title="3.1.4. 资源文件加载顺序"></a>3.1.4. 资源文件加载顺序</h3><p>css 放在页面最上面，js 放在最下面</p><h3 id="3-1-5-减少-Cookie-传输"><a href="#3-1-5-减少-Cookie-传输" class="headerlink" title="3.1.5. 减少 Cookie 传输"></a>3.1.5. 减少 <strong>Cookie</strong> 传输</h3><p>cookie 包含在每次的请求和响应中，因此哪些数据写入 cookie 需要慎重考虑</p><h3 id="3-1-6-先给用户一个提示"><a href="#3-1-6-先给用户一个提示" class="headerlink" title="3.1.6. 先给用户一个提示"></a>3.1.6. 先给用户一个提示</h3><p>有时候在前端给用户一个提示，就能收到良好的效果。毕竟用户需要的是不要不理他。</p><h2 id="3-2-CDN-加速"><a href="#3-2-CDN-加速" class="headerlink" title="3.2. CDN 加速"></a>3.2. <strong>CDN</strong> 加速</h2><p>CDN，又称内容分发网络，本质仍然是一个缓存，而且是将数据缓存在用户最近的地方。</p><p>无法自行实现 CDN 的时候，可以考虑商用 CDN 服务。</p><h2 id="3-3-反向代理缓存"><a href="#3-3-反向代理缓存" class="headerlink" title="3.3. 反向代理缓存"></a>3.3. 反向代理缓存</h2><p>将静态资源文件缓存在反向代理服务器上，一般是 Nginx</p><h2 id="3-4-应用服务性能优化"><a href="#3-4-应用服务性能优化" class="headerlink" title="3.4. 应用服务性能优化"></a>3.4. 应用服务性能优化</h2><h3 id="3-4-1-缓存"><a href="#3-4-1-缓存" class="headerlink" title="3.4.1. 缓存"></a>3.4.1. 缓存</h3><h3 id="3-4-2-异步"><a href="#3-4-2-异步" class="headerlink" title="3.4.2. 异步"></a>3.4.2. 异步</h3><h3 id="3-4-3-集群"><a href="#3-4-3-集群" class="headerlink" title="3.4.3. 集群"></a>3.4.3. 集群</h3><h3 id="3-4-4-JVM-调优"><a href="#3-4-4-JVM-调优" class="headerlink" title="3.4.4. JVM 调优"></a>3.4.4. JVM 调优</h3><p>对 JVM 性能影响最大的是编译器。选择编译器是运行 java 程序首先要做的选择之一 热点编译的概念 对于程序来说，通常只有一部分代码被经常执行，这些关键代码被称为应用的热点，执行 的越多就认为是越热。将这些代码编译为本地机器特定的二进制码，可以有效提高应用性 能。</p><h4 id="3-4-4-1-选择编译器类型"><a href="#3-4-4-1-选择编译器类型" class="headerlink" title="3.4.4.1. 选择编译器类型"></a>3.4.4.1. 选择编译器类型</h4><p>-server，更晚编译，但是编译后的优化更多，性能更高</p><p>-client，很早就开始编译</p><p>-XX:+TieredCompilation，开启分层编译，可以让 jvm 在启动时启用 client 编译，随着代码 变热后再转为 server 编译。</p><p>缺省编译器取决于机器位数、操作系统和 CPU 数目。32 位的机器上，一般默认都是 client 编译，64 位机器上一般都是 server 编译，多核机器一般是 server 编译。</p><p>中的 mix mode 一般指编译时机:</p><p>-Xint 表示禁用 JIT，所有字节码都被解释执行，这个模式的速度最慢的。</p><p>-Xcomp 表示所有字节码都首先被编译成本地代码，然后再执行。 -Xmixed，默认模式，让 JIT 根据程序运行的情况，有选择地将某些代码编译成本地代 码。</p><p>-Xcomp 和 -Xmixed 到底谁的速度快，针对不同的程序可能有不同的结果，基本还是推荐用默认模式。</p><h4 id="3-4-4-2-代码缓存相关"><a href="#3-4-4-2-代码缓存相关" class="headerlink" title="3.4.4.2. 代码缓存相关"></a>3.4.4.2. 代码缓存相关</h4><p>在编译后，会有一个代码缓存保存编译后的代码，一旦这个缓存满了，jvm 将无法继续编译代码。</p><p>当 jvm 提示: CodeCache is full，就表示需要增加代码缓存大小。 –XX:ReservedCodeCacheSize&#x3D;N 可以用来调整这个大小。</p><p>方法内联</p><p>逃逸分析</p><h4 id="3-4-4-3-GC-调优"><a href="#3-4-4-3-GC-调优" class="headerlink" title="3.4.4.3. GC 调优"></a>3.4.4.3. GC 调优</h4><a href="/2022/11/18/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E8%BF%9B%E9%98%B6-1%E3%80%81JVM-GC%E8%B0%83%E4%BC%98/" title="性能调优-进阶-1、JVM-GC调优">性能调优-进阶-1、JVM-GC调优</a><h3 id="3-4-5-代码"><a href="#3-4-5-代码" class="headerlink" title="3.4.5. 代码"></a>3.4.5. 代码</h3><h4 id="3-4-5-1-选择合适的数据结构"><a href="#3-4-5-1-选择合适的数据结构" class="headerlink" title="3.4.5.1. 选择合适的数据结构"></a>3.4.5.1. 选择合适的数据结构</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230426102618.png" alt="image.png"></p><h4 id="3-4-5-2-选择更优的算法"><a href="#3-4-5-2-选择更优的算法" class="headerlink" title="3.4.5.2. 选择更优的算法"></a>3.4.5.2. 选择更优的算法</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230426102637.png" alt="image.png"></p><h3 id="3-4-6-并发编程"><a href="#3-4-6-并发编程" class="headerlink" title="3.4.6. 并发编程"></a>3.4.6. 并发编程</h3><p>充分利用 <strong>CPU</strong> 多核， 实现线程安全的类，避免线程安全问题 同步下减少锁的竞争</p><h3 id="3-4-7-资源的复用"><a href="#3-4-7-资源的复用" class="headerlink" title="3.4.7. 资源的复用"></a>3.4.7. 资源的复用</h3><p>目的是减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程资 源等等。</p><p>单例模式</p><p>池化技术</p><h3 id="3-4-8-反射优化"><a href="#3-4-8-反射优化" class="headerlink" title="3.4.8. 反射优化"></a>3.4.8. 反射优化</h3><a href="/2022/12/09/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1%E3%80%81%E5%8F%8D%E5%B0%84/" title="基本原理-1、反射">基本原理-1、反射</a><a href="/2022/11/18/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E8%BF%9B%E9%98%B6-1%E3%80%81JVM-GC%E8%B0%83%E4%BC%98/" title="性能调优-进阶-1、JVM-GC调优">性能调优-进阶-1、JVM-GC调优</a><h3 id="3-4-9-序列化反序列化"><a href="#3-4-9-序列化反序列化" class="headerlink" title="3.4.9. 序列化反序列化"></a>3.4.9. 序列化反序列化</h3><a href="/2023/04/26/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1%E3%80%81%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83/" title="经验专题-序列化与反序列化-1、选型比较">经验专题-序列化与反序列化-1、选型比较</a><h2 id="3-5-数据库优化"><a href="#3-5-数据库优化" class="headerlink" title="3.5. 数据库优化"></a>3.5. 数据库优化</h2><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-8%E3%80%81SQL%E4%BC%98%E5%8C%96/" title="MySQL-8、SQL优化">MySQL-8、SQL优化</a><h1 id="4-实战经验"><a href="#4-实战经验" class="headerlink" title="4. 实战经验"></a>4. 实战经验</h1><h1 id="5-参考与感谢"><a href="#5-参考与感谢" class="headerlink" title="5. 参考与感谢"></a>5. 参考与感谢</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-性能评价指标&quot;&gt;&lt;a href=&quot;#1-性能评价指标&quot; class=&quot;headerlink&quot; title=&quot;1. 性能评价指标&quot;&gt;&lt;/a&gt;1. 性能评价指标&lt;/h1&gt;&lt;h2 id=&quot;1-1-响应时间&quot;&gt;&lt;a href=&quot;#1-1-响应时间&quot; clas</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>前端框架</title>
    <link href="https://taylorluo.github.io/2023/04/24/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://taylorluo.github.io/2023/04/24/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2023-04-24T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.758Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="瘦富客户端"><a href="#瘦富客户端" class="headerlink" title="瘦富客户端"></a>瘦富客户端</h1><p><a href="https://blog.csdn.net/ArvinSnow/article/details/87254362">https://blog.csdn.net/ArvinSnow/article/details/87254362</a><br><a href="https://blog.51cto.com/evan2008/107090">https://blog.51cto.com/evan2008/107090</a></p><h2 id="富客户端"><a href="#富客户端" class="headerlink" title="富客户端"></a>富客户端</h2><p>端技术充分利用本地机器的处理能力来处理数据，而不需要把某些数据发送到服务器处理，充分利用了本地机器的资源。</p><p>DWZ<br>FLEX</p><h2 id="瘦客户端"><a href="#瘦客户端" class="headerlink" title="瘦客户端"></a>瘦客户端</h2><p>然而随着应用向互联网上迁移，客户端数量剧增，维护和升级成为一件极其困难的事情。这个时候，人们想到了要给客户端“瘦身”，就是把业务层逻辑交给服务器端来完成，客户端仅仅完成人机交互界面和用于呈现运算结果。于是 B&#x2F;S 模式诞生了，客户端被浏览器所代替。</p><h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><p><a href="https://blog.csdn.net/ArvinSnow/article/details/87254362">https://blog.csdn.net/ArvinSnow/article/details/87254362</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230425083830.png" alt="image.png"></p><h1 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h1><h1 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1><p><a href="https://www.slideshare.net/yiditushe/flex3">https://www.slideshare.net/yiditushe/flex3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;瘦富客户端&quot;&gt;&lt;a href=&quot;#瘦富客户端&quot; class=&quot;headerlink&quot; title=&quot;瘦富客户端&quot;&gt;&lt;/a&gt;瘦富客户端&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ArvinSnow/article/deta</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>APM</title>
    <link href="https://taylorluo.github.io/2023/04/23/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/APM/"/>
    <id>https://taylorluo.github.io/2023/04/23/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/APM/</id>
    <published>2023-04-23T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.757Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="业务埋点"><a href="#业务埋点" class="headerlink" title="业务埋点"></a>业务埋点</h1><p>模仿业界的神策等，自研探针组件</p><h1 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h1><h1 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1><p>[[APM 数据采集的两种方式深入对比——探针埋点VS互联数据_应用]]</p><p><a href="https://www.woshipm.com/data-analysis/4377422.html">https://www.woshipm.com/data-analysis/4377422.html</a></p><a href="/2022/12/17/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-3%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA/" title="基本原理-3、字节码增强">基本原理-3、字节码增强</a>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;业务埋点&quot;&gt;&lt;a href=&quot;#业务埋点&quot; class=&quot;headerlink&quot; title=&quot;业务埋点&quot;&gt;&lt;/a&gt;业务埋点&lt;/h1&gt;&lt;p&gt;模仿业界的神策等，自研探针组件&lt;/p&gt;
&lt;h1 id=&quot;实战经验&quot;&gt;&lt;a href=&quot;#实战经验&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs</title>
    <link href="https://taylorluo.github.io/2023/04/22/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/NodeJs/"/>
    <id>https://taylorluo.github.io/2023/04/22/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/NodeJs/</id>
    <published>2023-04-22T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.758Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h1><h2 id="1-1-JavaScript-解析引擎"><a href="#1-1-JavaScript-解析引擎" class="headerlink" title="1.1. JavaScript 解析引擎"></a>1.1. JavaScript 解析引擎</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230423215257.png" alt="image.png"></p><h2 id="1-2-后端开发方式"><a href="#1-2-后端开发方式" class="headerlink" title="1.2. 后端开发方式"></a>1.2. 后端开发方式</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424072532.png" alt="image.png"></p><h1 id="2-什么是-nodejs"><a href="#2-什么是-nodejs" class="headerlink" title="2. 什么是 nodejs"></a>2. 什么是 nodejs</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424072743.png" alt="image.png"></p><h1 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3. 模块化"></a>3. 模块化</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424081213.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424081309.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424082015.png" alt="image.png"></p><h1 id="4-包管理工具"><a href="#4-包管理工具" class="headerlink" title="4. 包管理工具"></a>4. 包管理工具</h1><h2 id="4-1-多人协作"><a href="#4-1-多人协作" class="headerlink" title="4.1. 多人协作"></a>4.1. 多人协作</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424083131.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424083215.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424083234.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424083301.png" alt="image.png"></p><h1 id="5-Express"><a href="#5-Express" class="headerlink" title="5. Express"></a>5. Express</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424084916.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424084953.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424085044.png" alt="image.png"></p><h1 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6. 跨域问题"></a>6. 跨域问题</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424092538.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424092614.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424092833.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424092856.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424093041.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424093134.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424093225.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424093457.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424101638.png" alt="image.png"></p><h1 id="7-Web-开发模式"><a href="#7-Web-开发模式" class="headerlink" title="7. Web 开发模式"></a>7. Web 开发模式</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102427.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102453.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102537.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102701.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102837.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424102933.png" alt="image.png"></p><h1 id="8-身份认证"><a href="#8-身份认证" class="headerlink" title="8. 身份认证"></a>8. 身份认证</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424103151.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424103650.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424103915.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424104152.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230424104313.png" alt="image.png"></p><h1 id="9-实战经验"><a href="#9-实战经验" class="headerlink" title="9. 实战经验"></a>9. 实战经验</h1><h1 id="10-参考与感谢"><a href="#10-参考与感谢" class="headerlink" title="10. 参考与感谢"></a>10. 参考与感谢</h1><h2 id="10-1-黑马"><a href="#10-1-黑马" class="headerlink" title="10.1. 黑马"></a>10.1. 黑马</h2><h3 id="10-1-1-视频"><a href="#10-1-1-视频" class="headerlink" title="10.1.1. 视频"></a>10.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV1DS4y1Y7L4/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1DS4y1Y7L4/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="10-1-2-资料"><a href="#10-1-2-资料" class="headerlink" title="10.1.2. 资料"></a>10.1.2. 资料</h3><p>网络笔记<br><a href="https://blog.csdn.net/m0_52316372/article/details/124759435?spm=1001.2014.3001.5502">https://blog.csdn.net/m0_52316372/article/details/124759435?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-背景知识&quot;&gt;&lt;a href=&quot;#1-背景知识&quot; class=&quot;headerlink&quot; title=&quot;1. 背景知识&quot;&gt;&lt;/a&gt;1. 背景知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-JavaScript-解析引擎&quot;&gt;&lt;a href=&quot;#1-1-JavaScr</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
  <entry>
    <title>拓展技术专题-云原生-1、云平台</title>
    <link href="https://taylorluo.github.io/2023/04/17/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98-%E4%BA%91%E5%8E%9F%E7%94%9F-1%E3%80%81Kubernetes/"/>
    <id>https://taylorluo.github.io/2023/04/17/008-%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%8B%93%E5%B1%95%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98-%E4%BA%91%E5%8E%9F%E7%94%9F-1%E3%80%81Kubernetes/</id>
    <published>2023-04-17T16:00:00.000Z</published>
    <updated>2023-06-13T23:32:42.758Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h1><p>大规模容器编排系统 kubernetes 具有以下特性：</p><ul><li><strong>服务发现和负载均衡</strong><br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li><strong>存储编排</strong><br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li><li><strong>自动部署和回滚</strong><br>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</li><li><strong>自动完成装箱计算</strong><br>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li><li><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li><strong>密钥与配置管理</strong><br>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul><h1 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230514212227.png" alt="image.png"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h1 id="2-实战经验"><a href="#2-实战经验" class="headerlink" title="2. 实战经验"></a>2. 实战经验</h1><h1 id="3-参考与感谢"><a href="#3-参考与感谢" class="headerlink" title="3. 参考与感谢"></a>3. 参考与感谢</h1><h2 id="3-1-尚硅谷"><a href="#3-1-尚硅谷" class="headerlink" title="3.1. 尚硅谷"></a>3.1. 尚硅谷</h2><h3 id="3-1-1-视频"><a href="#3-1-1-视频" class="headerlink" title="3.1.1. 视频"></a>3.1.1. 视频</h3><p><a href="https://www.bilibili.com/video/BV13Q4y1C7hS?p=1&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV13Q4y1C7hS?p=1&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="3-1-2-资料"><a href="#3-1-2-资料" class="headerlink" title="3.1.2. 资料"></a>3.1.2. 资料</h3><p><a href="https://www.yuque.com/leifengyang/oncloud/vfvmcd">https://www.yuque.com/leifengyang/oncloud/vfvmcd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-特性&quot;&gt;&lt;a href=&quot;#1-特性&quot; class=&quot;headerlink&quot; title=&quot;1. 特性&quot;&gt;&lt;/a&gt;1. 特性&lt;/h1&gt;&lt;p&gt;大规模容器编排系统 kubernetes 具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务发现和</summary>
      
    
    
    
    
    <category term="timeline" scheme="https://taylorluo.github.io/tags/timeline/"/>
    
  </entry>
  
</feed>
