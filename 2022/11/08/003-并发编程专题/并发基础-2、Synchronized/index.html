<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程专题-基础-2、Synchronized | Taylor</title><meta name="keywords" content="并发编程专题,关键字"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 特性synchronized 是用了 JMM8 大操作的 lock 和 unlock 操作，对主内存中的变量进行了独占操作。 并发编程 3 大特性是可见性，原子性，有序性。 而 synchronized 能同时保证。而 volatile 只能保证可见性，有序性，不能保证原子性 1.1. 原子性原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操"><meta property="og:type" content="article"><meta property="og:title" content="并发编程专题-基础-2、Synchronized"><meta property="og:url" content="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 特性synchronized 是用了 JMM8 大操作的 lock 和 unlock 操作，对主内存中的变量进行了独占操作。 并发编程 3 大特性是可见性，原子性，有序性。 而 synchronized 能同时保证。而 volatile 只能保证可见性，有序性，不能保证原子性 1.1. 原子性原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/952"><meta property="article:published_time" content="2022-11-08T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.683Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="并发编程专题"><meta property="article:tag" content="关键字"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/952"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程专题-基础-2、Synchronized",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/952')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程专题-基础-2、Synchronized</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-08T16:00:00.000Z" title="发表于 2022-11-09 00:00:00">2022-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.683Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="并发编程专题-基础-2、Synchronized"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><span class="ob-timelines" data-date="1125-1716" data-title=" 并发编程专题 - 基础 -2、Synchronized" data-class="orange" data-type="range" data-end="2022-11-25"></span></p><h1 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h1><p>synchronized 是用了 JMM8 大操作的 lock 和 unlock 操作，对主内存中的变量进行了独占操作。</p><p>并发编程 3 大特性是可见性，原子性，有序性。 而 synchronized 能同时保证。而 volatile 只能保证可见性，有序性，不能保证原子性</p><h2 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1. 原子性"></a>1.1. 原子性</h2><p>原子性指的是在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。</p><h2 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2. 可见性"></a>1.2. 可见性</h2><p>可见性是指一个线程对共享变量进行了修改，另一个线程可以立即读取得到修改后的最新值。</p><h2 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3. 有序性"></a>1.3. 有序性</h2><p>有序性是指程序中代码的执行顺序，Java 在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是我们编写代码时的顺序。</p><p>例如，instance &#x3D; new Singleton() 实例化对象的语句分为三步：</p><ul><li>1、分配对象的内存空间；</li><li>2、初始化对象；</li><li>3、设置实例对象指向刚分配的内存地址；</li></ul><p>上述第二步操作需要依赖第一步，但是第三步操作不需要依赖第二步，所以执行顺序可能为：1-&gt;2-&gt;3、</p><p>1-&gt;3-&gt;2，当执行顺序为 1-&gt;3-&gt;2 时，可能实例对象还没正确初始化，我们直接拿到使用的时候可能会报错。</p><h2 id="1-4-可重入特性"><a href="#1-4-可重入特性" class="headerlink" title="1.4. 可重入特性"></a>1.4. 可重入特性</h2><p>synchronized 和 ReentrantLock 都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p><h2 id="1-5-原子性比较"><a href="#1-5-原子性比较" class="headerlink" title="1.5. 原子性比较"></a>1.5. 原子性比较</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512160426.png" alt="image.png"></p><h1 id="2-深入剖析"><a href="#2-深入剖析" class="headerlink" title="2. 深入剖析"></a>2. 深入剖析</h1><h2 id="2-1-应用层面"><a href="#2-1-应用层面" class="headerlink" title="2.1. 应用层面"></a>2.1. 应用层面</h2><p>8 锁问题：<a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-9%E3%80%81Java%E5%90%84%E7%A7%8D%E9%94%81/" title="并发基础-9、Java各种锁">并发基础-9、Java各种锁</a></p><p><strong>竞态条件</strong><br>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：CAS</li></ul><p>synchronized 同步块是 Java 提供的一种原子性 <code>内置锁</code>，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁，目的就是保证多个线程在进入 synchronized 代码段或者方法时，将并行变串行。</p><ol><li>synchronized 修饰的实例方法，多线程并发访问时，只能有一个线程进入，获得对象内置锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized 修饰的静态方法，多线程并发访问时，只能有一个线程进入，获得类锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized 修饰的代码块，多线程并发访问时，只能有一个线程进入，根据括号中的对象或者是类，获得相应的对象内置锁或者是类锁</li><li>每个类都有一个类锁，类的每个对象也有一个内置锁，它们是互不干扰的，也就是说一个线程可以同时获得类锁和该类实例化对象的内置锁，当线程访问非 synchronzied 修饰的方法时，并不需要获得锁，因此不会产生阻塞。</li></ol><h3 id="2-1-1-三种锁类型"><a href="#2-1-1-三种锁类型" class="headerlink" title="2.1.1. 三种锁类型"></a>2.1.1. 三种锁类型</h3><p><span style="background-color:#0f0">本质上都是依赖对象来锁</span></p><ul><li><strong>this 锁：当前实例锁</strong></li><li><strong>Class 锁：类对象锁</strong></li><li><strong>Object 锁：对象实例锁</strong></li></ul><h3 id="2-1-2-三种应用方式"><a href="#2-1-2-三种应用方式" class="headerlink" title="2.1.2. 三种应用方式"></a>2.1.2. 三种应用方式</h3><ul><li>修饰实例成员方法：使用 this 锁，线程想要执行被 Synchronized 关键字修饰的成员实例方法必须先获取当前实例对象的锁资源；</li><li>修饰静态成员方法：使用 class 锁，线程想要执行被 Synchronized 关键字修饰的静态方法必须先获取当前类对象的锁资源；</li><li>修饰代码块：使用 Object 锁，使用给定的对象实现锁功能，线程想要执行被 Synchronized 关键字修饰的代码块必须先获取当前给定对象的锁资源；</li></ul><p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/884eb51266e4">https://www.jianshu.com/p/884eb51266e4</a></p><h2 id="2-2-字节码层面"><a href="#2-2-字节码层面" class="headerlink" title="2.2. 字节码层面"></a>2.2. 字节码层面</h2><h3 id="2-2-1-monitorenter、monitorexit"><a href="#2-2-1-monitorenter、monitorexit" class="headerlink" title="2.2.1. monitorenter、monitorexit"></a>2.2.1. monitorenter、monitorexit</h3><h4 id="2-2-1-1-修饰代码块"><a href="#2-2-1-1-修饰代码块" class="headerlink" title="2.2.1.1. 修饰代码块"></a>2.2.1.1. 修饰代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSth</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">synchronized</span> (SynchronizedTest.class)&#123;  <br>            System.out.println(<span class="hljs-string">&quot;test Synchronized&quot;</span> );  <br>        &#125;  <br>    &#125;  <br>  <br><span class="hljs-comment">//    public synchronized void doSth()&#123;  </span><br><span class="hljs-comment">//        System.out.println(&quot;test Synchronized method&quot; );  </span><br><span class="hljs-comment">//    &#125;  </span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>javap -c SynchronizedTest.class</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110075743.png"></p><p>每个对象有一个监视器锁 monitor，当 monitor 被占用时就会处于锁定状态，线程执行 monitorenter 指令时尝试获取 monitor 的所有权，过程如下：</p><p>1.如果 monitor 的进入数为 0，则该线程进入 monitor，然后将进入数设置为 1，该线程即为 monitor 的所有者</p><p>2.如果线程已经占有该 monitor，只是重新进入，则进入 monitor 的进入数加 1</p><p>3.如果其他线程已经占有该 monitor，则该线程进入阻塞状态，直到 monitor 的进入数为 0，再重新尝试获取 monitor 的所有权</p><p>执行 monitorexit 的线程必须是 objectref 所对应的 monitor 的所有者。</p><p>指令执行时，monitor 的进入数减 1，如果减 1 后进入数为 0，那线程退出 monitor，不再是这个 monitor 的所有者。其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><blockquote><p>通过这两段描述，我们应该能很清楚的看出 Synchronized 的实现原理，Synchronized 的语义底层是通过一个 monitor 的对象来完成，其实 wait&#x2F;notify 等方法也依赖于 monitor 对象，这就是为什么只有在同步的块或者方法中才能调用 wait&#x2F;notify 等方法，否则会抛出 <code>java.lang.IllegalMonitorStateException</code> 的异常的原因</p></blockquote><h4 id="2-2-1-2-2-个-monitorexit"><a href="#2-2-1-2-2-个-monitorexit" class="headerlink" title="2.2.1.2. 2 个 monitorexit"></a>2.2.1.2. 2 个 monitorexit</h4><p>从上面的中文注释处可以看到，对于 <code>synchronized</code> 关键字而言，<code>javac</code> 在编译时，会生成对应的 <code>monitorenter</code> 和 <code>monitorexit</code> 指令分别对应 <code>synchronized</code> 同步块的进入和退出，有两个 <code>monitorexit</code> 指令的原因是：为了保证抛异常的情况下也能释放锁，所以 <code>javac</code> 为同步代码块添加了一个隐式的 try-finally，在 finally 中会调用 <code>monitorexit</code> 命令释放锁。</p><h3 id="2-2-2-ACC-SYNCHRONIZED"><a href="#2-2-2-ACC-SYNCHRONIZED" class="headerlink" title="2.2.2. ACC_SYNCHRONIZED"></a>2.2.2. ACC_SYNCHRONIZED</h3><h4 id="2-2-2-1-修饰方法"><a href="#2-2-2-1-修饰方法" class="headerlink" title="2.2.2.1. 修饰方法"></a>2.2.2.1. 修饰方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;  <br>  <br><span class="hljs-comment">//    public void doSth()&#123;  </span><br><span class="hljs-comment">//        synchronized (SynchronizedTest.class)&#123;  </span><br><span class="hljs-comment">//            System.out.println(&quot;test Synchronized&quot; );  </span><br><span class="hljs-comment">//        &#125;  </span><br><span class="hljs-comment">//    &#125;  </span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSth</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;test Synchronized method&quot;</span> );  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>javap -v SynchronizedTest.class</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110080551.png"></p><blockquote><p>方法级别的同步是隐式的，作为方法调用的一部分。同步方法的常量池中会有一个 ACC_SYNCHRONIZED 标志。</p><p>当调用一个设置了 ACC_SYNCHRONIZED 标志的方法，执行线程需要先获得 monitor 锁，然后开始执行方法，方法执行之后再释放 monitor 锁，当方法不管是正常 return 还是抛出异常都会释放对应的 monitor 锁。</p><p>在这期间，如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。</p><p>如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p></blockquote><h2 id="2-3-JDK-源码层面"><a href="#2-3-JDK-源码层面" class="headerlink" title="2.3. JDK 源码层面"></a>2.3. JDK 源码层面</h2><h3 id="2-3-1-ObjectMonitor"><a href="#2-3-1-ObjectMonitor" class="headerlink" title="2.3.1. ObjectMonitor"></a>2.3.1. ObjectMonitor</h3><p>JVM 的 monitorenter、monitorexit 这种机制底层是什么？<br><strong>ObjectMonitor</strong> 是 JVM 中的对于操作系统 <code>管程</code> 的实现。</p><blockquote><p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</p></blockquote><blockquote><p>引入管程的原因<br>信号量机制的缺点：进程自备同步操作，P(S) 和 V(S) 操作大量分散在各个进程中，不易管理，易发生死锁。<br>管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。</p></blockquote><p>简单地说管程就是一个概念，任何语言都可以实现。目的就是为了简化同步调用的过程。</p><h4 id="2-3-1-1-ObjectMonitor-对象"><a href="#2-3-1-1-ObjectMonitor-对象" class="headerlink" title="2.3.1.1. ObjectMonitor 对象"></a>2.3.1.1. ObjectMonitor 对象</h4><p>使用 monitor 机制的目的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的进程&#x2F;线程，还需要一个 monitor object 来协助，这个 monitor object 内部会有相应的数据结构，例如<span style="background-color:#0f0">列表，来保存被阻塞的线程</span>；同时由于 monitor 机制本质上是基于 mutex 这种基本原语的，所以 monitor object 还必须维护<span style="background-color:#0f0">一个基于 mutex 的锁</span>。 此外，为了在适当的时候能够阻塞和唤醒 进程&#x2F;线程，还需要<span style="background-color:#0f0">引入一个条件变量</span>，这个条件变量用来决定什么时候是“适当的时候”，这个条件可以来自程序代码的逻辑，也可以是在 monitor object 的内部，总而言之，程序员对条件变量的定义有很大的自主性。不过，由于 monitor object 内部采用了数据结构来保存被阻塞的队列，因此<span style="background-color:#0f0">它也必须对外提供两个 API 来让线程进入阻塞状态以及之后被唤醒，分别是 wait 和 notify</span>。管程机制中，monitor object 充当着维护 mutex 以及定义 wait&#x2F;signal API 来管理线程的阻塞和唤醒的角色。</p><p>JVM 中的同步是基于进入和退出 monitor object 实现的，<code>每个实例都会有个monitor object ，可以和对象一起创建，销毁。</code></p><p>通常所说的对象的内置锁，是对象头 Mark Word 中的重量级锁指针指向的 monitor 对象，该对象是在 HotSpot 底层 C++ 语言编写的 (openjdk 里面看)</p><h4 id="2-3-1-2-OM-创建时机"><a href="#2-3-1-2-OM-创建时机" class="headerlink" title="2.3.1.2. OM 创建时机"></a>2.3.1.2. OM 创建时机</h4><p>执行 monitorenter 指令时，线程会为锁对象关联一个 ObjectMonitor 对象</p><p>许多文章声称一个对象关联到一个 monitor，这个说法不够准确。如果对象已经是重量级锁了，对象头的确指向了一个 <code>monitor</code>。但对于正在膨胀的锁，会先从 <strong>线程私有</strong> 的 <code>monitor</code> 集合 <code>omFreeList</code> 中分配对象。如果 <code>omFreeList</code> 中已经没有 <code>monitor</code> 对象，再从 <strong>JVM 全局</strong> 的 <code>gFreeList</code> 中分配一批 <code>monitor</code> 到 <code>omFreeList</code> 中。</p><h4 id="2-3-1-3-数据结构"><a href="#2-3-1-3-数据结构" class="headerlink" title="2.3.1.3. 数据结构"></a>2.3.1.3. 数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>   _header       = NULL;<br>   _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用来记录获取锁的线程数</span><br>   _waiters      = <span class="hljs-number">0</span>;<br>   _recursions   = <span class="hljs-number">0</span>; <span class="hljs-comment">// 线程的重入次数</span><br>   _object       = NULL;<br>   _owner        = NULL; <span class="hljs-comment">// 标识拥有该monitor的线程</span><br>   _WaitSet      = NULL; <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>                         <span class="hljs-comment">// 等待线程组成的双向循环链表，_WaitSet是第一个节点</span><br>   _WaitSetLock  = <span class="hljs-number">0</span> ;<br>   _Responsible  = NULL ;<br>   _succ         = NULL ;<br>   _cxq          = NULL ; <span class="hljs-comment">// 多线程竞争锁进入时的单向链表</span><br>                          <span class="hljs-comment">//（ContentionList）：当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程插入到cxq队列的队首</span><br>   FreeNext      = NULL ;<br>   _EntryList    = NULL ; <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>                          <span class="hljs-comment">// _owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点</span><br>   _SpinFreq     = <span class="hljs-number">0</span> ;<br>   _SpinClock    = <span class="hljs-number">0</span> ;<br>   OwnerIsThread = <span class="hljs-number">0</span> ;<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110140612.png"></p><h5 id="2-3-1-3-1-count"><a href="#2-3-1-3-1-count" class="headerlink" title="2.3.1.3.1. _count"></a>2.3.1.3.1. <code>_count</code></h5><h5 id="2-3-1-3-2-recursions"><a href="#2-3-1-3-2-recursions" class="headerlink" title="2.3.1.3.2. _recursions"></a>2.3.1.3.2. <code>_recursions</code></h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221111223242.png"></p><h5 id="2-3-1-3-3-3个队列"><a href="#2-3-1-3-3-3个队列" class="headerlink" title="2.3.1.3.3. 3个队列"></a>2.3.1.3.3. <code>3个队列</code></h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221111221930.png"></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html">https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110141331.png"></p><p><strong>简要流程</strong></p><ul><li>想要获取 monitor 的线程,首先会进入 _EntryList 队列。</li><li>当某个线程获取到对象的 monitor 后，进入 _Owner 区域，设置为当前线程，同时计数器 _count 加 1。此时该线程就持有 mutex 锁</li><li>如果线程调用了 wait() 方法，则会进入 _WaitSet 队列。它就会释放持有的 mutex 锁，即将 _owner 赋值为 null，<code>_count自减1,进入_WaitSet队列阻塞等待</code>。</li><li>如果其他线程调用 notify() &#x2F; notifyAll() ，会唤醒 _WaitSet 中的某个线程，从 WaitSet 移动到 cxq 或 EntryList 中去 (根据配置策略决定放到哪一个中)，该线程再次尝试获取 monitor 锁，成功即进入 _Owner 区域。</li><li>同步方法执行完毕了，线程退出临界区，会将 monitor 的 owner 设为 null，并释放 mutex 锁。</li><li>新请求锁的线程将首先被加入到 ConetentionList 中，当某个拥有锁的线程（Owner 状态）调用 unlock 之后，如果发现 EntryList 为空则从 ContentionList 中移动线程到 EntryList，下面说明下 ContentionList 和 EntryList 的实现方式：</li></ul><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110142733.png"></p><p><strong>ContentionList 虚拟队列</strong></p><blockquote><p>ContentionList 并不是一个真正的 Queue，而只是一个虚拟队列，原因在于 ContentionList 是由 Node 及其 next 指针逻辑构成，并不存在一个 Queue 的数据结构。ContentionList 是一个先进先出（FIFO）的队列，每次新加入 Node 时都会在队头进行，通过 CAS 改变第一个节点的的指针为新增节点，同时设置新增节点的 next 指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个 Lock-Free 的队列。<br>因为只有 Owner 线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了 CAS 的 ABA 问题。</p></blockquote><p><strong>EntryList</strong></p><blockquote><p>EntryList 与 ContentionList 逻辑上同属等待队列，ContentionList 会被线程并发访问，为了降低对 ContentionList 队尾的争用，而建立 EntryList。<span style="background-color:#0f0">Owner 线程在 unlock 时会从 ContentionList 中迁移线程到 EntryList，并会指定 EntryList 中的某个线程（一般为 Head）为 Ready（OnDeck）线程。Owner 线程并不是把锁传递给 OnDeck 线程，只是把竞争锁的权利交给 OnDeck，OnDeck 线程需要重新竞争锁。</span>这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在 Hotspot 中把 OnDeck 的选择行为称之为“竞争切换”。<br>OnDeck 线程获得锁后即变为 owner 线程，无法获得锁则会依然留在 EntryList 中，考虑到公平性，在 EntryList 中的位置不发生变化（依然在队头）。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列；如果在某个时刻被 notify&#x2F;notifyAll 唤醒，则再次转移到 EntryList。</p></blockquote><p><strong>WaitSet</strong></p><blockquote><p>通过 object 获得内置锁 (objectMonitor)，通过内置锁将 Thread 封装成 OjectWaiter 对象，然后 addWaiter 将它插入以 _waitSet 为首结点的等待线程链表中去，最后释放锁。<br>通过 object 获得内置锁 (objectMonitor)，调用内置锁的 notify 方法，通过 _waitset 结点移出等待链表中的首结点，将它置于 _EntrySet 中去，等待获取锁。</p></blockquote><h4 id="2-3-1-4-工作机制"><a href="#2-3-1-4-工作机制" class="headerlink" title="2.3.1.4. 工作机制"></a>2.3.1.4. 工作机制</h4><p>见下方重量级锁章节</p><h4 id="2-3-1-5-重量级锁的重量"><a href="#2-3-1-5-重量级锁的重量" class="headerlink" title="2.3.1.5. 重量级锁的重量"></a>2.3.1.5. 重量级锁的重量</h4><ol><li>synchronzied 实现同步用到了对象的内置锁 (ObjectMonitor)，而在 ObjectMonitor 的函数调用中会涉及到 Mutex lock 等特权指令，那么这个时候就存在操作系统用户态和核心态的转换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，这也是为什么早期的 synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 <code>重量级锁</code>。</li><li>处于 <code>ContentionList</code>、<code>EntryList</code>、<code>WaitSet</code> 中的线程都处于阻塞状态，线程的阻塞或者唤醒都需要操作系统来帮忙，Linux 内核下采用 <code>pthread_mutex_lock</code> 系统调用实现的，进程需要从用户态切换到内核态的 <code>pthread_mutex_lock</code> 系统调用，是内核态为用户态进程提供的 Linux 内核态下互斥锁 (Mutex) 的访问机制，所以使用 <code>pthread_mutex_lock</code> 系统调用时，进程需要从用户态切换到内核态，而这种切换是需要消耗很多时间的，有可能比用户执行代码的时间还要长</li></ol><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221111-httpsdocs.oracle.comcdE19253-01819-70516n919hpagindex.html]]</p><h3 id="2-3-2-对象与-monitor-关联"><a href="#2-3-2-对象与-monitor-关联" class="headerlink" title="2.3.2. 对象与 monitor 关联"></a>2.3.2. 对象与 monitor 关联</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221110142132.png"></p><h2 id="2-4-内存屏障层面"><a href="#2-4-内存屏障层面" class="headerlink" title="2.4. 内存屏障层面"></a>2.4. 内存屏障层面</h2><p>synchronized 可见性是通过内存屏障实现的，按可见性划分，内存屏障分为：</p><ul><li>Load 屏障：执行 refresh，从其他处理器的高速缓冲、主内存，加载数据到自己的高速缓存，保证数据是最新的；</li><li>Store 屏障：执行 flush 操作，自己处理器更新的变量的值，刷新到高速缓存、主内存去；</li></ul><p>获取锁时，会清空当前线程工作内存中共享变量的副本值，重新从主内存中获取变量最新的值；<br>释放锁时，会将工作内存的值重新刷新回主内存；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>synchronize (<span class="hljs-built_in">this</span>)&#123;   <span class="hljs-comment">//monitorenter</span><br>    <span class="hljs-comment">// Load内存屏障</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">// 读，通过load内存屏障，强制执行refresh，保证读到最新的</span><br>    a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 写，释放锁时会通过Store，强制flush到高速缓存或主内存</span><br>&#125;    <span class="hljs-comment">//monitorexit</span><br><span class="hljs-comment">//Store内存屏障</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221128091102.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126161358.png"></p><p>synchronized 的有序性是依靠内存屏障实现的。</p><p>按照有序性，内存屏障可分为：</p><ul><li>Acquire 屏障：load 屏障之后，加 Acquire 屏障。它会禁止同步代码块内的读操作，和外面的读写操作发生指令重排；</li><li>Release 屏障：禁止写操作，和外面的读写操作发生指令重排；</li></ul><p>在 monitorenter 指令和 Load 屏障之后，会加一个 Acquire 屏障，这个屏障的作用是禁止同步代码块里面的读操作和外面的读写操作之间发生指令重排，在 monitorexit 指令前加一个 Release 屏障，也是禁止同步代码块里面的写操作和外面的读写操作之间发生重排序。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>synchronize (<span class="hljs-built_in">this</span>)&#123;  <span class="hljs-comment">//monitorenter</span><br>    <span class="hljs-comment">// Load内存屏障</span><br>    <span class="hljs-comment">// Acquire屏障，禁止代码块内部的读，和外面的读写发生指令重排</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br>    a = <span class="hljs-number">10</span>;    <span class="hljs-comment">//注意：内部还是会发生指令重排</span><br>    <span class="hljs-comment">// Release屏障，禁止写，和外面的读写发生指令重排</span><br>&#125; <span class="hljs-comment">//monitorexit</span><br><span class="hljs-comment">//Store内存屏障</span><br></code></pre></td></tr></table></figure><h2 id="2-5-汇编实现层面"><a href="#2-5-汇编实现层面" class="headerlink" title="2.5. 汇编实现层面"></a>2.5. 汇编实现层面</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221127150423.png"></p><h1 id="3-重量级锁"><a href="#3-重量级锁" class="headerlink" title="3. 重量级锁"></a>3. 重量级锁</h1><h2 id="3-1-锁膨胀"><a href="#3-1-锁膨胀" class="headerlink" title="3.1. 锁膨胀"></a>3.1. 锁膨胀</h2><h3 id="3-1-1-触发条件"><a href="#3-1-1-触发条件" class="headerlink" title="3.1.1. 触发条件"></a>3.1.1. 触发条件</h3><p>轻量级锁的释放也比较简单，就是<span style="background-color:#f0f">将当前线程栈帧中锁记录空间中的 Mark Word 尝试 cas 替换到锁对象的对象头中</span>，如果成功表示锁释放成功。否则，锁膨胀成重量级锁，实现重量级锁的释放锁逻辑。</p><p>如果当前 mark 处于加锁状态，且 mark 中的 ptr 指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁</p><p>当调用一个锁对象的 <code>wait/notify/notifyall</code> 方法时，若当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</p><h3 id="3-1-2-执行过程"><a href="#3-1-2-执行过程" class="headerlink" title="3.1.2. 执行过程"></a>3.1.2. 执行过程</h3><p>锁膨胀的过程实际上是<span style="background-color:#ff0">获得一个 ObjectMonitor 对象监视器</span>，而真正抢占锁的逻辑，在 <code>ObjectMonitor::enter</code> 方法里面。</p><p><code>inflate</code> 其中是一个 for 循环，主要是为了处理多线程同时调用 inflate 的情况。然后会根据锁对象的状态进行不同的处理：</p><p>1.已经是重量级状态，说明膨胀已经完成，返回并继续执行 ObjectMonitor::enter 方法。<br>2.如果是轻量级锁则需要进行膨胀操作。<br>3.如果是膨胀中状态，则进行忙等待。<br>4.如果是无锁状态则需要进行膨胀操作</p><p><strong>轻量级锁锁膨胀的过程</strong><br><code>步骤 1</code>、调用 <code>omAlloc</code> 获取一个可用的 <code>ObjectMonitor</code> 对象。在 <code>omAlloc</code> 方法中会先从 <strong>线程私有</strong> 的 <code>monitor</code> 集合 <code>omFreeList</code> 中分配对象，如果 <code>omFreeList</code> 中已经没有 <code>monitor</code> 对象，则从 <strong>JVM 全局</strong> 的 <code>gFreeList</code> 中分配一批 <code>monitor</code> 到 <code>omFreeList</code> 中；</p><p><code>步骤 2</code>、通过 CAS 尝试将 Mark Word 设置为 markOopDesc:INFLATING，标识当前锁正在膨胀中。如果 CAS 失败，说明同一时刻其它线程已经将 Mark Word 设置为 markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成。</p><p><code>步骤 3</code>、如果 CAS 成功，设置 monitor 的各个字段：设置 <code>monitor</code> 的 header 字段为 <code>displaced mark word</code>，owner 字段为 <code>Lock Record</code>，obj 字段为锁对象等；</p><p>📢 <span style="background-color:#ff0"><font color="#ff0000">设置 ObjectMonitor 的 _owner 为拥有对象轻量级锁的线程的 Lock Record，而不是当前正在 inflate 的线程的 Lock Record</font></span>，用于重量级锁竞争的判断。根本原因是因为锁对象的 Mark Word 里轻量级锁信息变成了重量级锁的信息，如果这个 CAS 操作是其他线程 (比如 B) 完成的，那么 A 是不知情的，而且 B 在获取轻量级锁时也 Blocked 了，所以干脆让 A 去处理轻量级锁膨胀后的逻辑。</p><p><code>步骤 4</code>、设置锁对象头的 <code>mark word</code> 为重量级锁状态，指向第一步分配的 <code>monitor</code> 对象；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202144631.png"></p><h2 id="3-2-monitor-竞争"><a href="#3-2-monitor-竞争" class="headerlink" title="3.2. monitor 竞争"></a>3.2. monitor 竞争</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/father-of-little-pig/p/16314318.html">https://www.cnblogs.com/father-of-little-pig/p/16314318.html</a><br><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a></p><p>当锁膨胀 <code>inflate</code> 执行完并返回对应的 <code>ObjectMonitor</code> 时，并不表示该线程竞争到了锁，真正的锁竞争发生在 <code>ObjectMonitor::enter</code> 方法中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br><br>  Thread * <span class="hljs-type">const</span> Self = THREAD ;<br>  <span class="hljs-type">void</span> * cur ;<br>  <span class="hljs-comment">// 步骤1</span><br>  <span class="hljs-comment">// owner为null，如果能CAS设置成功，则当前线程直接获得锁</span><br>  cur = Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="hljs-literal">NULL</span>) ;<br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) &#123;<br>     ...<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 如果是重入的情况</span><br>  <span class="hljs-keyword">if</span> (cur == Self) &#123;<br>     <span class="hljs-comment">// TODO-<span class="hljs-doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span><br>     _recursions ++ ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 步骤2</span><br>  <span class="hljs-comment">// 如果当前线程是之前持有轻量级锁的线程</span><br>  <span class="hljs-comment">// 上节轻量级锁膨胀将owner指向之前Lock Record的指针</span><br>  <span class="hljs-comment">// 这里利用owner判断是否第一次进入。</span><br>  <span class="hljs-keyword">if</span> (Self-&gt;<span class="hljs-built_in">is_lock_owned</span> ((address)cur)) &#123;<br>    <span class="hljs-built_in">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;internal state error&quot;</span>);<br>    <span class="hljs-comment">// 重入计数重置为1</span><br>    _recursions = <span class="hljs-number">1</span> ;<br>    <span class="hljs-comment">// 设置owner字段为当前线程</span><br>    _owner = Self ;<br>    OwnerIsThread = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  ...<br>  <span class="hljs-comment">// 步骤3</span><br>  <span class="hljs-comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span><br>  <span class="hljs-keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="hljs-built_in">TrySpin</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;    <br>     ...<br>     <span class="hljs-comment">//自旋的过程中获得了锁，则直接返回</span><br>     Self-&gt;_Stalled = <span class="hljs-number">0</span> ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  ...<br>  &#123; <br>    ...<br>    <span class="hljs-comment">// 步骤4</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      jt-&gt;<span class="hljs-built_in">set_suspend_equivalent</span>();<br>      <span class="hljs-comment">// 在该方法中调用系统同步操作</span><br>      <span class="hljs-built_in">EnterI</span> (THREAD) ;<br>      ...<br>    &#125;<br>    Self-&gt;<span class="hljs-built_in">set_current_pending_monitor</span>(<span class="hljs-literal">NULL</span>); <br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202174945.png"><br><code>步骤 1</code>、<code>Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;</code> 通过 CAS 尝试将 owner 设置为当前线程。如果当前是无锁、返回 null，说明获取锁成功，简单操作后返回。如果是重入，则 <code>_recursions ++</code></p><p><code>步骤 2</code>、当前线程是之前持有轻量级锁的线程，则为首次进入，设置 recursions 为 1，owner 为当前线程，该线程成功获得锁并返回。</p><p><code>步骤 3</code>、在调用系统的同步操作之前，先通过 TrySpin 方法 <strong>自旋尝试</strong> 获得锁，尽可能减少同步操作带来的开销。</p><p><code>步骤 4</code>、获取锁失败，调用 <code>EnterI</code> 方法，在该方法中调用系统同步操作。</p><p><span style="background-color:#0f0">这里注意，轻量级锁膨胀成功时，会把 owner 字段设置为<font color="#ff0000">膨胀之前轻量级锁持有线程的</font>栈中的 <code>Lock Record</code> 的指针，并在竞争时判断，具体是用在了步骤 2 的判断里。这么做的原因是，假设当前线程 A 持有锁对象的锁，线程 B 进入同步代码块，并把锁对象升级为重量级锁。但此时，线程 A 可能还在执行，并无法感知其持有锁对象的变化。因此，需要线程 B 在执行 <code>ObjectMonitor::enter</code> 时，将自己放入到阻塞等列等待。并需要线程 A 第二次进入、或者退出的时候对 monitor 进行一些操作，以此保证代码块的同步。</span></p><h2 id="3-3-monitor-等待"><a href="#3-3-monitor-等待" class="headerlink" title="3.3. monitor 等待"></a>3.3. monitor 等待</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/father-of-little-pig/p/16314318.html">https://www.cnblogs.com/father-of-little-pig/p/16314318.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html">https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html</a></p><p><code>ObjectMonitor</code> 竞争失败的线程，通过自旋执行 <code>ObjectMonitor::EnterI</code> 方法等待锁的释放，EnterI 方法的部分逻辑实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 省略部分代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::EnterI</span> <span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    Thread * Self = THREAD ;<br>    <span class="hljs-built_in">assert</span> (Self-&gt;<span class="hljs-built_in">is_Java_thread</span>(), <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-built_in">assert</span> (((JavaThread *) Self)-&gt;<span class="hljs-built_in">thread_state</span>() == _thread_blocked   , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>    <span class="hljs-comment">// Try lock 尝试获取锁</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">assert</span> (_succ != Self              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_owner == Self             , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_Responsible != Self       , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-comment">// 如果获取成功则退出，避免 park unpark 系统调度的开销</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 自旋获取锁</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TrySpin</span>(Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">assert</span> (_owner == Self, <span class="hljs-string">&quot;invariant&quot;</span>);<br>        <span class="hljs-built_in">assert</span> (_succ != Self, <span class="hljs-string">&quot;invariant&quot;</span>);<br>        <span class="hljs-built_in">assert</span> (_Responsible != Self, <span class="hljs-string">&quot;invariant&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前线程被封装成 ObjectWaiter 对象 node, 状态设置成 ObjectWaiter::TS_CXQ</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span> </span>;<br>    Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">reset</span>() ;<br>    node._prev   = (ObjectWaiter *) <span class="hljs-number">0xBAD</span> ;<br>    node.TState  = ObjectWaiter::TS_CXQ ;<br><br>    <span class="hljs-comment">// 通过 CAS 把 node 节点 push 到_cxq 列表中</span><br>    ObjectWaiter * nxt ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        node._next = nxt = _cxq ;<br>        <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="hljs-keyword">break</span> ;<br><br>        <span class="hljs-comment">// 再次 tryLock</span><br>        <span class="hljs-comment">// CAS失败的话 再尝试获得锁，这样也可以降低插入到_cxq队列的频率</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">assert</span> (_succ != Self         , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-built_in">assert</span> (_owner == Self        , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-built_in">assert</span> (_Responsible != Self  , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 本段代码的主要思想和 AQS 中相似可以类比来看</span><br>        <span class="hljs-comment">// 再次尝试</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-built_in">assert</span> (_owner != Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>        <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">2</span>) &amp;&amp; _Responsible == <span class="hljs-literal">NULL</span>) &#123;<br>           Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="hljs-literal">NULL</span>) ;<br>        &#125;<br><br>        <span class="hljs-comment">// 满足条件则 park self</span><br>        <span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-built_in">TEVENT</span> (Inflated enter - park TIMED) ;<br>            Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span> ((jlong) RecheckInterval) ;<br>            <span class="hljs-comment">// Increase the RecheckInterval, but clamp the value.</span><br>            RecheckInterval *= <span class="hljs-number">8</span> ;<br>            <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;<br>            <span class="hljs-comment">// 通过 park 将当前线程挂起，等待被唤醒</span><br>            Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span>() ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-comment">// 再次尝试自旋</span><br>        <span class="hljs-keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">TrySpin</span>(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>EnterI 大致原理：一个 <code>ObjectMonitor</code> 对象包括两个同步队列（<code>_cxq</code> 和 <code>_EntryList</code>） ，以及一个等待队列 <code>_WaitSet</code>。cxq、EntryList 、WaitSet 都是由 ObjectWaiter 构成的链表结构。其中，<code>_cxq</code> 为单向链表，<code>_EntryList</code> 为双向链表。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221113135319.png"></p><ol><li>当一个线程尝试获得重量级锁且没有竞争到时<span style="background-color:#ff0">(又经过 TryLock、TrySpin 努力)</span>，该线程会被封装成一个 <code>ObjectWaiter</code> 的 node 对象 <code>通过CAS</code> 插入到 cxq 的队列的队首，状态设置成 ObjectWaiter::TS_CXQ。此过程中还会 tryLock，也能起到降低插入到 _cxq 队列的频率的作用。</li><li>在将 CXQ 挂起的 for 循环中，node 对象还 <code>通过自旋尝试获取锁</code>，如果在指定的阈值范围内没有获得锁，则通过 park 将当前线程挂起，进入<span style="background-color:#ff0">BLOCKED</span>状态，等待被唤醒。</li><li>当线程释放锁时，会根据唤醒策略，从 cxq 或 EntryList 中挑选一个线程 <code>unpark</code> 唤醒。唤醒时会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li><li>如果线程获得锁后调用 <code>Object#wait</code> 方法，则会将线程加入到 WaitSet 中，进入<span style="background-color:#ff0">WAITING 或 TIMED_WAITING</span>状态。</li><li>当被 <code>Object#notify</code> 唤醒后，会将线程从 WaitSet 移动到 cxq 或 EntryList 中去，进入<span style="background-color:#ff0">BLOCKED</span>状态。</li><li>需要注意的是，当调用一个锁对象的 <code>wait</code> 或 <code>notify</code> 方法时，<span style="background-color:#0f0">若当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</span></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202214650.png"></p><p><strong>线程状态温习</strong></p><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发基础-7、Thread">并发基础-7、Thread</a><h2 id="3-4-monitor-释放"><a href="#3-4-monitor-释放" class="headerlink" title="3.4. monitor 释放"></a>3.4. monitor 释放</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html">https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6977744259688939551#heading-10">https://juejin.cn/post/6977744259688939551#heading-10</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> not_suspended, TRAPS)</span> </span>&#123;<br>   Thread * Self = THREAD ;<br>   <span class="hljs-keyword">if</span> (THREAD != _owner) &#123;<span class="hljs-comment">//如果当前锁对象中的_owner没有指向当前线程</span><br>     <span class="hljs-comment">//如果_owner指向的BasicLock在当前线程栈上,那么将_owner指向当前线程</span><br>     <span class="hljs-keyword">if</span> (THREAD-&gt;<span class="hljs-built_in">is_lock_owned</span>((address) _owner)) &#123;<br>       <span class="hljs-comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span><br>       <span class="hljs-comment">// We don&#x27;t need to hold _mutex for this transition.</span><br>       <span class="hljs-comment">// Non-null to Non-null is safe as long as all readers can</span><br>       <span class="hljs-comment">// tolerate either flavor.</span><br>       <span class="hljs-built_in">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>       _owner = THREAD ;<br>       _recursions = <span class="hljs-number">0</span> ;<br>       OwnerIsThread = <span class="hljs-number">1</span> ;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span><br>       <span class="hljs-comment">// in native code by throwing an exception.</span><br>       <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span><br>       <span class="hljs-built_in">TEVENT</span> (Exit - Throw IMSX) ;<br>       <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;Non-balanced monitor enter/exit!&quot;</span>);<br>       <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>          <span class="hljs-built_in">THROW</span>(vmSymbols::<span class="hljs-built_in">java_lang_IllegalMonitorStateException</span>());<br>       &#125;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">//如果当前，线程重入锁的次数，不为0，那么就重新走ObjectMonitor::exit，直到重入锁次数为0为止</span><br>   <span class="hljs-keyword">if</span> (_recursions != <span class="hljs-number">0</span>) &#123;<br>     _recursions--;        <span class="hljs-comment">// this is simple recursive enter</span><br>     <span class="hljs-built_in">TEVENT</span> (Inflated exit - recursive) ;<br>     <span class="hljs-keyword">return</span> ;<br>   &#125;<br>  ...<span class="hljs-comment">//此处省略很多代码</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">if</span> (Knob_ExitPolicy == <span class="hljs-number">0</span>) &#123;<br>      OrderAccess::<span class="hljs-built_in">release_store</span>(&amp;_owner, (<span class="hljs-type">void</span>*)<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//释放锁</span><br>      OrderAccess::<span class="hljs-built_in">storeload</span>();                        <span class="hljs-comment">// See if we need to wake a successor</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">intptr_t</span>(_EntryList)|<span class="hljs-built_in">intptr_t</span>(_cxq)) == <span class="hljs-number">0</span> || _succ != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">TEVENT</span>(Inflated exit - simple egress);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">TEVENT</span>(Inflated exit - complex egress);<br>      <span class="hljs-comment">//省略部分代码...</span><br>    &#125;<br>    <span class="hljs-comment">//省略部分代码...</span><br>    ObjectWaiter * w = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> QMode = Knob_QMode;<br>    <span class="hljs-comment">//根据QMode的模式判断，</span><br>    <span class="hljs-comment">//如果QMode == 2则直接从_cxq挂起的线程中唤醒    </span><br>    <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != <span class="hljs-literal">NULL</span>) &#123;<br>      w = _cxq;<br>      <span class="hljs-built_in">ExitEpilog</span>(Self, w);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>     <span class="hljs-comment">//省略部分代码... 省略的代码为根据QMode的不同，不同的唤醒机制</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放。在 HotSpot 中，通过退出 monitor 的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 <code>ObjectMonitor::exit</code> 方法中。</p><ul><li>判断当前锁对象中的 owner 没有指向当前线程，如果 owner 指向的 BasicLock 在当前线程栈上，那么将 _owner 指向当前线程。</li><li>如果当前锁对象中的 _owner 指向当前线程，则判断当前线程重入锁的次数，如果不为 0，继续执行 ObjectMonitor::exit()，直到重入锁次数为 0 为止。</li><li>释放当前锁，唤醒操作。根据不同的策略（由 QMode 指定），从 cxq 或 EntryList 中获取头节点，通过 <code>ObjectMonitor::ExitEpilog</code> 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成。</li></ul><p>根据 QMode 的不同 (默认为 0)，有不同的处理方式：</p><p>QMode &#x3D; 0：暂时什么都不做；<br>QMode &#x3D; 2 且 cxq 非空：取 cxq 队列队首的 ObjectWaiter 对象，调用 ExitEpilog 方法，该方法会唤醒 ObjectWaiter 对象的线程，然后立即返回，后面的代码不会执行了；<br>QMode &#x3D; 3 且 cxq 非空：把 cxq 队列插入到 EntryList 的尾部；<br>QMode &#x3D; 4 且 cxq 非空：把 cxq 队列插入到 EntryList 的头部；</p><p>只有 QMode&#x3D;2 的时候会提前返回，等于 0、3、4 的时继续执行：</p><p>1.如果 EntryList 的首元素非空，就取出来调用 ExitEpilog 方法，该方法会唤醒 ObjectWaiter 对象的线程，然后立即返回；<br>2.如果 EntryList 的首元素为空，就将 cxq 的所有元素放入到 EntryList 中，然后再从 EntryList 中取出来队首元素执行 ExitEpilog 方法，然后立即返回；<br>3.被唤醒的线程，继续竞争 monitor；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221203074915.png"></p><h2 id="3-5-wait-和-notify"><a href="#3-5-wait-和-notify" class="headerlink" title="3.5. wait 和 notify"></a>3.5. wait 和 notify</h2><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230607-2118%%</span>❕ ^shroec</p><ul><li><span style="background-color:#f0f">wait，notify 必须是持有当前对象锁 Monitor 的线程才能调用</span> (<span style="background-color:#0f0">对象锁代指 ObjectMonitor&#x2F;Monitor，锁对象代指 Object</span>)</li><li>上面有说到，当在 sychronized 中锁对象 Object 调用 wait 时会加入 waitSet 队列，WaitSet 的元素对象就是 <span style="background-color:#f0f">ObjectWaiter</span><br><strong>调用对象锁的 wait() 方法时，线程会被封装成 ObjectWaiter，最后使用 park 方法挂起，而当对象锁使用 notify() 时</strong></li><li>如果 waitSet 为空，则直接返回</li><li>waitSet 不为空从 waitSet 获取一个 ObjectWaiter，然后根据不同的 Policy 加入到 EntryList 或通过 <code>Atomic::cmpxchg_ptr</code> 指令自旋操作加入 <strong>cxq 队列</strong> 或者直接 unpark 唤醒</li><li>Object 的 notifyAll 方法则对应 <code>voidObjectMonitor::notifyAll(TRAPS)</code>，流程和 notify 类似。不过会通过 for 循环取出 WaitSet 的 ObjectWaiter 节点，再依次唤醒所有线程</li></ul><h2 id="3-6-源码分析"><a href="#3-6-源码分析" class="headerlink" title="3.6. 源码分析"></a>3.6. 源码分析</h2><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221113-从 Monitorenter 源码看 Synchronized 锁优化的过程 - 掘金]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-Java锁与线程的那些事]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221113-(三)死磕并发之深入Hotspot源码剖析Synchronized关键字实现 - 掘金]]</p><h1 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4. 锁优化"></a>4. 锁优化</h1><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221111-synchronized 实现原理 小米信息部技术团队]]</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-[博客大赛] 图文并茂!!讲解 JUC 重量级锁、轻量级锁、自旋、锁膨胀…._qq60751173d6bae 的技术博客 _51CTO 博客]]</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-Synchronized 偏向锁升级 - MaXianZhe - 博客园]]</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av70549061?p=180">https://www.bilibili.com/video/av70549061?p=180</a></p><p>事实上，只有在 JDK1.6 之前，synchronized 的实现才会直接调用 ObjectMonitor 的 enter 和 exit，这种锁被称之为重量级锁。</p><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了 <code>偏向锁</code> 和 <code>轻量级锁</code>：锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p><p>所以锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6 中默认是开启偏向锁和轻量级锁的，我们也可以通过 -XX:-UseBiasedLocking&#x3D;false 来禁用偏向锁</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230604074215.jpg" alt="image-20200131213915151"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230604074224.jpg" alt="image-20200131214209117"></p><h2 id="4-1-偏向锁"><a href="#4-1-偏向锁" class="headerlink" title="4.1. 偏向锁"></a>4.1. 偏向锁</h2><h3 id="4-1-1-优点作用-减少轻量级锁不必要的-CAS-线程-ID-的替换⭐️🔴"><a href="#4-1-1-优点作用-减少轻量级锁不必要的-CAS-线程-ID-的替换⭐️🔴" class="headerlink" title="4.1.1. 优点作用 - 减少轻量级锁不必要的 CAS 线程 ID 的替换⭐️🔴"></a>4.1.1. 优点作用 - 减少轻量级锁不必要的 CAS 线程 ID 的替换⭐️🔴</h3><p><span style="background-color:#0f0">轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</span></p><p>如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 记录该线程的 ID；当该线程再次请求锁时，无需做任何同步操作，即需要在获取锁的时候<span style="background-color:#f0f">检查一下 Mark Word 的锁标记位 &#x3D; 偏向锁 (01)，并且 threadID &#x3D; 该线程 ID 即可</span>，因此，省去了锁申请的操作。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230604074234.jpg" alt="image-20200131213740074"></p><h3 id="4-1-2-缺点问题"><a href="#4-1-2-缺点问题" class="headerlink" title="4.1.2. 缺点问题"></a>4.1.2. 缺点问题</h3><p><span style="background-color:#f0f">撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</span><br>撤销的场景很多：访问对象的 hashCode、调用 wait&#x2F;notify<br>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</p><h3 id="4-1-3-延迟偏向"><a href="#4-1-3-延迟偏向" class="headerlink" title="4.1.3. 延迟偏向"></a>4.1.3. 延迟偏向</h3><p>偏向锁模式存在偏向锁延迟机制：HotSpot 虚拟机在启动后有个 <code>4s</code> 的延迟才会对每个新建的对象开启偏向锁模式。因为 JVM 启动时会进行一系列的复杂活动，比如装载配置，系统类初始化等等。在这个过程中会使用大量 synchronized 关键字对对象加锁，且这些锁大多数都不是偏向锁。待启动完成后再延迟打开偏向锁。<br>可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，让其在程序启动时立刻启动。</p><h3 id="4-1-4-匿名偏向"><a href="#4-1-4-匿名偏向" class="headerlink" title="4.1.4. 匿名偏向"></a>4.1.4. 匿名偏向</h3><p><code>匿名偏向状态</code>：锁对象 mark word 标志位为 101，且存储的 <code>Thread ID</code> 为空 (源码中按 null 进行判断的，JOL 打印是 54 位都是 0) 时的状态 (即锁对象为偏向锁，且没有线程偏向于这个锁对象)。</p><p>为什么上述偏向锁逻辑没有判断 <strong>无锁状态的锁对象</strong>（001）？</p><p><strong>只有匿名偏向的对象才能进入偏向锁模式</strong>。偏向锁是延时初始化的，默认是 4000ms。初始化后会将所有加载的 Klass 的 prototype header 修改为匿名偏向样式。当创建一个对象时，会通过 Klass 的 prototype_header 来初始化该对象的对象头。简单的说，偏向锁初始化结束后，后续所有对象的对象头都为 <strong>匿名偏向</strong> 样式，在此之前创建的对象则为 <strong>无锁状态</strong>。而对于无锁状态的锁对象，如果有竞争，会直接进入到轻量级锁。这也是为什么 JVM 启动前 4 秒对象会直接进入到轻量级锁的原因。</p><h3 id="4-1-5-加锁流程⭐️🔴"><a href="#4-1-5-加锁流程⭐️🔴" class="headerlink" title="4.1.5. 加锁流程⭐️🔴"></a>4.1.5. 加锁流程⭐️🔴</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CASE</span>(_monitorenter): &#123;<br>  <span class="hljs-comment">// lockee 就是锁对象</span><br>  oop lockee = <span class="hljs-built_in">STACK_OBJECT</span>(<span class="hljs-number">-1</span>);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-built_in">CHECK_NULL</span>(lockee);<br>  <span class="hljs-comment">// code 1：找到一个空闲的Lock Record</span><br>  BasicObjectLock* limit = istate-&gt;<span class="hljs-built_in">monitor_base</span>();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="hljs-built_in">stack_base</span>();<br>  BasicObjectLock* entry = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-keyword">if</span> (most_recent-&gt;<span class="hljs-built_in">obj</span>() == <span class="hljs-literal">NULL</span>) entry = most_recent;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;<span class="hljs-built_in">obj</span>() == lockee) <span class="hljs-keyword">break</span>;<br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">//entry不为null，代表还有空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// code 2：将Lock Record的obj指针指向锁对象</span><br>    entry-&gt;<span class="hljs-built_in">set_obj</span>(lockee);<br>    <span class="hljs-type">int</span> success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">uintptr_t</span> epoch_mask_in_place = (<span class="hljs-type">uintptr_t</span>)markOopDesc::epoch_mask_in_place;<br>    <span class="hljs-comment">// markoop即对象头的mark word</span><br>    markOop mark = lockee-&gt;<span class="hljs-built_in">mark</span>();<br>    <span class="hljs-type">intptr_t</span> hash = (<span class="hljs-type">intptr_t</span>) markOopDesc::no_hash;<br>    <span class="hljs-comment">// code 3：如果锁对象的mark word的状态是偏向模式</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">has_bias_pattern</span>()) &#123;<br>      <span class="hljs-type">uintptr_t</span> thread_ident;<br>      <span class="hljs-type">uintptr_t</span> anticipated_bias_locking_value;<br>      thread_ident = (<span class="hljs-type">uintptr_t</span>)istate-&gt;<span class="hljs-built_in">thread</span>();<br>     <span class="hljs-comment">// code 4：这里有几步操作，下文分析</span><br>      anticipated_bias_locking_value =<br>        (((<span class="hljs-type">uintptr_t</span>)lockee-&gt;<span class="hljs-built_in">klass</span>()-&gt;<span class="hljs-built_in">prototype_header</span>() | thread_ident) ^ (<span class="hljs-type">uintptr_t</span>)mark) &amp;<br>        ~((<span class="hljs-type">uintptr_t</span>) markOopDesc::age_mask_in_place);<br>     <span class="hljs-comment">// code 5：如果偏向的线程是自己且epoch等于class的epoch</span><br>      <span class="hljs-keyword">if</span>  (anticipated_bias_locking_value == <span class="hljs-number">0</span>) &#123;<br>        <br>      &#125;<br>       <span class="hljs-comment">// code 6：如果偏向模式关闭，则尝试撤销偏向锁</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>        <br>      &#125;<br>         <span class="hljs-comment">// code 7：如果epoch不等于class中的epoch，则尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 构造一个偏向当前线程的mark word</span><br>        <br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）</span><br>        <span class="hljs-comment">// code 8：下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word</span><br>        markOop header = (markOop) ((<span class="hljs-type">uintptr_t</span>) mark &amp; ((<span class="hljs-type">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="hljs-type">uintptr_t</span>)markOopDesc::age_mask_in_place |epoch_mask_in_place));<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          header = header-&gt;<span class="hljs-built_in">copy_set_hash</span>(hash);<br>        &#125;<br>        markOop new_header = (markOop) ((<span class="hljs-type">uintptr_t</span>) header | thread_ident);<br>        <span class="hljs-comment">// debugging hint</span><br>        <span class="hljs-built_in">DEBUG_ONLY</span>(entry-&gt;<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">set_displaced_header</span>((markOop) (<span class="hljs-type">uintptr_t</span>) <span class="hljs-number">0xdeaddead</span>);)<br>        <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>((<span class="hljs-type">void</span>*)new_header, lockee-&gt;<span class="hljs-built_in">mark_addr</span>(), header) == header) &#123;<br>           <span class="hljs-comment">// CAS修改成功</span><br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (* BiasedLocking::<span class="hljs-built_in">anonymously_biased_lock_entry_count_addr</span>())++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果修改失败说明存在多线程竞争，所以进入monitorenter方法</span><br>          <span class="hljs-built_in">CALL_VM</span>(InterpreterRuntime::<span class="hljs-built_in">monitorenter</span>(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁的逻辑</span><br>      <span class="hljs-comment">//code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它</span><br>      markOop displaced = lockee-&gt;<span class="hljs-built_in">mark</span>()-&gt;<span class="hljs-built_in">set_unlocked</span>();<br>      entry-&gt;<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">set_displaced_header</span>(displaced);<br>      <span class="hljs-comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span><br>      <span class="hljs-type">bool</span> call_vm = UseHeavyMonitors;<br>      <span class="hljs-comment">// 利用CAS将对象头的mark word替换为指向Lock Record的指针</span><br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="hljs-built_in">mark_addr</span>(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;<span class="hljs-built_in">is_lock_owned</span>((address) displaced-&gt;<span class="hljs-built_in">clear_lock_bits</span>())) &#123;        <span class="hljs-comment">//code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null</span><br>          entry-&gt;<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">set_displaced_header</span>(<span class="hljs-literal">NULL</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">CALL_VM</span>(InterpreterRuntime::<span class="hljs-built_in">monitorenter</span>(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// lock record不够，重新执行</span><br>    istate-&gt;<span class="hljs-built_in">set_msg</span>(more_monitors);<br>    <span class="hljs-built_in">UPDATE_PC_AND_RETURN</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>偏向锁的获取一定是从 <code>匿名偏向</code> 状态开始，然后 <code>偏向</code> 到某一个线程。</p><ol><li>从当前线程的栈中找到一个空闲的 Lock Record（即代码中的 BasicObjectLock，下文都用 Lock Record 代指），判断 Lock Record 是否空闲的依据是其 obj 字段是否为 null。注意这里是按内存地址从低往高找到最后一个可用的 Lock Record，换而言之，就是找到内存地址最高的可用 Lock Record。</li><li>获取到 Lock Record 后，首先要做的就是为其 obj 字段赋值。</li><li>判断锁对象的 mark word 是否是<span style="background-color:#f0f">偏向模式，即低 3 位是否为 101</span>。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202074605.png"></p><p><span style="background-color:#f0f">5. <code>CAS</code> 将偏向线程 id 改为当前线程 id，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。</span><br><span style="background-color:#f0f">6. 若对象头 mark word 显示存储 thread id 为当前线程 id，表明这是一次锁重入操作，会向当前线程的栈帧中 <code>添加一条 displaced mark word 为空的 lock record 记录</code>（与轻量级锁记录重入记录原理相同）。</span><br>7. 若对象头 mark word 显示已存储其它 thread id，表明该锁对象已偏向其它线程，进入偏向锁撤销流程。等待 safepoint 检查偏向线程是否存活（遍历 jvm 线程栈检查），若偏向线程存活且还在执行同步代码块则进入升级轻量锁流程，否则将对象头 mark word 置为无锁 mark word，进入升级轻量级锁流程。</p><p><code>即不论偏向线程是否存活，只要该锁对象偏向过一个非当前线程的线程，在当前线程访问时一定会升级为轻量级锁。</code></p><p><strong>CAS 获取偏向锁的过程中存在并发冲突</strong>||<strong>已偏向其他线程</strong>||<strong>epoch 值过期</strong>||<strong>class 偏向模式关闭</strong>，都会进入到 <code>InterpreterRuntime::monitorenter</code> 方法， 在该方法中会进行偏向锁撤销和升级。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202065119.png"></p><p><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a><br><a target="_blank" rel="noopener" href="http://northsea.top/?p=195#3-%E5%81%8F%E5%90%91%E9%94%81">http://northsea.top/?p=195#3-%E5%81%8F%E5%90%91%E9%94%81</a></p><h3 id="4-1-6-撤销流程"><a href="#4-1-6-撤销流程" class="headerlink" title="4.1.6. 撤销流程"></a>4.1.6. 撤销流程</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/FraserYu/p/15743542.html">https://www.cnblogs.com/FraserYu/p/15743542.html</a></p><p><span style="background-color:#f0f">撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态</span><br>偏向锁的 <code>撤销</code>（revoke）是一个很特殊的操作，为了执行撤销操作，需要等待 <code>全局安全点</code>，此时所有的工作线程都停止了执行。偏向锁的撤销操作并不是将对象恢复到无锁可偏向的状态，而是在偏向锁的获取过程中，发现竞争时，直接将一个被偏向的对象 <code>升级到</code> 被加了 <code>轻量级锁</code> 的状态。</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/juniorMa/articles/13845491.html">https://www.cnblogs.com/juniorMa/articles/13845491.html</a><br><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6977744259688939551#heading-4">https://juejin.cn/post/6977744259688939551#heading-4</a></p><ul><li>查看偏向的线程是否存活，如果已经不存活了，则直接撤销偏向锁。JVM 维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活 [[性能调优专题-基础-1、Java-相关名词#线程集合]]。</li><li>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行 <code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的 <code>Lock Record</code>，将其 obj 字段指向锁对象。每次解锁（即执行 <code>monitorexit</code>）的时候都会将最低的一个相关 <code>Lock Record</code> 移除掉。所以可以通过遍历线程栈中的 <code>Lock Record</code> 来判断线程是否还在同步块中。</li><li>将偏向线程所有相关 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 设置为 null，然后将最高位的 <code>Lock Record</code> 的 <code>Displaced Mark Word</code> 设置为无锁状态，最高位的 <code>Lock Record</code> 也就是第一次获得锁时的 <code>Lock Record</code>（这里的第一次是指重入获取锁时的第一次），然后将对象头指向最高位的 <code>Lock Record</code>，这里不需要用 CAS 指令，因为是在 <code>safepoint</code>。 执行完后，就升级成了轻量级锁。原偏向线程的所有 Lock Record 都已经变成轻量级锁的状态。</li></ul><p>　　总结下上面原作者的话：</p><p>　　1 如果原来的线程不存活了，锁对象变成无锁状态，方法 return。这样，ThreadB 就能进入 slow_enter 了。slow_enter 就是获取轻量级锁，获取不到才是锁膨胀。</p><p>　　2 如果原线程存在，这是要构造一个无锁状态的 mark word，放到最开始的那个 Lock Record 里。这是因为此时要进行轻量级锁升级，轻量级锁释放就会把 Lock record 里的 mark word 写回对象头里。</p><p>　　  那么原线程直接获取该轻量级锁，同时 ThreadB 还是进入 slow_enter，参与到轻量级锁的竞争</p><h3 id="4-1-7-释放流程"><a href="#4-1-7-释放流程" class="headerlink" title="4.1.7. 释放流程"></a>4.1.7. 释放流程</h3><p>锁释放是指线程执行完毕，退出同步代码块。偏向锁的释放并不是偏向锁的撤销，对象头还是偏向锁。most_recent-&gt;set_obj(NULL); 这就是释放偏向锁，其实啥也没干。还要把这条 LockRecord 删除掉 每次解锁（即执行 <code>monitorexit</code>）的时候都会将最低的一个相关 <code>Lock Record</code> 移除掉。</p><p>偏向锁的释放可参考 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923">bytecodeInterpreter.cpp#1923</a>，这里也不贴了。偏向锁的释放只要将对应 <code>Lock Record</code> 释放就好了，但这里的释放并不会将 mark word 里面的 thread ID 去掉，这样做是为了下一次更方便的加锁。而轻量级锁则需要将 <code>Displaced Mark Word</code> 替换到对象头的 mark word 中。如果 CAS 失败或者是重量级锁则进入到 <code>InterpreterRuntime::monitorexit</code> 方法中。</p><h3 id="4-1-8-锁重入"><a href="#4-1-8-锁重入" class="headerlink" title="4.1.8. 锁重入"></a>4.1.8. 锁重入</h3><p>该线程 ID 是自己的,则表示可重入,直接可以获取 (此时在自己的线程栈中继续生成一条新的 Lock Record)</p><h3 id="4-1-9-其他撤销"><a href="#4-1-9-其他撤销" class="headerlink" title="4.1.9. 其他撤销"></a>4.1.9. 其他撤销</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/father-of-little-pig/p/16314318.html">https://www.cnblogs.com/father-of-little-pig/p/16314318.html</a><br>状态跟踪<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162218.png"></p><h4 id="4-1-9-1-偏向锁撤销之调用对象-HashCode"><a href="#4-1-9-1-偏向锁撤销之调用对象-HashCode" class="headerlink" title="4.1.9.1. 偏向锁撤销之调用对象 HashCode"></a>4.1.9.1. 偏向锁撤销之调用对象 HashCode</h4><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230604-0833%%</span>❕ ^6jfu5x</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162016.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162033.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162047.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162101.png"></p><h5 id="4-1-9-1-1-为什么调用-hashcode-会撤销偏向锁"><a href="#4-1-9-1-1-为什么调用-hashcode-会撤销偏向锁" class="headerlink" title="4.1.9.1.1. 为什么调用 hashcode 会撤销偏向锁"></a>4.1.9.1.1. 为什么调用 hashcode 会撤销偏向锁</h5><p>[[20221112-Java GC详解 - 最全面的理解Java对象结构 - 对象指针 OOPs HeapDump性能社区#^jy0jkr]]</p><h5 id="4-1-9-1-2-hashcode-存储位置"><a href="#4-1-9-1-2-hashcode-存储位置" class="headerlink" title="4.1.9.1.2. hashcode 存储位置"></a>4.1.9.1.2. hashcode 存储位置</h5><h4 id="4-1-9-2-偏向锁撤销之调用-wait-x2F-notify"><a href="#4-1-9-2-偏向锁撤销之调用-wait-x2F-notify" class="headerlink" title="4.1.9.2. 偏向锁撤销之调用 wait&#x2F;notify"></a>4.1.9.2. 偏向锁撤销之调用 wait&#x2F;notify</h4><p>偏向锁状态执行 obj.notify() 会升级为轻量级锁，调用 obj.wait(timeout) 会升级为重量级锁</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162326.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112162346.png"></p><h3 id="4-1-10-批量重偏向和批量撤销"><a href="#4-1-10-批量重偏向和批量撤销" class="headerlink" title="4.1.10. 批量重偏向和批量撤销"></a>4.1.10. 批量重偏向和批量撤销</h3><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;偏向锁理论太抽象，实战了解下偏向锁如何发生以及如何升级【实战篇】 - 掘金]]</p><p>撤销偏向和重偏向都是 <code>以类为单位批量</code> 进行的<br>依赖三个阈值作出判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 批量重偏向阈值 <br>-XX:BiasedLockingBulkRebiasThreshold=20 <br># 重置计数的延迟时间 <br>-XX:BiasedLockingDecayTime=25000 <br># 批量撤销阈值 <br>-XX:BiasedLockingBulkRevokeThreshold=40<br></code></pre></td></tr></table></figure><p>简单总结，对于 <strong>一个类</strong>，按默认参数来说：<br><strong>单个偏向撤销的计数达到 20，就会进行批量重偏向。<br>距上次批量重偏向 25 秒内，计数达到 40，就会发生批量撤销。</strong><br>每隔 (&gt;&#x3D;) 25 秒，会重置在 [20, 40) 内的计数为 0，这意味着可以发生多次批量重偏向。</p><p>注意：对于一个类来说，批量撤销只能发生一次，因为批量撤销后，该类禁用了可偏向属性，后面该类的对象都是不可偏向的，包括新创建的对象。</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-[博客大赛] 图文并茂!!讲解 JUC 重量级锁、轻量级锁、自旋、锁膨胀…._qq60751173d6bae 的技术博客 _51CTO 博客]]</p><h3 id="4-1-11-源码解析"><a href="#4-1-11-源码解析" class="headerlink" title="4.1.11. 源码解析"></a>4.1.11. 源码解析</h3><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-死磕Synchronized底层实现–偏向锁-Java知音]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-Java锁与线程的那些事]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-Synchronized 偏向锁升级 - MaXianZhe - 博客园]]</p><h2 id="4-2-轻量级锁"><a href="#4-2-轻量级锁" class="headerlink" title="4.2. 轻量级锁"></a>4.2. 轻量级锁</h2><h3 id="4-2-1-概念作用-多个线程交替执行⭐️🔴"><a href="#4-2-1-概念作用-多个线程交替执行⭐️🔴" class="headerlink" title="4.2.1. 概念作用 - 多个线程交替执行⭐️🔴"></a>4.2.1. 概念作用 - 多个线程交替执行⭐️🔴</h3><p>轻量级锁是 JDK 6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。<br>引入轻量级锁的目的：在 <code>多线程交替执行同步块的情况下</code>，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p><h3 id="4-2-2-加锁流程-轻量级锁加锁及锁膨胀⭐️🔴⭐️🔴"><a href="#4-2-2-加锁流程-轻量级锁加锁及锁膨胀⭐️🔴⭐️🔴" class="headerlink" title="4.2.2. 加锁流程 - 轻量级锁加锁及锁膨胀⭐️🔴⭐️🔴"></a>4.2.2. 加锁流程 - 轻量级锁加锁及锁膨胀⭐️🔴⭐️🔴</h3><p><a target="_blank" rel="noopener" href="https://www.javazhiyin.com/24364.html">https://www.javazhiyin.com/24364.html</a><br><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a><br><a target="_blank" rel="noopener" href="https://dandelioncloud.cn/article/details/1403089140002131970">https://dandelioncloud.cn/article/details/1403089140002131970</a></p><p>HotSpot 中偏向锁的具体实现可参考 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816">bytecodeInterpreter.cpp#1816</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202101854.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112085951.jpg"></p><p><span style="background-color:#f0f">多个线程竞争偏向锁导致偏向锁升级为轻量级锁</span></p><ol><li>JVM 在当前线程的栈帧中创建 Lock Reocrd，<span style="background-color:#f0f">将内部 obj （ptr_to_obj）指针指向锁对像</span>。然后构造一个无锁状态的 Mark Word(相当于<span style="background-color:#f0f">复制无锁状态的 Mark Word 到锁记录中</span>)，并将 lock record 中的 Displaced Mark Word 指向它。（Displaced Mark Word，供解锁时恢复锁对象对象头）</li><li><span style="background-color:#f0f">线程尝试使用 CAS 将对象头中的 Mark Word 中的 ptr_to_lock_record(指向栈中锁记录的指针) 替换为 上面第一步刚在栈中创建的 Lock Reocrd 的指针。如果成功则获得锁</span></li><li>CAS 失败时判断检查已获取轻量级锁线程是否为自己（遍历栈帧查找其它 obj* 指向同个对象且 mark word 不为空的 lock record），如果是则代表当前为一次锁重入，就将当前 lock record 的 mark word （displaced mark word）置为 null(上面第一步设置的)，即当前 lock record 即作为一个计数器使用，结束。</li><li>若 CAS 失败且当前线程栈帧中不存在其它指向该锁对象的 lock record，说明存在其它线程竞争，锁膨胀至重量级锁。</li></ol><p>Mark Word 布局温习</p><a href="/2022/11/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-1%E3%80%81%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/" title="对象创建-1、对象内存">对象创建-1、对象内存</a><h3 id="4-2-3-解锁流程"><a href="#4-2-3-解锁流程" class="headerlink" title="4.2.3. 解锁流程"></a>4.2.3. 解锁流程</h3><p><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a><br><a target="_blank" rel="noopener" href="https://dandelioncloud.cn/article/details/1403089140002131970">https://dandelioncloud.cn/article/details/1403089140002131970</a></p><p>轻量级锁释放的入口在 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923">bytecodeInterpreter.cpp#1923</a>。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221113125337.png"></p><ol><li>遍历线程栈帧，找多所有 obj* 指向该锁对象的 lock record。</li><li>如果 lock record 的 displaced mark word 为 null，代表这是一条重入所记录，将 obj 置为 null 后 continue。</li><li>如果 lock record 的 displaced mark word 不为 null，则利用 <code>CAS 操作</code> 将锁对象对象头的 mark word 恢复成 displaced mark word，这一步成功则说明解锁成功，失败则膨胀至重量锁。</li></ol><p>轻量级锁释放时需要将 <code>Displaced Mark Word</code> <span style="background-color:#f0f">替换到</span>对象头的 <code>mark word</code> 中。如果 CAS 失败或者是重量级锁则进入到 <code>InterpreterRuntime::monitorexit</code> 方法中。</p><h3 id="4-2-4-优点"><a href="#4-2-4-优点" class="headerlink" title="4.2.4. 优点"></a>4.2.4. 优点</h3><p>正常交替流程<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202142955.png"></p><p>其性能提升的依据是对于绝大部分的锁在整个生命周期内都是不会存在竞争。在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p><h3 id="4-2-5-缺点⭐️🔴"><a href="#4-2-5-缺点⭐️🔴" class="headerlink" title="4.2.5. 缺点⭐️🔴"></a>4.2.5. 缺点⭐️🔴</h3><p>在有多线程竞争的情况下轻量级锁增加了额外开销。</p><h3 id="4-2-6-锁重入"><a href="#4-2-6-锁重入" class="headerlink" title="4.2.6. 锁重入"></a>4.2.6. 锁重入</h3><p>轻量级锁在拷贝 mark word 到线程栈 Lock Record 中时，如果有重入锁，则在线程栈中继续压栈 Lock Record 记录，只不过 mark word 的值为空，等到解锁后，依次弹出，最终将 mard word 恢复到对象头中，如图所示</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112135554.png"></p><p>[[20221111-轻量级锁（锁重入的实现方式）-蒲公英云]]<br>[[Java锁与线程状态的那些事.pdf]]</p><h3 id="4-2-7-源码"><a href="#4-2-7-源码" class="headerlink" title="4.2.7. 源码"></a>4.2.7. 源码</h3><p><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a><br>[[轻量级锁加锁 &amp; 解锁过程 gorden5566]]<br>[[轻量级锁（锁重入的实现方式）-蒲公英云]]</p><h2 id="4-3-自旋锁"><a href="#4-3-自旋锁" class="headerlink" title="4.3. 自旋锁"></a>4.3. 自旋锁</h2><blockquote><p>线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。<br>何谓自旋锁？<br>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br><span style="background-color:#f0f">自旋锁在 JDK 1.4.2 中引入，默认关闭，但是可以使用 -XX:+UseSpinning 开开启，在 JDK1.6 中默认开启。同时自旋的默认次数为 10 次，可以通过参数 -XX:PreBlockSpin 来调整；</span><br>如果通过参数 -XX:preBlockSpin 来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为 10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是 JDK1.6 引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p></blockquote><p><strong>适应自旋锁</strong></p><blockquote><p>JDK 1.6 引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p></blockquote><h2 id="4-4-锁消除"><a href="#4-4-锁消除" class="headerlink" title="4.4. 锁消除"></a>4.4. 锁消除</h2><blockquote><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM 检测到不可能存在共享数据竞争，这是 JVM 会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些 JDK 的内置 API 时，如 StringBuffer、Vector、HashTable 等，这个时候会存在隐形的加锁操作。比如 StringBuffer 的 append() 方法，Vector 的 add() 方法：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">vectorTest</span><span class="hljs-params">()</span></span>&#123;<br>     Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>&lt;String&gt;();<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;<br>         vector.<span class="hljs-built_in">add</span>(i + <span class="hljs-string">&quot;&quot;</span>);<br>     &#125;<br> <br>     System.out.<span class="hljs-built_in">println</span>(vector);<br> &#125;<br></code></pre></td></tr></table></figure><p>在运行这段代码时，JVM 可以明显检测到变量 vector 没有逃逸出方法 vectorTest() 之外，所以 JVM 可以大胆地将 vector 内部的加锁操作消除。</p><h2 id="4-5-锁粗化"><a href="#4-5-锁粗化" class="headerlink" title="4.5. 锁粗化"></a>4.5. 锁粗化</h2><blockquote><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>在大多数的情况下，上述观点是正确的，LZ 也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。</p></blockquote><h2 id="4-6-应用场景"><a href="#4-6-应用场景" class="headerlink" title="4.6. 应用场景"></a>4.6. 应用场景</h2><ul><li>偏向锁 : 偏向锁适合在只有一个线程访问锁的场景,在此种场景下,线程只需要执行一次 CAS 获取偏向锁,后续该线程可重入访问该锁时仅仅只需要简单的判断 Mark Word 的线程 ID 即可</li><li>轻量级锁 : 轻量级锁适用于线程交替执行同步块的场景,绝大部分的锁在整个同步周期内都不存在长时间的竞争,此种场景下,线程每次获取锁只需要执行一次 CAS 即可</li><li>重量级锁 : 重量级锁适合在多线程竞争环境下访问锁,执行临界区的时间比较长,由于竞争激烈,自旋后未获取到锁的线程将会被挂起进入等待队列,等待持有锁的线程释放锁后唤醒它.此种场景下,线程每次都需要进行多次 CAS 操作,操作失败将会被放入队列里等待唤醒.</li></ul><h1 id="5-锁升级"><a href="#5-锁升级" class="headerlink" title="5. 锁升级"></a>5. 锁升级</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230604074200.jpg" alt="image-20200129142133191"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112130237.png"></p><p>无锁是锁升级前的一个中间态，必须要恢复到无锁才能进行升级，因为需要有拷贝 mark word 的过程，并且修改指针。</p><p><code>思考1：重量级锁释放之后变为无锁，此时有新的线程来调用同步块，会获取什么锁？</code></p><blockquote><p>通过实验可以得出，后面的线程会获得轻量级锁，相当于线程竞争不激烈，多个线程通过 CAS 就能轮流获取锁，并且释放。</p></blockquote><p><a target="_blank" rel="noopener" href="https://img2022.cnblogs.com/blog/1765702/202205/1765702-20220529150327464-184883137.png"><img src="https://img2022.cnblogs.com/blog/1765702/202205/1765702-20220529150327464-184883137.png"></a></p><p><code>思考2：为什么有轻量级锁还需要重量级锁？</code></p><blockquote><p>因为轻量级锁时通过 CAS 自旋的方式获取锁，该方式消耗 CPU 资源的，如果锁的时间长，或者自旋线程多，CPU 会被大量消耗；而重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗 CPU 资源。</p></blockquote><p><code>思考3：偏向锁是否一定比轻量级锁效率高吗？</code></p><blockquote><p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，需要暂停线程，回到安全点，并检查线程是否活着，故撤销需要消耗性能，这时候直接使用轻量级锁。<br>JVM 启动过程，会有很多线程竞争，所以默认情况启动时不打开偏向锁，过一段儿时间再打开。</p></blockquote><h2 id="5-1-锁记录-LockRecord"><a href="#5-1-锁记录-LockRecord" class="headerlink" title="5.1. 锁记录 ( LockRecord)"></a>5.1. 锁记录 ( LockRecord)</h2><p>线程栈的栈帧中，可以有多个 LockRecord</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112085951.jpg"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221112084915.jpg"></p><p>[[20221111-Synchronized 探秘 - 软件即世界]]</p><h2 id="5-2-锁对象-ObjectRef"><a href="#5-2-锁对象-ObjectRef" class="headerlink" title="5.2. 锁对象 (ObjectRef)"></a>5.2. 锁对象 (ObjectRef)</h2><p><a href="#2-1-1-%E4%B8%89%E7%A7%8D%E9%94%81%E7%B1%BB%E5%9E%8B">作为锁的对象</a></p><h2 id="5-3-对象锁-ObjectMonitor"><a href="#5-3-对象锁-ObjectMonitor" class="headerlink" title="5.3. 对象锁 (ObjectMonitor)"></a>5.3. 对象锁 (ObjectMonitor)</h2><p><a href="#2-3-1-ObjectMonitor">ObjectMonitor</a></p><h2 id="5-4-升级图示"><a href="#5-4-升级图示" class="headerlink" title="5.4. 升级图示"></a>5.4. 升级图示</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221113123434.png"></p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221112-[博客大赛] 图文并茂!!讲解 JUC 重量级锁、轻量级锁、自旋、锁膨胀…._qq60751173d6bae 的技术博客 _51CTO 博客]]</p><h2 id="5-5-锁升级原理-流程-⭐️🔴⭐️🔴"><a href="#5-5-锁升级原理-流程-⭐️🔴⭐️🔴" class="headerlink" title="5.5. 锁升级原理 (流程)⭐️🔴⭐️🔴"></a>5.5. 锁升级原理 (流程)⭐️🔴⭐️🔴</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221202103858.png"></p><p>Synchronized 在 jdk1.6 版本之前，是通过重量级锁的方式来实现线程之间锁的竞争。之所以称它为重量级锁，是因为它的底层底层依赖操作系统的 <code>Mutex Lock</code> 来实现互斥功能。 Mutex 是系统方法，由于权限隔离的关系，应用程序调用系统方法时需要切换到内核态来执行。这里涉及到用户态向内核态的切换，这个切换会带来性能的损耗。</p><p>在 jdk1.6 版本中，synchronized 增加了锁升级的机制，来平衡数据安全性和性能。简单来说，就是线程去访问 synchronized 同步代码块的时候，synchronized 根据线程竞争情况，会先尝试在不加重量级锁的情况下去保证线程安全性。所以引入了偏向锁和轻量级锁的机制。</p><p>偏向锁，就是直接把当前锁偏向于某个线程，简单来说就是通过 CAS 修改偏向锁标记，这种锁适合同一个线程多次去申请同一个锁资源并且没有其他线程竞争的场景。<br>轻量级锁也可以称为自旋锁，基于自适应自旋的机制，通过多次自旋重试去竞争锁。自旋锁优点在于它避免避免了用户态到内核态的切换带来的性能开销。</p><p>Synchronized 引入了锁升级的机制之后，如果有线程去竞争锁： 首先，synchronized 会尝试使用偏向锁的方式去竞争锁资源，如果能够竞争到偏向锁，表示加锁成功直接返回。</p><p>如果竞争锁失败，说明当前锁已经偏向了其他线程。需要将锁升级到轻量级锁，在轻量级锁状态下，竞争锁的线程根据自适应自旋次数去尝试抢占锁资源，如果在轻量级锁状态下还是没有竞争到锁，就只能升级到重量级锁<br>在重量级锁状态下，没有竞争到锁的线程就会被阻塞，线程状态是 Blocked。处于锁等待状态的线程需要等待获得锁的线程来触发唤醒。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230604120233.png" alt="image.png"></p><p>总的来说，Synchronized 的锁升级的设计思想，在我看来本质上是一种性能和 安全性的平衡，也就是如何在不加锁的情况下能够保证线程安全性。 这种思想在编程领域比较常见，比如 Mysql 里面的 MVCC 使用版本链的方式来 解决多个并行事务的竞争问题。</p><h1 id="6-为什么要废弃偏向锁"><a href="#6-为什么要废弃偏向锁" class="headerlink" title="6. 为什么要废弃偏向锁"></a>6. 为什么要废弃偏向锁</h1><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221110-你知道 Java 的偏向锁被废弃掉了吗？_杏仁技术站的博客-CSDN博客]]</p><p>在 Java15 后默认禁用偏向锁可能会导致一些 Java 应用的性能下降，所以 HotSpot 提供了显示开启偏向锁的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 在 Java15 后，手动开启偏向锁在启动的时候会收到警告信息-XX:+UseBiasedLocking<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/916746#slide-8">https://developer.aliyun.com/article/916746#slide-8</a></p><h1 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221113184722.png"></p><h1 id="8-实战经验"><a href="#8-实战经验" class="headerlink" title="8. 实战经验"></a>8. 实战经验</h1><h2 id="8-1-减少-synchronized-的范围"><a href="#8-1-减少-synchronized-的范围" class="headerlink" title="8.1. 减少 synchronized 的范围"></a>8.1. 减少 synchronized 的范围</h2><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (Demo01.class) &#123;<br>  System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-降低-synchronized-锁的粒度"><a href="#8-2-降低-synchronized-锁的粒度" class="headerlink" title="8.2. 降低 synchronized 锁的粒度"></a>8.2. 降低 synchronized 锁的粒度</h2><p>将一个锁拆分为多个锁提高并发度</p><h2 id="8-3-读写分离"><a href="#8-3-读写分离" class="headerlink" title="8.3. 读写分离"></a>8.3. 读写分离</h2><p>读取时不加锁，写入和删除时加锁<br>ConcurrentHashMap，CopyOnWriteArrayList 和 ConyOnWriteSet</p><h2 id="8-4-常见错误"><a href="#8-4-常见错误" class="headerlink" title="8.4. 常见错误"></a>8.4. 常见错误</h2><h3 id="8-4-1-synchronized-new-Object"><a href="#8-4-1-synchronized-new-Object" class="headerlink" title="8.4.1. synchronized (new Object())"></a>8.4.1. synchronized (new Object())</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">synchronized (new Object())<br></code></pre></td></tr></table></figure><p>每次调用创建的是不同的锁，相当于无锁</p><h3 id="8-4-2-synchronized-享元"><a href="#8-4-2-synchronized-享元" class="headerlink" title="8.4.2. synchronized (享元)"></a>8.4.2. synchronized (享元)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">private Integer count;<br>synchronized (count)<br></code></pre></td></tr></table></figure><p>String，Boolean 在实现了都用了享元模式，即值在一定范围内，对象是同一个。所以看似是用了不同的对象，其实用的是同一个对象。会导致一个锁被多个地方使用</p><h3 id="8-4-3-正确的加锁姿势"><a href="#8-4-3-正确的加锁姿势" class="headerlink" title="8.4.3. 正确的加锁姿势"></a>8.4.3. 正确的加锁姿势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 普通对象锁<br>private final Object lock = new Object();<br>// 静态对象锁<br>private static final Object lock = new Object();<br></code></pre></td></tr></table></figure><h1 id="9-源码入口"><a href="#9-源码入口" class="headerlink" title="9. 源码入口"></a>9. 源码入口</h1><p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/13">https://github.com/farmerjohngit/myblog/issues/13</a><br>偏向锁入口，肯定是要在源码中找到对 <code>monitorenter</code> 指令解析的地方。在 HotSpot 的中有两处地方对 <code>monitorenter</code> 指令进行解析：一个是在 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816">bytecodeInterpreter.cpp#1816</a> ，另一个是在 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/cpu/x86/vm/templateTable_x86_64.cpp#l3667">templateTable_x86_64.cpp#3667</a>。其中，<code>bytecodeInterpreter</code> 是 JVM 中的字节码解释器， <code>templateInterpreter</code> 为模板解释器。HotSpot 对运行效率有着极其执着的追求，显然会倾向于用模板解释器来实现。R 大的 <a target="_blank" rel="noopener" href="https://book.douban.com/annotation/31407691/">读书笔记</a> 中有说明，HotSpot 中只用到了模板解释器，并没有用到字节码解释器。因此，本文认为 <code>montorenter</code> 的解析入口为 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/cpu/x86/vm/templateTable_x86_64.cpp#l3667">templateTable_x86_64.cpp#3667</a>。但模板解释器 <code>templateInterpreter</code> 都是汇编代码，不易读，且实现逻辑与字节码解释器 <code>bytecodeInterpreter</code> 大体一致。因此本文的源码都以 <code>bytecodeInterpreter</code> 来说明，借此窥探 <code>synchronized</code> 的实现原理。</p><h1 id="10-面试题"><a href="#10-面试题" class="headerlink" title="10. 面试题"></a>10. 面试题</h1><h2 id="10-1-wait-和-notify-这个为什么要在-synchronized-代码块中"><a href="#10-1-wait-和-notify-这个为什么要在-synchronized-代码块中" class="headerlink" title="10.1. wait 和 notify 这个为什么要在 synchronized 代码块中"></a>10.1. wait 和 notify 这个为什么要在 synchronized 代码块中</h2><p>在多线程里面，要实现多个线程之间的通信，除了<span style="background-color:#f0f">管道流</span>以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修改过了共享变量 s，否则就需要等待。同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。所以要在这种特性下要去实现线程之间的通信，就<span style="background-color:#f0f">必须要有一个竞争条件</span>控制线程在什么条件下等待，什么条件下唤醒。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230607210753.png" alt="image.png"></p><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。<br>所以这也是为什么 wait&#x2F;notify 需要放在 Synchronized 同步代码块中的原因，有了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。<br>另外，为了避免 wait&#x2F;notify 的错误使用，jdk 强制要求把 wait&#x2F;notify 写在同步代码块里面，否则会抛出 IllegalMonitorStateException<br>最后，基于 wait&#x2F;notify 的特性，非常适合实现生产者消费者的模型，比如说用 wait&#x2F;notify 来实现连接池就绪前的等待与就绪后的唤醒。</p><p>wait 和 notify 的实现逻辑：<a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/" title="并发基础-2、Synchronized">并发基础-2、Synchronized</a></p><h3 id="10-1-1-管道流"><a href="#10-1-1-管道流" class="headerlink" title="10.1.1. 管道流"></a>10.1.1. 管道流</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qlqwjy/p/10118733.html">https://www.cnblogs.com/qlqwjy/p/10118733.html</a><br>在 Java 语言中提供了各种各样的输入&#x2F;输出流 Stream, 使我们能够方便地对数据进行操作，其中管道流 (pipeStream) 是一种特殊的流，用于在不同线程间直接传送数据。一个发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无需借助于临时文件之类的动西。</p><p>　　在 Java 的 JDK 中提供了 4 个类来使线程间可以通信:</p><p>　　(1)PipedInputStream 和 PipedOutputStream</p><p>　　(2)PipedReader 和 PipedWriter</p><h1 id="11-参考与感谢"><a href="#11-参考与感谢" class="headerlink" title="11. 参考与感谢"></a>11. 参考与感谢</h1><h2 id="11-1-黑马"><a href="#11-1-黑马" class="headerlink" title="11.1. 黑马"></a>11.1. 黑马</h2><h3 id="11-1-1-视频"><a href="#11-1-1-视频" class="headerlink" title="11.1.1. 视频"></a>11.1.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av70549061?p=180">https://www.bilibili.com/video/av70549061?p=180</a></p><h2 id="11-2-其他"><a href="#11-2-其他" class="headerlink" title="11.2. 其他"></a>11.2. 其他</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c37377351882525ec200f9e">https://juejin.im/post/5c37377351882525ec200f9e</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5367116.html">https://www.cnblogs.com/paddix/p/5367116.html</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903918653145102">https://juejin.cn/post/6844903918653145102</a><br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221109-Synchronized解析——如果你愿意一层一层剥开我的心 - 掘金]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221110-由Java 15废弃偏向锁，谈谈Java Synchronized 的锁机制 - Yano_nankai - 博客园]]</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV168411e7wr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV168411e7wr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/qieshuyuni/ws3p3g/ai3b4s">https://www.yuque.com/qieshuyuni/ws3p3g/ai3b4s</a></p><p>✅ <a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a></p><p>：[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;20221111-(三)死磕并发之深入Hotspot源码剖析Synchronized关键字实现 - 掘金]]</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6995156191286394888">https://juejin.cn/post/6995156191286394888</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/46a874d52b71">https://www.jianshu.com/p/46a874d52b71</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/father-of-little-pig/p/16314318.html">https://www.cnblogs.com/father-of-little-pig/p/16314318.html</a></p><p>源码 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.hpp">https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/runtime/objectMonitor.hpp</a><br><a target="_blank" rel="noopener" href="http://60.205.225.95/?p=49">http://60.205.225.95/?p=49</a></p><h2 id="11-3-源码分析"><a href="#11-3-源码分析" class="headerlink" title="11.3. 源码分析"></a>11.3. 源码分析</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7104638789456232478#heading-12">https://juejin.cn/post/7104638789456232478#heading-12</a><br><a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2020/03/24/synchronized/">https://xiaomi-info.github.io/2020/03/24/synchronized/</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6977744259688939551#heading-9">https://juejin.cn/post/6977744259688939551#heading-9</a><br><a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/</a></p><p>应用：[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;(二)深入理解Java并发编程之Synchronized关键字实现原理剖析 - 简书]]</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/">https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/952" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发编程专题-基础-1、JMM与MESI</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-8%E3%80%81HashMap%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96/"><img class="next-cover" src="https://picsum.photos/1920/912" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础-集合框架-8、HashMap版本变化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/10/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-6%E3%80%81CAS/" title="并发编程专题-基础-6、CAS"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">并发编程专题-基础-6、CAS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发编程专题-基础-7、Thread"><img class="cover" src="https://picsum.photos/1920/912" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-7、Thread</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-4、信号量与管程"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-4、信号量与管程</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-5%E3%80%81%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-5、进程 线程 纤程 协程 管程"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-5、进程 线程 纤程 协程 管程</div></div></a></div><div><a href="/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/" title="并发编程专题-基础-12、AQS"><img class="cover" src="https://picsum.photos/1920/1084" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">并发编程专题-基础-12、AQS</div></div></a></div><div><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/" title="并发编程专题-基础-1、JMM与MESI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-09</div><div class="title">并发编程专题-基础-1、JMM与MESI</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%89%B9%E6%80%A7"><span class="toc-text">1. 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">1.1. 原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">1.2. 可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">1.3. 有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8F%AF%E9%87%8D%E5%85%A5%E7%89%B9%E6%80%A7"><span class="toc-text">1.4. 可重入特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%8E%9F%E5%AD%90%E6%80%A7%E6%AF%94%E8%BE%83"><span class="toc-text">1.5. 原子性比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90"><span class="toc-text">2. 深入剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BA%94%E7%94%A8%E5%B1%82%E9%9D%A2"><span class="toc-text">2.1. 应用层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E4%B8%89%E7%A7%8D%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.1.1. 三种锁类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">2.1.2. 三种应用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-text">2.2. 字节码层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-monitorenter%E3%80%81monitorexit"><span class="toc-text">2.2.1. monitorenter、monitorexit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-1-%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">2.2.1.1. 修饰代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-2-2-%E4%B8%AA-monitorexit"><span class="toc-text">2.2.1.2. 2 个 monitorexit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-ACC-SYNCHRONIZED"><span class="toc-text">2.2.2. ACC_SYNCHRONIZED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.2.1. 修饰方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-JDK-%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-text">2.3. JDK 源码层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-ObjectMonitor"><span class="toc-text">2.3.1. ObjectMonitor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-1-ObjectMonitor-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.3.1.1. ObjectMonitor 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-2-OM-%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">2.3.1.2. OM 创建时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2.3.1.3. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-1-count"><span class="toc-text">2.3.1.3.1. _count</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-2-recursions"><span class="toc-text">2.3.1.3.2. _recursions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-3-3%E4%B8%AA%E9%98%9F%E5%88%97"><span class="toc-text">2.3.1.3.3. 3个队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-4-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3.1.4. 工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-5-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8D%E9%87%8F"><span class="toc-text">2.3.1.5. 重量级锁的重量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E-monitor-%E5%85%B3%E8%81%94"><span class="toc-text">2.3.2. 对象与 monitor 关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%B1%82%E9%9D%A2"><span class="toc-text">2.4. 内存屏障层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2"><span class="toc-text">2.5. 汇编实现层面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">3. 重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-text">3.1. 锁膨胀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.1.1. 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">3.1.2. 执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-monitor-%E7%AB%9E%E4%BA%89"><span class="toc-text">3.2. monitor 竞争</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-monitor-%E7%AD%89%E5%BE%85"><span class="toc-text">3.3. monitor 等待</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-monitor-%E9%87%8A%E6%94%BE"><span class="toc-text">3.4. monitor 释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-wait-%E5%92%8C-notify"><span class="toc-text">3.5. wait 和 notify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">3.6. 源码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-text">4. 锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">4.1. 偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E4%BC%98%E7%82%B9%E4%BD%9C%E7%94%A8-%E5%87%8F%E5%B0%91%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-CAS-%E7%BA%BF%E7%A8%8B-ID-%E7%9A%84%E6%9B%BF%E6%8D%A2%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.1.1. 优点作用 - 减少轻量级锁不必要的 CAS 线程 ID 的替换⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%BC%BA%E7%82%B9%E9%97%AE%E9%A2%98"><span class="toc-text">4.1.2. 缺点问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%BB%B6%E8%BF%9F%E5%81%8F%E5%90%91"><span class="toc-text">4.1.3. 延迟偏向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E5%8C%BF%E5%90%8D%E5%81%8F%E5%90%91"><span class="toc-text">4.1.4. 匿名偏向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.1.5. 加锁流程⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%92%A4%E9%94%80%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1.6. 撤销流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-%E9%87%8A%E6%94%BE%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1.7. 释放流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-text">4.1.8. 锁重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-%E5%85%B6%E4%BB%96%E6%92%A4%E9%94%80"><span class="toc-text">4.1.9. 其他撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-9-1-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E4%B9%8B%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-HashCode"><span class="toc-text">4.1.9.1. 偏向锁撤销之调用对象 HashCode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-9-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8-hashcode-%E4%BC%9A%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">4.1.9.1.1. 为什么调用 hashcode 会撤销偏向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-9-1-2-hashcode-%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">4.1.9.1.2. hashcode 存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-9-2-%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80%E4%B9%8B%E8%B0%83%E7%94%A8-wait-x2F-notify"><span class="toc-text">4.1.9.2. 偏向锁撤销之调用 wait&#x2F;notify</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-10-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E5%92%8C%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-text">4.1.10. 批量重偏向和批量撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">4.1.11. 源码解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">4.2. 轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%A6%82%E5%BF%B5%E4%BD%9C%E7%94%A8-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.2.1. 概念作用 - 多个线程交替执行⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81%E5%8F%8A%E9%94%81%E8%86%A8%E8%83%80%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.2.2. 加锁流程 - 轻量级锁加锁及锁膨胀⭐️🔴⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-text">4.2.3. 解锁流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E4%BC%98%E7%82%B9"><span class="toc-text">4.2.4. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E7%BC%BA%E7%82%B9%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.2.5. 缺点⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-text">4.2.6. 锁重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E6%BA%90%E7%A0%81"><span class="toc-text">4.2.7. 源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">4.3. 自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-text">4.4. 锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-text">4.5. 锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.6. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">5. 锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%94%81%E8%AE%B0%E5%BD%95-LockRecord"><span class="toc-text">5.1. 锁记录 ( LockRecord)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%94%81%E5%AF%B9%E8%B1%A1-ObjectRef"><span class="toc-text">5.2. 锁对象 (ObjectRef)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E9%94%81-ObjectMonitor"><span class="toc-text">5.3. 对象锁 (ObjectMonitor)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8D%87%E7%BA%A7%E5%9B%BE%E7%A4%BA"><span class="toc-text">5.4. 升级图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E9%94%81%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86-%E6%B5%81%E7%A8%8B-%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.5. 锁升级原理 (流程)⭐️🔴⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">6. 为什么要废弃偏向锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AF%B9%E6%AF%94"><span class="toc-text">7. 对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">8. 实战经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%87%8F%E5%B0%91-synchronized-%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">8.1. 减少 synchronized 的范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E9%99%8D%E4%BD%8E-synchronized-%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-text">8.2. 降低 synchronized 锁的粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">8.3. 读写分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-text">8.4. 常见错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-synchronized-new-Object"><span class="toc-text">8.4.1. synchronized (new Object())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-synchronized-%E4%BA%AB%E5%85%83"><span class="toc-text">8.4.2. synchronized (享元)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8A%A0%E9%94%81%E5%A7%BF%E5%8A%BF"><span class="toc-text">8.4.3. 正确的加锁姿势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3"><span class="toc-text">9. 源码入口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">10. 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-wait-%E5%92%8C-notify-%E8%BF%99%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8-synchronized-%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD"><span class="toc-text">10.1. wait 和 notify 这个为什么要在 synchronized 代码块中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E7%AE%A1%E9%81%93%E6%B5%81"><span class="toc-text">10.1.1. 管道流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">11. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E9%BB%91%E9%A9%AC"><span class="toc-text">11.1. 黑马</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-%E8%A7%86%E9%A2%91"><span class="toc-text">11.1.1. 视频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%85%B6%E4%BB%96"><span class="toc-text">11.2. 其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">11.3. 源码分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/952')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>