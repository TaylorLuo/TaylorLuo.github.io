<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程专题-基础-1、JMM与MESI | Taylor</title><meta name="keywords" content="并发编程专题,关键字"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. CPU 架构1.1. CPU 主要架构    1.1.1. Front End（Core 前端）首先看 Front-end，Front-end 的主要目的就是从内存里提取各种各样的 X86 指令，然后对指令进行译码，融合优化等操作，把 X86 指令转化为最适合执行单元执行的微指令流传递给执行单元。Front-End 的存在就是为了让执行单元时刻保持繁忙，将 CPU 的性能完全发挥出来。 1."><meta property="og:type" content="article"><meta property="og:title" content="并发编程专题-基础-1、JMM与MESI"><meta property="og:url" content="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. CPU 架构1.1. CPU 主要架构    1.1.1. Front End（Core 前端）首先看 Front-end，Front-end 的主要目的就是从内存里提取各种各样的 X86 指令，然后对指令进行译码，融合优化等操作，把 X86 指令转化为最适合执行单元执行的微指令流传递给执行单元。Front-End 的存在就是为了让执行单元时刻保持繁忙，将 CPU 的性能完全发挥出来。 1."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://unpkg.com/justlovesmile-img/cover1.JPG"><meta property="article:published_time" content="2022-11-08T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.682Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="并发编程专题"><meta property="article:tag" content="关键字"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://unpkg.com/justlovesmile-img/cover1.JPG"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程专题-基础-1、JMM与MESI",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://unpkg.com/justlovesmile-img/cover1.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程专题-基础-1、JMM与MESI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-08T16:00:00.000Z" title="发表于 2022-11-09 00:00:00">2022-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.682Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="并发编程专题-基础-1、JMM与MESI"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-CPU-架构"><a href="#1-CPU-架构" class="headerlink" title="1. CPU 架构"></a>1. CPU 架构</h1><h2 id="1-1-CPU-主要架构"><a href="#1-1-CPU-主要架构" class="headerlink" title="1.1. CPU 主要架构"></a>1.1. CPU 主要架构</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116162723.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221114092628.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221114152404.svg"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221114151834.png"></p><h3 id="1-1-1-Front-End（Core-前端）"><a href="#1-1-1-Front-End（Core-前端）" class="headerlink" title="1.1.1. Front End（Core 前端）"></a>1.1.1. Front End（Core 前端）</h3><p>首先看 Front-end，Front-end 的主要目的就是从内存里提取各种各样的 X86 指令，然后对指令进行译码，融合优化等操作，把 X86 指令转化为最适合执行单元执行的微指令流传递给执行单元。Front-End 的存在就是为了让执行单元时刻保持繁忙，将 CPU 的性能完全发挥出来。</p><h4 id="1-1-1-1-乱序组件"><a href="#1-1-1-1-乱序组件" class="headerlink" title="1.1.1.1. 乱序组件"></a>1.1.1.1. 乱序组件</h4><ul><li>**Allocation Queue(IDQ): 分配队列，分配队列作为前端与执行单元的接口，是 Core 前端的最后的一个部件。分配队列的目的是将微指令进行重新整合与融合，发给执行单元进行乱序执行。分配队列又包含了 Loop Stream Detector(LSD) 循环流检测器，对循环操作进行优化与 up-Fusion(微指令融合单元)。融合是为了让后续解码单元更有效率并且节省 ROB（re-order buffer）的空间</li></ul><p><img src="https://pic1.zhimg.com/80/v2-31d86c5c0a08fb1dcce87747c3223b50_720w.webp"></p><h3 id="1-1-2-Execution-Engine-执行单元"><a href="#1-1-2-Execution-Engine-执行单元" class="headerlink" title="1.1.2. Execution Engine (执行单元)"></a>1.1.2. Execution Engine (执行单元)</h3><p>Front-End 的存在就是为了让执行单元时刻保持繁忙，那么执行单元的最主要的目的就是执行指令，运算。这也是一个 core 中最根本的单元。</p><p>当被 AQ 或者 IDQ（分配单元）优化过后的微指令来到执行单元时，首先最先传输到</p><h4 id="1-1-2-1-重排缓冲区"><a href="#1-1-2-1-重排缓冲区" class="headerlink" title="1.1.2.1. 重排缓冲区"></a>1.1.2.1. 重排缓冲区</h4><ul><li>**ROB（re-order buffer）：重新排序缓冲区。ROB 的存在 ROB 的目的<span style="background-color:#0f0">为存储 out-of-order 的处理结果，作为 EU 的入口兼部分出口，它是乱序执行的最基本保证</span>。当指令被传如 ROB 中，微指令流会以顺序执行的方式传入到后面的 RS，在经过 ROB 时，会占用 ROB 的一个位置，这个位置是存储微指令乱序执行处理完成时候的结果，之后经过整合会顺序写回到相应的寄存器。而微指令在经过 ROB 时候会做一些优化。（消除寄存器移动，置零指令与置一指令等）。此外对于超线程中的寄存器别名技术在此经过 RAT（寄存器别名表）进行寄存器重命名。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-dd56b40540282c6feb74de7b6af2e48e_720w.webp"></p><ul><li><strong>RS(Scheduler unified reservation station)：</strong>统一调度保留站。指令经过前面千辛万苦来到这里，此时微指令不在融合在一起，而是被单独的分配给下面各个执行单元，从架构图中可以看到，RS 下面挂载了八个端口，每个端口后面挂载不同的执行模块应对不同的指令需求.</li></ul><p><img src="https://pic4.zhimg.com/80/v2-58c7699ff760f8e3fed8693e5690125b_720w.webp"></p><p>从上图中可以看到，对于 8 个端口，其中 Port0,Port1,Port5,Port6 负责各种常见运算 (整数，浮点，除法，移位，AES 加密，复合整数运算……)，而 Port2,Port3 负责从下层的指令缓存提取数据，port4 负责存储数据到 L1 缓存。Port7 挂载地址生成单元（AGU address generation unit）.</p><h3 id="1-1-3-Memory-Subsystem"><a href="#1-1-3-Memory-Subsystem" class="headerlink" title="1.1.3. Memory Subsystem"></a>1.1.3. Memory Subsystem</h3><p>图中紫色的模块，在 EU（执行单元）在执行指令时候，L1 数据 Cache 负责供给执行指令期间所需要的数据。从图中可以看到 L1 数据缓存是 8- 路并行数据缓存，L1 数据缓存可以通过数据页表地址缓存从 L2 提取数据与存储数据。</p><h4 id="1-1-3-1-保存缓冲区"><a href="#1-1-3-1-保存缓冲区" class="headerlink" title="1.1.3.1. 保存缓冲区"></a>1.1.3.1. 保存缓冲区</h4><p>Store Buffer</p><p><img src="https://pic2.zhimg.com/80/v2-81f39695ca8dd21a111102357889c035_720w.webp"></p><h2 id="1-2-高速缓存"><a href="#1-2-高速缓存" class="headerlink" title="1.2. 高速缓存"></a>1.2. 高速缓存</h2><h3 id="1-2-1-为什么要有"><a href="#1-2-1-为什么要有" class="headerlink" title="1.2.1. 为什么要有"></a>1.2.1. 为什么要有</h3><h4 id="1-2-1-1-性能适配"><a href="#1-2-1-1-性能适配" class="headerlink" title="1.2.1.1. 性能适配"></a>1.2.1.1. 性能适配</h4><p>CPU 和内存访问性能的差距非常大。如今，一次内存的访问，大约需要 120 个 CPU Cycle。这也意味着，在今天，<strong>CPU 和内存的访问速度已经有了 120 倍的差距。</strong><br>为了弥补两者之间的性能差异，充分利用 CPU，现代 CPU 中引入了 <strong>高速缓存 (CPU Cache)<strong>。高速缓存分为 L1&#x2F;L2&#x2F;L3 Cache，不是一个单纯的、概念上的缓存（比如使用内存作为硬盘的缓存），</strong>而是指特定的由 SRAM 组成的物理芯片</strong>。下图是一张 Intel CPU 的放大照片。这里面大片的长方形芯片，就是这个 CPU 使用的 20MB 的 L3 Cache，可以看到现代 CPU 中大量的空间已经被 SRAM 占据。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221128124059.png"></p><h4 id="1-2-1-2-局部性原理"><a href="#1-2-1-2-局部性原理" class="headerlink" title="1.2.1.2. 局部性原理"></a>1.2.1.2. 局部性原理</h4><ul><li>时间局部性：某个内存单元在较短时间内很可能被再次访问</li><li>空间局部性：某个内存单元被访问后相邻的内存单元较短时间内很可能被访问</li></ul><p>在各类基准测试 (Benchmark) 和实际应用场景中，<strong>CPU Cache 的命中率通常能达到 95% 以上。</strong></p><h3 id="1-2-2-缓存行"><a href="#1-2-2-缓存行" class="headerlink" title="1.2.2. 缓存行"></a>1.2.2. 缓存行</h3><h4 id="1-2-2-1-是什么"><a href="#1-2-2-1-是什么" class="headerlink" title="1.2.2.1. 是什么"></a>1.2.2.1. 是什么</h4><p>之所以会有 CPU 缓存，时间局部性是其中一个重要的原因。不过，我们到底应该怎么利用处理器的空间局部性呢？比起拷贝一个单独的内存地址到 CPU 缓存里，拷贝一个 <strong>缓存行</strong> (<strong>Cache Line</strong>) 是更好的实现。<span style="background-color:#0f0">一个缓存行是一个连续的内存段。</span></p><p>缓存行的大小取决于缓存的级别 (同样的，具体还是取决于处理器模型)。举个例子，这是我的电脑的 L1 缓存行的大小：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">sysctl</span> <span class="hljs-string">-a</span> <span class="hljs-string">|</span> <span class="hljs-attr">grep cachelinehw.cachelinesize:</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>处理器会拷贝一段连续的 64 字节的内存段到 L1 缓存里，而不是仅仅拷贝一个单独的变量。比如 long 类型变量，1 个占用 8 个字节，那么一个缓存行就可放 8 个 long 类型的变量</p><p>现在总结一下，为了平衡 CPU 和内存的性能差异，现在 CPU 引入高速缓存：</p><ul><li>**高速缓存 (CPU Cache)**：用于平衡 CPU 和内存的性能差异，分为 L1&#x2F;L2&#x2F;L3 Cache。其中 L1&#x2F;L2 是 CPU 私有，L3 是所有 CPU 共享。</li><li>**缓存行 (Cache Line)**：高速缓存的最小单元，一次从内存中读取的数据大小。常用的 Intel 服务器 Cache Line 的大小通常是 64 字节。</li></ul><p>两种写入策略。</p><ul><li>**写直达 (Write-Through)**：每一次数据都要写入到主内存里面。</li><li>**写回 (Write-Back)**：数据写到 CPU Cache 就结束。只有当 CPU Cache 是脏数据时，才把数据写入主内存。<br>写回这个策略里，如果我们大量的操作，都能够命中缓存。那么大部分时间里，我们都不需要读写主内存，自然性能会比写直达的效果好很多。</li></ul><h4 id="1-2-2-2-伪共享"><a href="#1-2-2-2-伪共享" class="headerlink" title="1.2.2.2. 伪共享"></a>1.2.2.2. 伪共享</h4><p>[[【译】CPU 高速缓存原理和应用 - Strike Freedom]]</p><h2 id="1-3-乱序执行技术"><a href="#1-3-乱序执行技术" class="headerlink" title="1.3. 乱序执行技术"></a>1.3. 乱序执行技术</h2><p>乱序执行（Out-of-order Execution）是以乱序方式执行指令，即 CPU 允许将多条指令不按程序规定的顺序而分开发送给各相应电路单元进行处理。这样，根据各个电路单元的状态和各指令能否提前执行的具体情况分析，将能够提前执行的指令立即发送给相应电路单元予以执行，在这期间不按规定顺序执行指令；然后由 <strong>重新排列单元将各执行单元的结果按指令顺序重新排列</strong>。乱序执行的目的，就是为了 <strong>使 CPU 内部电路满负荷运转，并相应提高 CPU 运行程序的速度</strong>。</p><p>实现乱序执行的关键在于 <strong>取消传统的“取指”和“执行”两个阶段之间指令需要线性排列的限制</strong>，而使用一个 <strong>指令缓冲池</strong>(即<span style="background-color:#0f0">重排缓冲区 ROB</span>) 来开辟一个较长的指令窗口，<strong>允许执行单元在一个较大的范围内调遣和执行已译码的程序指令流</strong>。</p><h2 id="1-4-CPU-乱序来源"><a href="#1-4-CPU-乱序来源" class="headerlink" title="1.4. CPU 乱序来源"></a>1.4. CPU 乱序来源</h2><h3 id="1-4-1-指令执行乱序"><a href="#1-4-1-指令执行乱序" class="headerlink" title="1.4.1. 指令执行乱序"></a>1.4.1. 指令执行乱序</h3><p>因为 MESI 规范要求变量值写入缓存行的前提条件是变量必须在缓存行中，这就要求有一个中间的 StoreBuffer 作为缓冲 (其实这是 StoreBuffer 需要存在的一个原因，主要原因还是为了避免 CPU 写入缓存行时等待其他 CPU 的 ack 消息而导致的性能下降)，否则会导致 CPU 效率下降。那么<br>ROB 写入到 StoreBuffer 有 2 种方式：</p><ol><li>ROB 中的变量，在 StoreBuffer 中谁先有谁先写</li><li>严格的 FIFO 方式<br>从 x86-TSO 模型的物理构件角度解释就是，写操作会按照 FIFO 的规则 进入 StoreBuffer，并且按照 FIFO 的顺序刷入共享存储</li></ol><p>so，x86 是可以保证不会出现 CPU 的指令执行乱序的</p><h3 id="1-4-2-内存写入乱序"><a href="#1-4-2-内存写入乱序" class="headerlink" title="1.4.2. 内存写入乱序"></a>1.4.2. 内存写入乱序</h3><p>然鹅，从 StoreBuffer 到 共享缓存这一步，是异步的，就需要 CPU 指令来保证了，比如 volatile 的 fence 方法中的 lock 指令，值得注意的是 lock 这个 CPU 指令也具有禁止编译优化的作用。</p><h4 id="1-4-2-1-问题根源"><a href="#1-4-2-1-问题根源" class="headerlink" title="1.4.2.1. 问题根源"></a>1.4.2.1. 问题根源</h4><p>[[后端 - MESI 缓存一致性协议引发的一些思考_个人文章 - SegmentFault 思否]]</p><h1 id="2-Java-Memory-Model"><a href="#2-Java-Memory-Model" class="headerlink" title="2. Java Memory Model"></a>2. Java Memory Model</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106110623.jpg" alt="image-20200128184358700"></p><p><strong>工作内存就是每个线程独享的线程栈</strong></p><h2 id="2-1-并发编程的-3-大特性"><a href="#2-1-并发编程的-3-大特性" class="headerlink" title="2.1. 并发编程的 3 大特性"></a>2.1. 并发编程的 3 大特性</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106111027.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106111220.png"></p><h2 id="2-2-JMM8-大原子操作"><a href="#2-2-JMM8-大原子操作" class="headerlink" title="2.2. JMM8 大原子操作"></a>2.2. JMM8 大原子操作</h2><ul><li>read(读取)：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用;</li><li>load(载入)：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中;</li><li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作;</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作;</li><li>store(存储)：<span style="background-color:#0f0">作用于工作内存的变量</span>，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作;</li><li>write(写入)：<span style="background-color:#0f0">作用于主内存的变量</span>，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中;</li></ul><h2 id="2-3-JMM-缓存不一致问题"><a href="#2-3-JMM-缓存不一致问题" class="headerlink" title="2.3. JMM 缓存不一致问题"></a>2.3. JMM 缓存不一致问题</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106110701.jpg" alt="image-20200128193625783"></p><h3 id="2-3-1-工作原理"><a href="#2-3-1-工作原理" class="headerlink" title="2.3.1. 工作原理"></a>2.3.1. 工作原理</h3><h4 id="2-3-1-1-总线加锁"><a href="#2-3-1-1-总线加锁" class="headerlink" title="2.3.1.1. 总线加锁"></a>2.3.1.1. 总线加锁</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106110712.jpg" alt="image-20200321183046051"></p><ol><li>先到先得，一个线程 read 主内存数据时，用 lock 命令给总线加锁，此时 CPU 跟主内存的通信被锁定，其他 CPU 的线程都无法操作主内存，直到将运算结果 write 回主内存后再用 unlock 命令将锁释放，之后其他线程才能操作主内存中的这个资源。</li><li>从主内存中，读取锁的最小单位是缓存行，加入一个数据的长度大于一个缓存行，这时候就会出现缓存行失效问题，当缓存行失效，就会走总线加锁。</li></ol><h4 id="2-3-1-2-MESI"><a href="#2-3-1-2-MESI" class="headerlink" title="2.3.1.2. MESI"></a>2.3.1.2. MESI</h4><h1 id="3-MESI"><a href="#3-MESI" class="headerlink" title="3. MESI"></a>3. MESI</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jackeason/p/11336317.html">https://www.cnblogs.com/jackeason/p/11336317.html</a></p><p>MESI 的状态机包含了 4 个状态，也是名字的由来：</p><ul><li>(M)odified: 单副本 + 脏数据（即缓存改变，未写回内存）</li><li>(E)xclusive: 单副本 + 干净数据</li><li>(S)hared: 多副本 + 干净数据</li><li>(I)nvalid: 数据未加载或缓存已失效</li></ul><h2 id="3-1-工作原理"><a href="#3-1-工作原理" class="headerlink" title="3.1. 工作原理"></a>3.1. 工作原理</h2><blockquote><p>具体 CPU 如何从主内存中加载变量进行运行的过程，在 CPU 缓存架构中有详解，这里不做过多的解释</p><p>1.假设 CPU1 率先抢到时间片，当变量 count 加载至 CPU 缓存中时，会将 count 的使用标志为（E 独占：首次加载会将变量置为独占，也就说明没有其他 CPU 进行加载）</p><p>2.CPU2 也获得时间片，把变量 count 加载缓存中，此时 count 的使用标志为（E 独占），并发送消息至总线，告知其他 CPU 读取了变量的值，各 CPU 通过时刻监听（总线嗅探机制）获得到此变量已被多个 CPU 所加载，那么此时 CPU2 就会将自身 count 的使用标志置为（S 共享），CPU1 也会将变量的使用标志也会置为（S）</p><p>3.CPU1 从缓存中加载 count 至寄存器中进行自增操作，执行完毕之后，count &#x3D; 0 -&gt; 1，此时由于 count 的值发生了变化，因此 CPU1 中变量 count 使用标志应为（M 修改），此时 CPU1 会发送消息至总线，告知其他线程已经修改了变量 count 的值，其他 CPU 嗅探到值的修改，就会将自身变量 count 的使用标志置为（I 无效）</p><p>4.CPU1 会将 M 状态的变量立刻写回至主内存中，写回完毕之后，CPU1 会将使用状态置为（E 独享），发送消息至总线，告知其他 CPU 已经写回完毕，其他 CPU 会再此从主内存中读取变量 count 的值，读取完毕之后，也会发送消息至总线，其他 CPU 嗅探到之后将自身变量 count 置为（S 共享），自身变量的使用状态也会置为（S 共享）</p></blockquote><p>MESI 失效时，缓存锁会退化到总线锁，失效的情况：</p><ol><li>当缓存行存储的数据超过最小存储单元大小时（数据长度存储跨越多个缓存行的情况），就会导致 MESI 操作缓存行无效，导致 MESI 缓存一致性协议失效；</li><li>系统不支持缓存一致性协议。</li></ol><p>缓存行大小：32B、64B、128B(因系统而定)</p><h2 id="3-2-状态变换"><a href="#3-2-状态变换" class="headerlink" title="3.2. 状态变换"></a>3.2. 状态变换</h2><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;并发研究之CPU缓存一致性协议(MESI) - 枫飘雪落 - 博客园]]</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221115172751.png"></p><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M 修改 (Modified)</td><td>该 Cache line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成 S（共享）状态之前被延迟执行。</td></tr><tr><td>E 独享、互斥 (Exclusive)</td><td>该 Cache line 有效，数据和内存中的数据一致，数据只存在于本 Cache 中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成 S（共享）状态。</td></tr><tr><td>S 共享 (Shared)</td><td>该 Cache line 有效，数据和内存中的数据一致，数据存在于很多 Cache 中。</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td>I 无效 (Invalid)</td><td>该 Cache line 无效。</td><td>无</td></tr></tbody></table><p>在 MESI 协议中，<strong>每个 Cache 的 Cache 控制器不仅知道自己的读写操作，而且也监听 (snoop) 其它 Cache 的读写操作</strong>。每个 Cache line 所处的状态根据本核和其它核的读写操作在 4 个状态间进行迁移</p><p>Local Read 表示本内核读本 Cache 中的值，Local Write 表示本内核写本 Cache 中的值，Remote Read 表示其它内核读其它 Cache 中的值，Remote Write 表示其它内核写其它 Cache 中的值，箭头表示本 Cache line 状态的迁移，环形箭头表示状态不变。 当内核需要访问的数据不在本 Cache 中，而其它 Cache 有这份数据的备份时，本 Cache 既可以从内存中导入数据，也可以从其它 Cache 中导入数据，不同的处理器会有不同的选择。MESI 协议为了使自己更加通用，没有定义这些细节，只定义了状态之间的迁移，下面的描述假设本 Cache 从内存中导入数据.</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;并发原理系列一：MESI与内存屏障-今日头条]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;CPU高速缓存行与内存关系 及并发MESI 协议 - JokerJason - 博客园]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;聊聊缓存一致性协议 - Yungyu - 博客园]]</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;CPU缓存一致性协议—MESI详解 - 提拉没有米苏 - 博客园]]</p><h2 id="3-3-5-种协议消息"><a href="#3-3-5-种协议消息" class="headerlink" title="3.3. 5 种协议消息"></a>3.3. 5 种协议消息</h2><p>Mesi 协议消息<br><strong>Read</strong>：”read” 消息用来获取指定物理地址上的 cache line 数据。<br><strong>Read Response</strong>：该消息携带了 “read” 消息所请求的数据。read response 可能来自于 memory 或者是其他 CPU cache。<br><strong>Invalidate</strong>：该消息将其他 CPU cache 中指定的数据设置为失效。该消息携带物理地址，其他 CPU cache 在收到该消息后，必须进行匹配，发现在自己的 cache line 中有该地址的数据，那么就将其从 cahe line 中移除，<span style="background-color:red">并响应 Invalidate Acknowledge 回应</span>。Invalidate Acknowledge 消息用做回应 Invalidate 消息。<br><strong>Read Invalidate</strong>：该消息中带有物理地址，用来说明想要读取哪一个 cache line 中的数据。这个消息还有 Invalidate 消息的效果。其实该消息是 read + Invalidate 消息的组合，发送该消息后 cache 期望收到一个 read response 消息。<br><strong>Writeback</strong>： 该消息带有地址和数据，该消息用在 modified 状态的 cache line 被置换时发出，用来将最新的数据写回 memory 或其他下一级 cache 中。</p><h2 id="3-4-Store-Buffer⭐️🔴"><a href="#3-4-Store-Buffer⭐️🔴" class="headerlink" title="3.4. Store Buffer⭐️🔴"></a>3.4. Store Buffer⭐️🔴</h2><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230528-1555%%</span>❕ ^pyabmn</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116152644.png"></p><p>当 cpu0 要<span style="background-color:#0f0">写数据到本地 cache</span>的时候，<span style="background-color:#ff0">如果不是 M 或者 E 状态，需要发送一个 invalidate 消息</span>给 cpu1，<span style="background-color:red">只有收到 cpu1 的 acknowledgement 才能写数据到 cache 中，在这个过程中 cpu0 需要等待，这大大影响了性能</span>。一种解决办法是在 cpu 和 cache 之间引入 store buffer，当发出 invalidate 之后直接把数据写入 store buffer。当收到 acknowledgement 之后可以把 store buffer 中的数据写入 cache。<br>现在的架构图是这样的： ^47f91q</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116152811.png"></p><p>Store Buffer 的确提高了 CPU 的资源利用率，不过优化了带来了新的问题。在新数据存储在 Store Buffer 里时，如果此时有一条 read 指令，若仍旧从 cache 中读取数据时，读到的是旧的数据。要解决这个问题就必须要求 CPU 读取数据时得先看 Store Buferes 里面有没有，如果有则直接读取 Store Buferes 里的值，如果没有才能读取自己缓存里面的数据，这也就是所谓的“Store Forward”。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116152942.png"></p><h2 id="3-5-Invalidate-Queue⭐️🔴"><a href="#3-5-Invalidate-Queue⭐️🔴" class="headerlink" title="3.5. Invalidate Queue⭐️🔴"></a>3.5. Invalidate Queue⭐️🔴</h2><p>但是内存屏障的处理方法有个问题，那就是 store buffer 空间是有限的，如果 store buffer 中的空间被 smp_mb 之后的存储塞满，cpu 还是得等待 invalidate 消息返回才能继续处理。解决这种问题的思路是让 invalidate ack 能更早得返回，一种办法是提供一种放置 invalidate message 的队列，称为 invalidate queue. cpu 可以在收到 invalidate 之后马上返回 invalidate ack，而不是在把本地 cache invalidate 之后，并把 invalidate message 放置到 invalide queue，以待之后处理。</p><p>CPU 其实不需要完成 invalidate 操作就可以回送 acknowledge 消息，这样，就不会阻止发生 invalidate 请求的那个 CPU 进入无聊的等待状态。CPU 可以 buffer 这些 invalidate message（放入 Invalidate Queues），然后直接回应 acknowledge，表示自己已经收到请求，随后会慢慢处理。</p><h2 id="3-6-读写屏障⭐️🔴"><a href="#3-6-读写屏障⭐️🔴" class="headerlink" title="3.6. 读写屏障⭐️🔴"></a>3.6. 读写屏障⭐️🔴</h2><p>store buffer 和 invalidate queue 的引入导致不满足全局有序，所以需要有写屏障和读屏障。<br>读屏障用于处理 invalidate queue，写屏障用于处理 store buffer。<br>X86 架构下的读屏障指令是 lfenc，写屏障指令是 sfence，读写屏障指令是 mfence。</p><h3 id="3-6-1-读屏障⭐️🔴"><a href="#3-6-1-读屏障⭐️🔴" class="headerlink" title="3.6.1. 读屏障⭐️🔴"></a>3.6.1. 读屏障⭐️🔴</h3><p><strong>作用</strong>：所有读屏障之前发生的内存更新，对读屏障之后的 load 操作都是可见的<br><strong>cpu 实际操作：</strong> 把 <strong>失效队列</strong>（invalidate queue）里的实效指令（I）全部执行</p><h3 id="3-6-2-写屏障⭐️🔴"><a href="#3-6-2-写屏障⭐️🔴" class="headerlink" title="3.6.2. 写屏障⭐️🔴"></a>3.6.2. 写屏障⭐️🔴</h3><p><strong>作用</strong>：所有写屏障之前发生的内存更新（M）对之后的命令都是可见的<br><strong>cpu 实际操作：等到 存储缓存</strong>（store buffer）为空（所有更新已刷出），cpu 才能执行写屏障之后指令</p><h3 id="3-6-3-Full-屏障"><a href="#3-6-3-Full-屏障" class="headerlink" title="3.6.3. Full 屏障"></a>3.6.3. Full 屏障</h3><p><strong>作用</strong>：上述二者之和<br><strong>cpu 实际操作</strong>：上述二者之后</p><h2 id="3-7-cache-写策略"><a href="#3-7-cache-写策略" class="headerlink" title="3.7. cache 写策略"></a>3.7. cache 写策略</h2><p>Write-through（直写模式）在数据更新时，同时写入缓存 Cache 和后端存储。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p><p><span style="background-color:#0f0">Write-back（回写模式）</span>在数据更新时只写入缓存 Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p><h2 id="3-8-总线嗅探"><a href="#3-8-总线嗅探" class="headerlink" title="3.8. 总线嗅探"></a>3.8. 总线嗅探</h2><p>高速缓存有缓存控制器，然后用来监视总线，如果某一个 CPU 想要修改共享缓存的数据，它会先进行广播，其他的 CPU 就会嗅探到这个事务或者广播。然后他们会判断自己本地高速缓存是否也有这样的数据副本，如果没有则不用理会。<br>总线嗅探机制一般分为两种协议，一种是<span style="background-color:#0f0">写失效协议 (write-invalidate)</span>，一个核心写入缓存后，会广播一个失效请求，其他核心嗅探到则将自己缓存中对应的缓存行标记为失效; 另一种是写更新协议 (write-update)，写入缓存的核心除了要广播一个失效请求外，还要广播数据内容，把对应数据传输给其他 CPU。如果有则通常让他们无效 (write-invalidate) 或者更新 (write-update)。但是对于总线嗅探来说，一般都是使用 write-invalidate，让这些数据无效，因为 write-update 会产生数据拷贝，产生总线流量。</p><p>原文链接： <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanglh046/article/details/115307993">https://blog.csdn.net/zhanglh046/article/details/115307993</a></p><h2 id="3-9-状态流转案例"><a href="#3-9-状态流转案例" class="headerlink" title="3.9. 状态流转案例"></a>3.9. 状态流转案例</h2><p>MESI<br>MESI 通过给每一个 Cache Line 设置一个大小为 2bit （四个状态）的状态位来保证一致性</p><p>状态 描述<br>M（Modified） 被修改的，该 Cache Line 被当前 CPU 核心修改了，和主存不一致，但是是最新的数据，可以直接使用<br>E（Exclusive） 独占的，该 Cache Line 只有当前 CPU 核心有，而且数据和主存一样，可以直接使用<br>S（Shared） 共享的，有多个 CPU 核心里有该 Cache Line，而且数据和主存一样，可以直接使用<br>I（Invalid） 失效的，表示该 Cache Line 无效，需要读取数据就直接取主存中读取即可<br>例子<br>情景：假设现在存在一个 CPU 存在两个核心 core a， core b；</p><h3 id="3-9-1-读取数据"><a href="#3-9-1-读取数据" class="headerlink" title="3.9.1. 读取数据"></a>3.9.1. 读取数据</h3><p>core a 需要读取数据 x<br>core a 会先查看自己的缓存中是否有该数据：<br>如果存在，就查看 Cache Line 的状态，如果是 M，E，S 的话直接使用即可<br>如果不存在，或者 状态是 I ，就会向总线发起读请求 (read)，其他 CPU 核心就会监听该消息，并检查自己有没有该数据:</p><ul><li>如果 core b 缓存中没有该数据，core a 就直接到主存中读取数据即可</li><li>如果 core b 缓存中有该数据， 状态是 E ，说明 core b 的缓存和主存一致，那么 core b 就会把该 数据发送到总线，让 core a 去获取数据，还需要把状态改为 S</li><li>如果 core b 缓存中有该数据，状态是 S ，说明 core b 的缓存和主存一致，那么 core b 就会把该 数据发送到总线，让 core a 去获取数据</li><li>如果 core b 缓存中有该数据，状态是 M，说明 core b 的缓存和主存不一致，那么 core b 需要先把数据写到主存中，把状态改为 S，分享给 core a</li><li>如果 core b 缓存中有该数据，状态是 I，core a 就直接到主存中读取数据即可</li></ul><h3 id="3-9-2-写入数据"><a href="#3-9-2-写入数据" class="headerlink" title="3.9.2. 写入数据"></a>3.9.2. 写入数据</h3><p>core a 需要写入数据 x</p><p>core a 会先查看自己的缓存中是否有该数据：<br>如果存在，并且 Cache Line 的状态为 M ，说明该数据只有在 core a 中是最新的，那么直接修改数据即可，状态不变<br>如果存在，并且 Cache Line 的状态为 E ，说明该数据只有在 core a 中是最新的，那么直接修改数据，然后修改状态为 M<br>如果存在，并且 Cache Line 的状态为 S ，说明该数据在其他核心中存在备份，那么需要发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，通知到其他的 CPU 核心， 自己对该数据进行了修改， 其他核心需要把自己对应的 Cache Line 的状态改为 I ，即无效，core a 需要修改状态为 M<br>如果不存在或者为 Cache Line 状态为 I ，就需要先读取数据到缓存中（回到上面的读取数据流程），然后修改状态为 M ，同时发消息到总线通知其他核心将该数据状态改为 I</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;看懂这篇，才能说了解并发底层技术 - 腾讯云开发者社区-腾讯云]]</p><p><strong>初始 I 状态</strong>：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。<br><strong>本地写（Local Write）</strong>：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。<br><strong>本地读（Local Read）</strong>：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：</p><ul><li>(1) 其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；</li><li>(2) 其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于 M 状态的缓存行，再由本地处理器写入&#x2F;读出，状态是不会改变的）<br><strong>远程读（Remote Read）</strong>：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容 (由 c1 应答 c2 的 read 请求)，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。<br><strong>远程写（Remote Write）</strong>：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置 I 的过程将给写操作带来很大的性能消耗。</li></ul><h2 id="3-10-落地实现"><a href="#3-10-落地实现" class="headerlink" title="3.10. 落地实现"></a>3.10. 落地实现</h2><p>AMD 的 Opteron 处理器使用从 MESI 中演化出的<span style="background-color:#0f0">MOESI 协议</span>，O(Owned) 是 MESI 中 S 和 M 的一个合体，表示本 Cache line 被修改，和内存中的数据不一致，不过其它的核可以有这份数据的拷贝，状态为 S。</p><p>Intel 的 core i7 处理器使用从 MESI 中演化出的<span style="background-color:#0f0">MESIF 协议</span>，F(Forward) 从 Share 中演化而来，一个 Cache line 如果是 Forward 状态，它可以把数据直接传给其它内核的 Cache，而 Share 则不能。</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cherish010/p/8602635.html">https://www.cnblogs.com/cherish010/p/8602635.html</a></p><h1 id="4-屏障和-Lock"><a href="#4-屏障和-Lock" class="headerlink" title="4. 屏障和 Lock"></a>4. 屏障和 Lock</h1><a href="/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" title="并发编程专题-基础-10、内存屏障">并发编程专题-基础-10、内存屏障</a><h1 id="5-总结-来龙去脉⭐️🔴⭐️🔴"><a href="#5-总结-来龙去脉⭐️🔴⭐️🔴" class="headerlink" title="5. 总结 - 来龙去脉⭐️🔴⭐️🔴"></a>5. 总结 - 来龙去脉⭐️🔴⭐️🔴</h1><ol><li><span style="background-color:#f0f">因为内存的速度和 CPU 匹配不上，所以在内存和 CPU 之间加了多级缓存。</span></li><li>单核 CPU 独享不会出现数据不一致的问题，但是多核情况下会有缓存一致性问题。</li><li><span style="background-color:#f0f">缓存一致性协议就是为了解决多组缓存导致的缓存一致性问题。</span></li><li>缓存一致性协议有两种实现方式，一个是基于目录的，一个是基于总线嗅探的。</li><li>基于目录的方式延迟高，但是占用总线流量小，适合 CPU 核数多的系统。</li><li>基于总线嗅探的方式延迟低，但是占用总线流量大，适合 CPU 核数小的系统。</li><li><span style="background-color:#f0f">常见的 MESI 协议就是基于总线嗅探实现的。</span></li><li><span style="background-color:#f0f">MESI 解决了缓存一致性问题，但是还是不能将 CPU 性能压榨到极致。</span><br>!<a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/" title="并发基础-1、JMM与MESI">并发基础-1、JMM与MESI</a></li><li><span style="background-color:#f0f">为了进一步压榨 CPU，所以引入了 store buffer 和 invalidate queue。</span></li><li><span style="background-color:#f0f">store buffer 和 invalidate queue 的引入导致不满足全局有序，所以需要有写屏障和读屏障。</span></li><li>X86 架构下的读屏障指令是 lfenc，写屏障指令是 sfence，读写屏障指令是 mfence。</li><li>lock 前缀指令直接锁缓存行，也能达到内存屏障的效果。</li><li><span style="background-color:#f0f">x86 架构下，volatile 的底层实现就是 lock 前缀指令。</span></li><li>JMM 是一个模型，是一个便于 Java 开发人员开发的抽象模型。</li><li>缓存性一致性协议是为了解决 CPU 多核系统下的数据一致性问题，是一个客观存在的东西，不需要去触发。</li><li><strong>JMM 和缓存一致性协议没有一毛钱关系。</strong></li><li><strong>JMM 和 MESI 没有一毛钱关系。</strong></li></ol><h1 id="6-参考与感谢"><a href="#6-参考与感谢" class="headerlink" title="6. 参考与感谢"></a>6. 参考与感谢</h1><p>[[关于缓存一致性协议、MESI、StoreBuffer、InvalidateQueue、内存屏障、Lock指令和JMM的那点事 HeapDump性能社区]]</p><p>[[MESI 协议学习笔记 三点水]]</p><p>[[内存屏障及其在 JVM 下的应用 — Blogs by ylgrgyq]]</p><p>👍 [[cpu缓存和volatile - XuMinzhe - 博客园]]</p><p>JMM 完善于 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=PV6GfA24/DoFWatq/r8pPA==.+q6CgZcQq5DGewDfrvSMWEW6oCoKl+qIyjXyJDFcC8tkEmDyzGwlu3gJqYXsFNvb">JSR-133</a>，现在一般会把详细说明放在 Java Language 的 Spec 上，比如 Java11 的话在：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=o6ed6BfL7g86k67Y56td0g==.aQTiJ2Adn2nH2UrtXmPeSi65AUs2HZJhC0m1I+txwTM23m50K7CmAhI2ha8jKR9Rq9Ve6f+hSFE/tZ8tWdTf5R2RqGj5n2nJNe/LVYDdyZI=">Chapter 17. Threads and Locks</a>。在这些说明之外，还有个特别出名的 Cookbook，叫 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Cc8voHRYDmHjNAmEOTW/0g==.tduSK/KKFZo4xGurj6YzNuGR4ZrmimxxMBi4VlikUXf10T5Z44AMgnbksklMOl94">The JSR-133 Cookbook for Compiler Writers</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/">https://taylorluo.github.io/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/justlovesmile-img/cover1.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-1%E3%80%81%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发编程专题-基础-3、对象内存</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-2%E3%80%81Synchronized/"><img class="next-cover" src="https://picsum.photos/1920/952" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发编程专题-基础-2、Synchronized</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/10/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-6%E3%80%81CAS/" title="并发编程专题-基础-6、CAS"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">并发编程专题-基础-6、CAS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发编程专题-基础-7、Thread"><img class="cover" src="https://picsum.photos/1920/912" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-7、Thread</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-4、信号量与管程"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-4、信号量与管程</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-5%E3%80%81%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-5、进程 线程 纤程 协程 管程"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-5、进程 线程 纤程 协程 管程</div></div></a></div><div><a href="/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/" title="并发编程专题-基础-12、AQS"><img class="cover" src="https://picsum.photos/1920/1084" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">并发编程专题-基础-12、AQS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-9%E3%80%81Java%E5%90%84%E7%A7%8D%E9%94%81/" title="并发编程专题-基础-9、Java各种锁"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-9、Java各种锁</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-CPU-%E6%9E%B6%E6%9E%84"><span class="toc-text">1. CPU 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-CPU-%E4%B8%BB%E8%A6%81%E6%9E%B6%E6%9E%84"><span class="toc-text">1.1. CPU 主要架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-Front-End%EF%BC%88Core-%E5%89%8D%E7%AB%AF%EF%BC%89"><span class="toc-text">1.1.1. Front End（Core 前端）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-1-%E4%B9%B1%E5%BA%8F%E7%BB%84%E4%BB%B6"><span class="toc-text">1.1.1.1. 乱序组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-Execution-Engine-%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83"><span class="toc-text">1.1.2. Execution Engine (执行单元)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-1-%E9%87%8D%E6%8E%92%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">1.1.2.1. 重排缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-Memory-Subsystem"><span class="toc-text">1.1.3. Memory Subsystem</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-1-%E4%BF%9D%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">1.1.3.1. 保存缓冲区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-text">1.2. 高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89"><span class="toc-text">1.2.1. 为什么要有</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-1-%E6%80%A7%E8%83%BD%E9%80%82%E9%85%8D"><span class="toc-text">1.2.1.1. 性能适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-2-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">1.2.1.2. 局部性原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%BC%93%E5%AD%98%E8%A1%8C"><span class="toc-text">1.2.2. 缓存行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.2.2.1. 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-2-%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-text">1.2.2.2. 伪共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF"><span class="toc-text">1.3. 乱序执行技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-CPU-%E4%B9%B1%E5%BA%8F%E6%9D%A5%E6%BA%90"><span class="toc-text">1.4. CPU 乱序来源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%B1%E5%BA%8F"><span class="toc-text">1.4.1. 指令执行乱序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E4%B9%B1%E5%BA%8F"><span class="toc-text">1.4.2. 内存写入乱序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-1-%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90"><span class="toc-text">1.4.2.1. 问题根源</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Java-Memory-Model"><span class="toc-text">2. Java Memory Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84-3-%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">2.1. 并发编程的 3 大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-JMM8-%E5%A4%A7%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2. JMM8 大原子操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-JMM-%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="toc-text">2.3. JMM 缓存不一致问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.1. 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-1-%E6%80%BB%E7%BA%BF%E5%8A%A0%E9%94%81"><span class="toc-text">2.3.1.1. 总线加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-2-MESI"><span class="toc-text">2.3.1.2. MESI</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-MESI"><span class="toc-text">3. MESI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3.1. 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%8A%B6%E6%80%81%E5%8F%98%E6%8D%A2"><span class="toc-text">3.2. 状态变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-5-%E7%A7%8D%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF"><span class="toc-text">3.3. 5 种协议消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Store-Buffer%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.4. Store Buffer⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Invalidate-Queue%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.5. Invalidate Queue⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.6. 读写屏障⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E8%AF%BB%E5%B1%8F%E9%9A%9C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.6.1. 读屏障⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%86%99%E5%B1%8F%E9%9A%9C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.6.2. 写屏障⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-Full-%E5%B1%8F%E9%9A%9C"><span class="toc-text">3.6.3. Full 屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-cache-%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-text">3.7. cache 写策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E6%80%BB%E7%BA%BF%E5%97%85%E6%8E%A2"><span class="toc-text">3.8. 总线嗅探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC%E6%A1%88%E4%BE%8B"><span class="toc-text">3.9. 状态流转案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">3.9.1. 读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-2-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">3.9.2. 写入数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E8%90%BD%E5%9C%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.10. 落地实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B1%8F%E9%9A%9C%E5%92%8C-Lock"><span class="toc-text">4. 屏障和 Lock</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93-%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5. 总结 - 来龙去脉⭐️🔴⭐️🔴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">6. 参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://unpkg.com/justlovesmile-img/cover1.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>