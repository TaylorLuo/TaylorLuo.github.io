<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程专题-基础-10、内存屏障 | Taylor</title><meta name="keywords" content="并发编程专题"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="其实从头看到尾就会发现，一个技术点的出现往往是为了填补另一个的坑。为了解决处理器与主内存之间的速度鸿沟，引入了高速缓存，却又导致了缓存一致性问题为了解决缓存一致性问题，引入了如MESI等技术，又导致了处理器等待问题为了解决处理器等待问题，引入了写缓冲和无效化队列，又导致了重排序和可见性问题为了解决重排序和可见性问题，引入了内存屏障 1. 屏障分类为何而来？为了解决计算机的乱序问题而来。那为什么要有"><meta property="og:type" content="article"><meta property="og:title" content="并发编程专题-基础-10、内存屏障"><meta property="og:url" content="https://taylorluo.github.io/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="其实从头看到尾就会发现，一个技术点的出现往往是为了填补另一个的坑。为了解决处理器与主内存之间的速度鸿沟，引入了高速缓存，却又导致了缓存一致性问题为了解决缓存一致性问题，引入了如MESI等技术，又导致了处理器等待问题为了解决处理器等待问题，引入了写缓冲和无效化队列，又导致了重排序和可见性问题为了解决重排序和可见性问题，引入了内存屏障 1. 屏障分类为何而来？为了解决计算机的乱序问题而来。那为什么要有"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://unpkg.com/justlovesmile-img/cover7.JPG"><meta property="article:published_time" content="2022-11-24T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.684Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="并发编程专题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://unpkg.com/justlovesmile-img/cover7.JPG"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程专题-基础-10、内存屏障",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://unpkg.com/justlovesmile-img/cover7.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程专题-基础-10、内存屏障</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-24T16:00:00.000Z" title="发表于 2022-11-25 00:00:00">2022-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.684Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="并发编程专题-基础-10、内存屏障"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>其实从头看到尾就会发现，一个技术点的出现往往是为了填补另一个的坑。<br>为了解决处理器与主内存之间的速度鸿沟，引入了高速缓存，却又导致了缓存一致性问题<br>为了解决缓存一致性问题，引入了如MESI等技术，又导致了处理器等待问题<br>为了解决处理器等待问题，引入了写缓冲和无效化队列，又导致了重排序和可见性问题<br>为了解决重排序和可见性问题，引入了内存屏障</p><h1 id="1-屏障分类"><a href="#1-屏障分类" class="headerlink" title="1. 屏障分类"></a>1. 屏障分类</h1><p>为何而来？为了解决计算机的乱序问题而来。那为什么要有乱序，为了性能，ok。那有什么乱序需要用屏障来避免？<a href="/2022/11/26/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-11%E3%80%81%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/" title="并发基础-11、乱序问题">并发基础-11、乱序问题</a></p><h2 id="1-1-编译器屏障-优化屏障"><a href="#1-1-编译器屏障-优化屏障" class="headerlink" title="1.1. 编译器屏障(优化屏障)"></a>1.1. 编译器屏障(优化屏障)</h2><p><strong>Optimization barrier</strong>，解决编译器优化乱序问题。</p><p>编译器编译源代码时，会将源代码进行优化，将源代码的指令进行重排序，以适合于CPU的并行执行。然而，内核同步必须避免指令重新排序，优化屏障（Optimization barrier）是避免编译器的重排序优化操作，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。<br>Linux用宏barrier实现优化屏障，gcc编译器的优化屏障宏定义列出如下（在include&#x2F;linux&#x2F;compiler-gcc.h中）： </p><p><code>#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</code></p><p>上述定义中，“__asm__”表示插入了汇编语言程序，“__volatile__”表示阻止编译器对该值进行优化，确保变量使用了用户定义的精确地址，而不是装有同一信息的一些别名。“memory”表示指令修改了内存单元。</p><h2 id="1-2-内存屏障-机器屏障"><a href="#1-2-内存屏障-机器屏障" class="headerlink" title="1.2. 内存屏障(机器屏障)"></a>1.2. 内存屏障(机器屏障)</h2><p><strong>Memory barrier</strong>，解决CPU的指令执行乱序和内存写入乱序问题。</p><p><a target="_blank" rel="noopener" href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/">https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06717ac8312c">https://www.jianshu.com/p/06717ac8312c</a></p><ul><li>**smp_mb(StoreLoad)**：<br>smp_mb 包含的语义有些“重”，既包含了 Store Buffer 的 flush(首先会使得 CPU 在后续变量变更写入之前，把 Store Buffer 的变更写入 flush 到缓存；CPU 要么就等待 flush 完成后写入，要么就把后续的写入变更放到 Store Buffer 中，直到 Store Buffer 数据顺序刷到缓存。)，又包含了 Invalidate Queue 的等待环节，但现实场景下，我们可能只需要与其中一个数据结构打交道即可。于是，CPU 的设计者把 smp_mb 屏障进一步拆分，一分为二， smp_rmb 称之为读内存屏障，smp_wmb 称之为写内存屏障。他们分别的语义也相应做了简化：</li></ul><p>mfence指令实现了Full Barrier，相当于StoreLoad Barriers。</p><ul><li>**smp_wmb(StoreStore)**：执行后需等待 Store Buffer 中的写入变更 flush 完全到缓存后，后续的写操作才能继续执行，保证执行前后的写操作对其他 CPU 而言是顺序执行的；</li><li>**smp_rmb(LoadLoad)**：执行后需等待 Invalidate Queue 完全应用到缓存后，后续的读操作才能继续执行，保证执行前后的读操作对其他 CPU 而言是顺序执行的；</li></ul><h3 id="1-2-1-mb-与mfence"><a href="#1-2-1-mb-与mfence" class="headerlink" title="1.2.1. mb()与mfence"></a>1.2.1. mb()与mfence</h3><ul><li>**<em>在x86 UP体系架构中</em>**，smp_mb、smp_rmb、smp_wmb被翻译成barrier：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)<br></code></pre></td></tr></table></figure><p>__volatile告诉编译器此条语句不进行任何优化，””: : :”memory” 内存单元已被修改、需要重新读入。</p><ul><li>**<em>在x86 SMP体系架构中</em>**，smp_mb、smp_rmb、smp_wmb如下定义：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">/arch/x86/include/asm/system.h：<br>352 /*<br>353  * Force strict CPU ordering.<br>354  * And yes, this is required on UP too when we&#x27;re talking<br>355  * to devices.<br>356  */<br>357 #ifdef CONFIG_X86_32<br>358 /*<br>359  * Some non-Intel clones support out of order store. wmb() ceases to be a<br>360  * nop for these.<br>361  */<br>362 #define mb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;mfence&quot;, X86_FEATURE_XMM2)<br>363 #define rmb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;lfence&quot;, X86_FEATURE_XMM2)<br>364 #define wmb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;sfence&quot;, X86_FEATURE_XMM)<br>365 #else<br>366 #define mb()    asm volatile(&quot;mfence&quot;:::&quot;memory&quot;)<br>367 #define rmb()   asm volatile(&quot;lfence&quot;:::&quot;memory&quot;)<br>368 #define wmb()   asm volatile(&quot;sfence&quot; ::: &quot;memory&quot;)<br>369 #endif<br></code></pre></td></tr></table></figure><ul><li><p>362<del>364行针对x86的32位CPU，366</del>368行针对x86的64位CPU。</p></li><li><p>在x86的64位CPU中，mb()宏实际为：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">asm volatile(&quot;sfence&quot; ::: &quot;memory&quot;)。<br>volatile告诉编译器严禁在此处汇编语句与其它语句重组优化，memory强制编译器假设RAM所有内存单元均被汇编指令修改，&quot;sfence&quot; ::: 表示在此插入一条串行化汇编指令sfence。<br>mfence：串行化发生在mfence指令之前的读写操作<br>lfence：串行化发生在mfence指令之前的读操作、但不影响写操作<br>sfence：串行化发生在mfence指令之前的写操作、但不影响读操作<br></code></pre></td></tr></table></figure><ul><li>在x86的32位CPU中，mb()宏实际为：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">mb() alternative(&quot;lock; addl $0,0(%%esp)&quot;, &quot;mfence&quot;, X86_FEATURE_XMM2)<br><br>由于x86的32位CPU有可能不提供mfence、lfence、sfence三条汇编指令的支持，故在不支持mfence的指令中使用：&quot;lock; addl $0,0(%%esp)&quot;, &quot;mfence&quot;。lock表示将“addl $0,0(%%esp)”语句作为内存屏障。<br></code></pre></td></tr></table></figure><h2 id="1-3-JVM屏障"><a href="#1-3-JVM屏障" class="headerlink" title="1.3. JVM屏障"></a>1.3. JVM屏障</h2><p>JVM 按前后分别有读、写两种操作以全排列方式一共提供了四种 Barrier，名称就是左右两边操作的名字拼接。比如 <code>LoadLoad</code> Barrier 就是放在两次 Load 操作中间的 Barrier，<code>LoadStore</code> 就是放在 Load 和 Store 中间的 Barrier。Barrier 类型及其含义如下：</p><ul><li><code>LoadLoad</code>，操作序列 Load1, LoadLoad, Load2，用于保证访问 Load2 的读取操作一定不能重排到 Load1 之前。类似于前面说的 <code>Read Barrier</code>，需要先处理 Invalidate Queue 后再读 Load2；</li><li><code>StoreStore</code>，操作序列 Store1, StoreStore, Store2，用于保证 Store1 及其之后写出的数据一定先于 Store2 写出，即别的 CPU 一定先看到 Store1 的数据，再看到 Store2 的数据。可能会有一次 Store Buffer 的刷写，也可能通过所有写操作都放入 Store Buffer 排序来保证；</li><li><code>LoadStore</code>，操作序列 Load1, LoadStore, Store2，用于保证 Store2 及其之后写出的数据被其它 CPU 看到之前，Load1 读取的数据一定先读入缓存。甚至可能 Store2 的操作依赖于 Load1 的当前值。这个 Barrier 的使用场景可能和上一节讲的 Cache 架构模型很难对应，毕竟那是一个极简结构，并且只是一种具体的 Cache 架构，而 JVM 的 Barrier 要足够抽象去应付各种不同的 Cache 架构。如果跳出上一节的 Cache 架构来说，我理解用到这个 Barrier 的场景可能是说某种 CPU 在写 Store2 的时候，认为刷写 Store2 到内存，将其它 CPU 上 Store2 所在 Cache Line 设置为无效的速度要快于从内存读取 Load1，所以做了这种重排。</li><li><code>StoreLoad</code>，操作序列 Store1, StoreLoad, Load2，用于保证 Store1 写出的数据被其它 CPU 看到后才能读取 Load2 的数据到缓存。如果 Store1 和 Load2 操作的是同一个地址，StoreLoad Barrier 需要保证 Load2 不能读 Store Buffer 内的数据，得是从内存上拉取到的某个别的 CPU 修改过的值。<code>StoreLoad</code> 一般会认为是最重的 Barrier 也是能实现其它所有 Barrier 功能的 Barrier。</li></ul><p>对上面四种 Barrier 解释最好的是来自这里：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/6bab0f539fba8fb441697846347597b4a0ade428/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/MemoryBarriers.java">jdk&#x2F;MemoryBarriers.java at 6bab0f539fba8fb441697846347597b4a0ade428 · openjdk&#x2F;jdk · GitHub</a></p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load2</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><p><code>StoreLoad</code> 为什么能实现其它 Barrier 的功能？</p><p>这个也是从前一个问题结果能看出来的。<code>StoreLoad</code> 因为对读写操作均有要求，所以它能实现其它 Barrier 的功能。其它 Barrier 都是只对读写之中的一个方面有要求。</p><p>不过这四个 Barrier 只是 Java 为了跨平台而设计出来的，实际上根据 CPU 的不同，对应 CPU 平台上的 JVM 可能可以优化掉一些 Barrier。比如很多 CPU 在读写同一个变量的时候能保证它连续操作的顺序性，那就不用加 Barrier 了。比如 <code>Load x; Load x.field</code> 读 x 再读 x 下面某个 field，如果访问同一个内存 CPU 能保证顺序性，两次读取之间的 Barrier 就不再需要了，根据字节码编译得到的汇编指令中，本来应该插入 Barrier 的地方会被替换为 <code>nop</code>，即空操作。在 x86 上，实际只有 <code>StoreLoad</code> 这一个 Barrier 是有效的，x86 上没有 Invalidate Queue，每次 Store 数据又都会去 Store Buffer 排队，所以 <code>StoreStore</code>， <code>LoadLoad</code> 都不需要。x86 又能保证 Store 操作都会走 Store Buffer 异步刷写，Store 不会被重排到 Load 之前，<code>LoadStore</code> 也是不需要的。只剩下一个 <code>StoreLoad</code> Barrier 在 x86 平台的 JVM 上被使用。<br>来自这里：<a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/9a69bb807beb6693c68a7b11bee435c0bab7ceac/src/hotspot/cpu/x86/assembler_x86.hpp">jdk&#x2F;assembler_x86.hpp at 9a69bb807beb6693c68a7b11bee435c0bab7ceac · openjdk&#x2F;jdk · GitHub</a> 看到 x86 下使用的是 lock 来实现 <code>StoreLoad</code>，并且只处理了 <code>StoreLoad</code>。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116140129.png"></p><p>对于x86架构的cpu来说，在单核上来看，其保证了Sequential consistency，因此对于开发者，我们可以完全不用担心单核上的乱序优化会给我们的程序带来正确性问题。在多核上来看，其保证了x86-tso模型，使用mfence就可以将store buffer中的数据，写入到cache中。而且，<span style="background-color:#0f0">由于x86架构下，store buffer是FIFO的和不存在invalid queue，mfence能够保证多核间的数据可见性，以及顺序性</span>。</p><p>对于arm和power架构的cpu来说，编程就变得危险多了。除了存在数据依赖，控制依赖以及地址依赖等的前后指令不能被乱序之外，其余指令间都有可能存在乱序。而且，它们的store buffer并不是FIFO的，而且还可能存在invalid queue，这些也同样让并发编程变得困难重重。因此需要引入不同类型的barrier来完成不同的需求。</p><p>根据上面表格我们可以看到 x86 平台下，只有 StoreLoad 才有具体的指令对应，而其他三个屏障均是 no-op (空操作)。</p><p>关于 StoreLoad 又有三个具体的指令对应，分别是 <span style="background-color:#ff0">mfence、cpuid、以及 locked insn</span>，他们都能很好地实现 StoreLoad 的屏障效果。但毕竟不可能同时用三种指令，这里可能意思是，三种均能达到效果，具体实现交由 JVM 设计者决断。</p><p>我们随便写一段代码，查看下JVM采用的是哪一种命令(需要下载 hsdis-amd64.dylib 然后移动到 jre lib 目录)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>VolatileTest.<span class="hljs-keyword">java </span>&amp;&amp; <span class="hljs-keyword">java </span>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> &#123;<br><br>		<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>				test();<br>		&#125;<br><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span>&#123;<br>				a++;<br>		&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里的 StoreLoad 用到的具体指令是lock</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x000000010dfedef8</span>: <span class="hljs-keyword">lock</span> addl <span class="hljs-number">$0</span>x0,(%rsp)<br><span class="hljs-number">0x000000010dfedefd</span>: cmpl   <span class="hljs-number">$0</span>x0,-<span class="hljs-number">0x32f1197</span>(%rip)        # <span class="hljs-number">0x000000010acfcd70</span><br>                                              <span class="hljs-comment">;   &#123;external_word&#125;</span><br><span class="hljs-number">0x000000010dfedf07</span>: <span class="hljs-keyword">jne</span>    <span class="hljs-number">0x000000010dfedf1b</span><br></code></pre></td></tr></table></figure><p>lock用于在多处理器中执行指令时对共享内存的独占使用。它的副作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。另外还提供了有序的指令无法越过这个内存屏障的作用。</p><p>简单来说，这句指令的作用就是保证了可见性以及内存屏障。</p><ul><li>执行 a 的写操作后执行到 StoreLoad 内存屏障；</li><li>发出 Lock 指令，锁总线 或 a 的缓存行，那么其他 CPU 不能对已上锁的缓存行有任何操作；</li><li>让其他 CPU 持有的 a 的缓存行失效；</li><li>将 a 的变更写回主内存，保证全局可见；</li></ul><p>上面执行完后，该 CPU 方可执行后续操作。</p><p>JVM 是如何分别插入上面四种内存屏障到指令序列之中的呢？这里的设计相当巧妙。</p><p>对于 volatile 读 or monitor enter</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> t = x; <span class="hljs-comment">// x 是 volatile 变量</span><br>[<span class="hljs-meta">LoadLoad</span>]<br>[<span class="hljs-meta">LoadStore</span>]<br>&lt;other ops&gt;<br></code></pre></td></tr></table></figure><p>对于 volatile 写 or monitor exit</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;other ops&gt;<br>[<span class="hljs-meta">StoreStore</span>]<br>[<span class="hljs-meta">LoadStore</span>]<br>x = <span class="hljs-number">1</span>; <span class="hljs-comment">// x 是 volatile 变量</span><br>[<span class="hljs-meta">StoreLoad</span>] <span class="hljs-comment">// 这里带了个尾巴</span><br></code></pre></td></tr></table></figure><h3 id="1-3-1-其他分类"><a href="#1-3-1-其他分类" class="headerlink" title="1.3.1. 其他分类"></a>1.3.1. 其他分类</h3><p>1、按照可见性划分，也就是解决并发问题的可见性：</p><p>加载屏障（Load Barrier）：相当于上面的LoadStoreBarrier，也对应JMM 8种基本操作中的load（载入）</p><p>存储屏障（Store Barrier）：相当于上面的StoreLoadBarrier，也对应JMM 8种基本操作中的Store（存储）</p><p>2、按照有序性划分，也就是解决了并发问题中的有序性：</p><p>获取屏障（Acquire Barrier）：相当于上面的LoadLoadBarrier和LoadStoreBarrier组合</p><p>释放屏障（Release Barrier）：相当于LoadStoreBarrier和StoreStoreBarrier组合</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/it_lihongmin/article/details/109169260">https://blog.csdn.net/it_lihongmin/article/details/109169260</a></p><h3 id="1-3-2-StoreLoad-最重"><a href="#1-3-2-StoreLoad-最重" class="headerlink" title="1.3.2. StoreLoad 最重"></a>1.3.2. StoreLoad 最重</h3><p>所谓的重实际就是跟内存交互次数，交互越多延迟越大，也就是越重。<code>StoreStore</code>， <code>LoadLoad</code> 两个都不提了，因为它俩要么只限制读，要么只限制写，也即只有一次内存交互。只有 <code>LoadStore</code> 和 <code>StoreLoad</code> 看上去有可能对读写都有限制。但 <code>LoadStore</code> 里实际限制的更多的是读，即 Load 数据进来，它并不对最后的 Store 存出去数据的可见性有要求，只是说 Store 不能重排到 Load 之前。而反观 <code>StoreLoad</code>，它是说不能让 Load 重排到 Store 之前，这么一来得要求在 Load 操作前刷写 Store Buffer 到内存。不去刷 Store Buffer 的话，就可能导致先执行了读取操作，之后再刷 Store Buffer 导致写操作实际被重排到了读之后。而数据一旦刷写出去，别的 CPU 就能看到，看到之后可能就会修改，下一步 Load 操作的内存导致 Load 操作的内存所在 Cache Line 无效。如果允许 Load 操作从一个可能被 Invalidate 的 Cache Line 里读数据，则表示 Load 从实际意义上来说被重排到了 Store 之前，因为这个数据可能是 Store 前就在 Cache 中的，相当于读操作提前了。为了避免这种事发生，Store 完成后一定要去处理 Invalidate Queue，去判断自己 Load 操作的内存所在 Cache Line 是否被设置为无效。这么一来为了满足 <code>StoreLoad</code> 的要求，一方面要刷 Store Buffer，一方面要处理 Invalidate Queue，则最差情况下会有两次内存操作，读写分别一次，所以它最重。</p><h1 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h1><p>Acquire与Release语义<br>对于Acquire来说，保证Acquire后的读写操作不会发生在Acquire动作之前<br>对于Release来说，保证Release前的读写操作不会发生在Release动作之后<br>Acquire &amp; Release 语义保证内存操作仅在acquire和release屏障之间发生</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221125191646.png"></p><p>X86-64中Load读操作本身满足Acquire语义，Store写操作本身也是满足Release语义。但Store-Load操作间等于没有保护，因此仍需要靠mfence或lock等指令才可以满足到Synchronizes-with规则。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221125195347.png"></p><h1 id="3-LOCK指令"><a href="#3-LOCK指令" class="headerlink" title="3. LOCK指令"></a>3. LOCK指令</h1><ol><li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，因为锁总线的开销比较大，后来的处理器都采用锁缓存替代锁总线，在无法使用缓存锁的时候会降级使用总线锁</li><li>lock期间的写操作会回写已修改的数据到主内存，同时通过缓存一致性协议让其它CPU相关缓存行失效</li></ol><p>x86 体系下的 LOCK 信号（在汇编里给指令加上 LOCK 前缀），通过锁定总线，禁止其他 CPU 对内存的操作来保证原子性。但这样的锁粒度太粗，其他无关的内存操作也会被阻塞，大幅降低系统性能，而随着核数逐渐增加该问题会愈发显著 —— 要知道现在连家用 CPU 都有16核了。</p><p>因此 Intel 在 Pentium 486 开始引入了用于保证缓存一致性的 MESI 协议，通过锁定对应的 cache line，使得其他 core 无法修改指定内存，从而实现了原子操作（缓存锁）</p><p><code>总线锁</code>、<code>缓存锁</code>可以保证<code>原子性</code>，<code>缓存一致性协议</code>可以保证<code>可见性</code>，</p><h2 id="3-1-总线锁"><a href="#3-1-总线锁" class="headerlink" title="3.1. 总线锁"></a>3.1. 总线锁</h2><p>总线索就是使用处理器提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。</p><p>在多 cpu 下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个 LOCK# 信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据，总线锁定把 CPU 和内存之间的通信锁住了，这使得锁定期间，其他处理器<strong>不能操作其他内存地址的数据</strong>，<strong>总线锁定的开销比较大</strong>，这种机制显然是<strong>不合适</strong>的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">总线锁的力度太大了，最好的方法就是控制锁的保护粒度，只需要保证对于被多个 CPU 缓存的同一份数据是一致的就可以了。所以引入了缓存锁。<br></code></pre></td></tr></table></figure><h2 id="3-2-缓存锁"><a href="#3-2-缓存锁" class="headerlink" title="3.2. 缓存锁"></a>3.2. 缓存锁</h2><p>由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。</p><p><code>缓存锁</code>就是指内存区域如果被缓存在处理器的缓存行中，并且在<code>LOCK#</code>操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言<code>LOCK#</code>信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效</p><p>相比总线锁，缓存锁即降低了锁的力度。核心机制是基于缓存一致性协议来实现的。</p><h2 id="3-3-使用场景"><a href="#3-3-使用场景" class="headerlink" title="3.3. 使用场景"></a>3.3. 使用场景</h2><p>如上面所说，在多数情况下，处理器还是使用缓存锁来代替总线锁，但是在下面两种情况下，我们还是使用总线锁来完成相应保证一致性。</p><ol><li>情况1：当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，则处理器会字调用总线锁锁定。</li><li>情况2：有些处理器不支持缓存行锁定。</li></ol><h2 id="3-4-lock的实现"><a href="#3-4-lock的实现" class="headerlink" title="3.4. lock的实现"></a>3.4. lock的实现</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">关于lock的实现：cpu上有一根pin #HLOCK连到北桥,lock前缀会在执行这条指令前先去拉这根pin，持续到这个指令结束时放开#HLOCK pin，在这期间，北桥会屏蔽掉一切外设以及AGP的内存操作。也就保证了这条指令的atomic。<br></code></pre></td></tr></table></figure><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;内存屏障 – Part 1 - innohub]]<br>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;内核同步机制-优化屏障和内存屏障-阿里云开发者社区]]</p><h1 id="4-实战经验"><a href="#4-实战经验" class="headerlink" title="4. 实战经验"></a>4. 实战经验</h1><h1 id="5-参考与感谢"><a href="#5-参考与感谢" class="headerlink" title="5. 参考与感谢"></a>5. 参考与感谢</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Courage129/p/14360186.html">https://www.cnblogs.com/Courage129/p/14360186.html</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/">https://taylorluo.github.io/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/justlovesmile-img/cover7.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/26/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-11%E3%80%81%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover7.JPG" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发编程专题-基础-11、乱序问题</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/19/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-9%E3%80%81JVM-%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"><img class="next-cover" src="https://picsum.photos/1920/1083" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">性能调优专题-基础-9、JVM-HSDB</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/26/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-11%E3%80%81%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/" title="并发编程专题-基础-11、乱序问题"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover7.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-27</div><div class="title">并发编程专题-基础-11、乱序问题</div></div></a></div><div><a href="/2022/11/10/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-6%E3%80%81CAS/" title="并发编程专题-基础-6、CAS"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">并发编程专题-基础-6、CAS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发编程专题-基础-7、Thread"><img class="cover" src="https://picsum.photos/1920/912" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-7、Thread</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-4、信号量与管程"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-4、信号量与管程</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-5%E3%80%81%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-5、进程 线程 纤程 协程 管程"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-5、进程 线程 纤程 协程 管程</div></div></a></div><div><a href="/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/" title="并发编程专题-基础-12、AQS"><img class="cover" src="https://picsum.photos/1920/1084" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">并发编程专题-基础-12、AQS</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%B1%8F%E9%9A%9C%E5%88%86%E7%B1%BB"><span class="toc-text">1. 屏障分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%BC%96%E8%AF%91%E5%99%A8%E5%B1%8F%E9%9A%9C-%E4%BC%98%E5%8C%96%E5%B1%8F%E9%9A%9C"><span class="toc-text">1.1. 编译器屏障(优化屏障)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-%E6%9C%BA%E5%99%A8%E5%B1%8F%E9%9A%9C"><span class="toc-text">1.2. 内存屏障(机器屏障)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-mb-%E4%B8%8Emfence"><span class="toc-text">1.2.1. mb()与mfence</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-JVM%E5%B1%8F%E9%9A%9C"><span class="toc-text">1.3. JVM屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB"><span class="toc-text">1.3.1. 其他分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-StoreLoad-%E6%9C%80%E9%87%8D"><span class="toc-text">1.3.2. StoreLoad 最重</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. 内存模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-LOCK%E6%8C%87%E4%BB%A4"><span class="toc-text">3. LOCK指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%80%BB%E7%BA%BF%E9%94%81"><span class="toc-text">3.1. 总线锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BC%93%E5%AD%98%E9%94%81"><span class="toc-text">3.2. 缓存锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.3. 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-lock%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.4. lock的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">4. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">5. 参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://unpkg.com/justlovesmile-img/cover7.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>