<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程专题-基础-8、Volatile | Taylor</title><meta name="keywords" content="并发编程专题,关键字"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 简要回答   2. 乱序问题并发基础-11、乱序问题  3. 前置知识3.1. JMM 原子操作3.1.1. JMM 及 MESI请看 并发基础-1、JMM与MESI   Volatile 保证了 JMM 三大特性的可见性和有序性，但无法保证原子性 (Synchronized 保证了可见性、有序性和原子性)。 3.2. 可见性3.2.1. 可见性原理 1、在对变量进行 assign 操作时，"><meta property="og:type" content="article"><meta property="og:title" content="并发编程专题-基础-8、Volatile"><meta property="og:url" content="https://taylorluo.github.io/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-8%E3%80%81Volatile/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 简要回答   2. 乱序问题并发基础-11、乱序问题  3. 前置知识3.1. JMM 原子操作3.1.1. JMM 及 MESI请看 并发基础-1、JMM与MESI   Volatile 保证了 JMM 三大特性的可见性和有序性，但无法保证原子性 (Synchronized 保证了可见性、有序性和原子性)。 3.2. 可见性3.2.1. 可见性原理 1、在对变量进行 assign 操作时，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/1080"><meta property="article:published_time" content="2022-11-12T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.684Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="并发编程专题"><meta property="article:tag" content="关键字"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/1080"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-8%E3%80%81Volatile/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程专题-基础-8、Volatile",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/1080')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程专题-基础-8、Volatile</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-12T16:00:00.000Z" title="发表于 2022-11-13 00:00:00">2022-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.684Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="并发编程专题-基础-8、Volatile"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-8%E3%80%81Volatile/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-简要回答"><a href="#1-简要回答" class="headerlink" title="1. 简要回答"></a>1. 简要回答</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512160700.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512160916.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230512160948.png" alt="image.png"></p><h1 id="2-乱序问题"><a href="#2-乱序问题" class="headerlink" title="2. 乱序问题"></a>2. 乱序问题</h1><a href="/2022/11/26/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-11%E3%80%81%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/" title="并发基础-11、乱序问题">并发基础-11、乱序问题</a><h1 id="3-前置知识"><a href="#3-前置知识" class="headerlink" title="3. 前置知识"></a>3. 前置知识</h1><h2 id="3-1-JMM-原子操作"><a href="#3-1-JMM-原子操作" class="headerlink" title="3.1. JMM 原子操作"></a>3.1. JMM 原子操作</h2><h3 id="3-1-1-JMM-及-MESI"><a href="#3-1-1-JMM-及-MESI" class="headerlink" title="3.1.1. JMM 及 MESI"></a>3.1.1. JMM 及 MESI</h3><p>请看 <a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/" title="并发基础-1、JMM与MESI">并发基础-1、JMM与MESI</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221102090503.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221113222951.png"></p><p><span style="background-color:#f0f">Volatile 保证了 JMM 三大特性的可见性和有序性，但无法保证原子性 (Synchronized 保证了可见性、有序性和原子性)。</span></p><h2 id="3-2-可见性"><a href="#3-2-可见性" class="headerlink" title="3.2. 可见性"></a>3.2. 可见性</h2><h3 id="3-2-1-可见性原理"><a href="#3-2-1-可见性原理" class="headerlink" title="3.2.1. 可见性原理"></a>3.2.1. 可见性原理</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121637.jpg" alt="image-20200128202356235"></p><p>1、<strong>在对变量进行 assign 操作时</strong>，加了 Volatile 修饰的变量，计算机底层会加一个 <strong>lock 前缀指令</strong>（这个操作利用了 MESI 协议对 M 状态变量的处理逻辑，向总线发送 Invalid 信息，并立即写回主内存）。</p><p>2、同时，<strong>lock 前缀指令</strong> 有内存屏障的作用，在 assign 的时候就对变量施加了 <strong>缓存锁</strong>，防止读取未修改的数据。</p><h3 id="3-2-2-JVM-源码实现"><a href="#3-2-2-JVM-源码实现" class="headerlink" title="3.2.2. JVM 源码实现"></a>3.2.2. JVM 源码实现</h3><p>bytecodeinterpreter.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> field_offset = cache-&gt;<span class="hljs-built_in">f2_as_index</span>();  <br>          <span class="hljs-keyword">if</span> (cache-&gt;<span class="hljs-built_in">is_volatile</span>()) &#123;  <br>            <span class="hljs-keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;  <br>              OrderAccess::<span class="hljs-built_in">fence</span>();  <br>            &#125;<br></code></pre></td></tr></table></figure><p>orderaccess_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">OrderAccess::fence</span><span class="hljs-params">()</span> </span>&#123;  <br>  <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">is_MP</span>()) &#123;  <br>    <span class="hljs-comment">// always use locked addl since mfence is sometimes expensive  </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AMD64  </span><br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  </span><br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3. 有序性"></a>3.3. 有序性</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121653.jpg" alt="image-20200409104711867"></p><h3 id="3-3-1-指令重排序"><a href="#3-3-1-指令重排序" class="headerlink" title="3.3.1. 指令重排序"></a>3.3.1. 指令重排序</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40cb45484f1e">https://www.jianshu.com/p/40cb45484f1e</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121705.jpg" alt="image-20200321232720870"></p><p>举例：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121726.jpg" alt="image-20200407142617599"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121739.jpg" alt="image-20200409110052812"></p><h3 id="3-3-2-volatile-禁止重排的原理"><a href="#3-3-2-volatile-禁止重排的原理" class="headerlink" title="3.3.2. volatile 禁止重排的原理"></a>3.3.2. volatile 禁止重排的原理</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121747.jpg" alt="image-20200321233516250"></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae9b41b518825670b33e6c4">https://juejin.im/post/5ae9b41b518825670b33e6c4</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121757.jpg" alt="image-20200407143515457"></p><h4 id="3-3-2-1-读操作"><a href="#3-3-2-1-读操作" class="headerlink" title="3.3.2.1. 读操作"></a>3.3.2.1. 读操作</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122144.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122328.png"></p><h4 id="3-3-2-2-写操作"><a href="#3-3-2-2-写操作" class="headerlink" title="3.3.2.2. 写操作"></a>3.3.2.2. 写操作</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122438.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221116210838.webp"></p><h3 id="3-3-3-JVM-实现"><a href="#3-3-3-JVM-实现" class="headerlink" title="3.3.3. JVM 实现"></a>3.3.3. JVM 实现</h3><p><a href="#5-2-CPU%E4%B9%B1%E5%BA%8F%E6%9D%A5%E6%BA%90">CPU乱序来源</a></p><h2 id="3-4-不保证原子性"><a href="#3-4-不保证原子性" class="headerlink" title="3.4. 不保证原子性"></a>3.4. 不保证原子性</h2><h4 id="3-4-1-为什么"><a href="#3-4-1-为什么" class="headerlink" title="3.4.1. 为什么"></a>3.4.1. 为什么</h4><p>1、诸葛结合了 volatile，把原因归结为写无效，比如 2 个线程都 use 后计算了新值，线程 2 出了问题没来得及 assign，没有触发 MESI 协议，但是第一个线程正常触发 MESI 协议，线程 2 也通过总线嗅探机制，收到了已经变化的信号，那么第 2 个线程没来得及 assign 的新值就失效了，那么也就白加了，导致了丢失 ++ 操作</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121810.jpg" alt="image-20200321222329981"></p><p>2、尚硅谷 - 周阳讲把原因归结为写覆盖，比如 2 个线程都 use 后计算出了新值，线程 2 出了问题没来得及 assign 触发 MESI 协议，但是第一个线程正常触发 MESI 协议，但是线程 2 由于某种原因没有收到了已经变化的信号，那么第 2 个线程 assign 的新值也执行了 store-write 操作，那么第一个线程的加操作被覆盖了，导致了丢失 ++ 操作</p><p>一句话：将要 assign-store-write 的这个原子性操作，被挂起或者其他原因，没有收到其他线程的 M 消息，也就没有正常去失效自己之前将要的 assign-store-write 的新变量值，线程恢复时去更改主内存，那么就覆盖其他线程的操作。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121819.jpg" alt="image-20200321222558008"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121827.jpg" alt="image-20200321222749028"></p><p>我们看到 jvm 通过 lock 实现了 volatile 的内存屏障，但是 volatile 并不具有原子性。原因很简单，不同 CPU 依旧可以对同一个缓存行持有，一个 CPU 对同一个缓存行的修改不能让另一个 CPU 及时感知，因此出现并发冲突。线程安全还是需要用锁来保障，锁能有效的让 CPU 在同一个时刻独占某个缓存行，执行完并释放锁后，其他 CPU 才能访问该缓存行。</p><p>L1 缓存中的变量有两种赋值方式, 一种是从内存加载进来, 另一种是从寄存器回写过来的. </p><p>因为缓存一致性协议只能失效缓存行的数据, 而不能失效寄存器的数据, 导致 volatile 不能做到原子性.</p><p>volatile 和 cas 都是基于 lock 前缀实现，但 volatile 却无法保证原子性这是因为：Lock 前缀只能保证缓存一致性，但不能保证寄存器中数据的一致性，如果指令在 lock 的缓存刷新生效之前把数据写入了寄存器，那么寄存器中的数据不会因此失效而是继续被使用，就好像数据库中的事务执行失败却没有回滚，原子性就被破坏了。以被 volatile 修饰的 i 作 i++ 为例，实际上分为 4 个步骤：<br>mov　　　　 0xc(%r10),%r8d ; 把 i 的值赋给寄存器<br>inc　　　　　%r8d　　　　　 ; 寄存器的值 +1<br>mov　　　　 %r8d,0xc(%r10) ; 把寄存器的值写回<br><span style="background-color:#f0f">lock addl　　$0x0,(%rsp)　　; 内存屏障，禁止指令重排序，并同步所有缓存</span><br>　<br>如果两个线程 AB 同时把 i 读进自己的寄存器，此时 B 线程等待，A 线程继续工作，把 i++ 后放回内存。按照原子性的性质，此时 B 应该回滚，重新从内存中读取 i，但因为此时 i 已经拷贝到寄存器中，所以 B 线程会继续运行，原子性被破坏。<br>　<br>而 cas 没有这个问题，因为 cas 操作对应指令只有一个：<br><code>lock cmpxchg dword ptr [edx], ecx ;</code><br>　<br>该指令确保了直接从内存拿数据（ptr [edx]），然后放回内存这一系列操作都在 lock 状态下，所以是原子性的。<br>　<br>总结：volatile 之所以不是原子性的原因是 jvm 对 volatile 语义的实现只是在 volatile 写后面加一个内存屏障，而内存屏障前的操作不在 lock 状态下，这些操作可能会把数据放入寄存器从而导致无法有效同步；cas 能保证原子性是因为 cas 指令只有一个，这个指令从头到尾都是在 lock 状态下而且从内存到内存，所以它是原子性的。</p><h4 id="3-4-2-如何保证"><a href="#3-4-2-如何保证" class="headerlink" title="3.4.2. 如何保证"></a>3.4.2. 如何保证</h4><p>使用原子包装的整形类，比如 AtomicInteger，原子类的底层是 CAS 原理</p><h2 id="3-5-Happens-Before"><a href="#3-5-Happens-Before" class="headerlink" title="3.5. Happens-Before"></a>3.5. Happens-Before</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP?p=174">https://www.bilibili.com/video/BV1yE411Z7AP?p=174</a></p><p><code>HappenBefore，规定了哪些写操作对其他线程的读操作可见，它是可见性和有序性一些规则的总和，解决的是可见性问题</code><br>定义：前一个操作的结果对于后续操作是可见的。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在 happens-before 关系。这两个操作可以是同一个线程，也可以是不同的线程。</p><p>JMM 中有哪些方法建立 happen-before 规则：</p><ul><li>1、<strong>as-if-serial 规则（程序顺序执行）</strong>：单个线程中的代码顺序不管怎么重排序，对于结果来说是不变的。</li><li>2、<strong>volatile 变量规则</strong>，对于 volatile 修饰的变量的写的操作， 一定 happen-before 后续对于 volatile 变量的读操作;</li><li>3、<strong>监视器锁规则（monitor lock rule）</strong>：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。</li><li>4、<strong>传递性规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>5、<strong>start 规则</strong>：如果线程 A 执行操作 ThreadB.start(),那么线程 A 的 ThreadB.start() 操作 happens-before 线程 B 中的任意操作。</li><li>6、<strong>join 规则</strong>：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</li></ul><h3 id="3-5-1-具体案例"><a href="#3-5-1-具体案例" class="headerlink" title="3.5.1. 具体案例"></a>3.5.1. 具体案例</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121837.jpg" alt="image-20200402165219887"></p><p><strong>线程之间解锁、加锁传递时，之前的写是可见的</strong></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121844.jpg" alt="image-20200402165252509"></p><p><strong>开始前的自己可以看，结束后的别人可以看</strong></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121855.jpg" alt="image-20200402165400484"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121907.jpg" alt="image-20200402165418405"></p><p>这里主线程 (或其他线程) 得知 t2 被打断之后，读取 x 的值是修改后的，当然 while 循环中 t2 被打断后，t2 自己的读也是可以读到的。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121916.jpg" alt="image-20200402165638180"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121923.jpg" alt="image-20200407131343816"></p><h2 id="3-6-与-MESI-的关系"><a href="#3-6-与-MESI-的关系" class="headerlink" title="3.6. 与 MESI 的关系"></a>3.6. 与 MESI 的关系</h2><p><strong>在多核 cpu 中通过缓存一致性协议保证了每个缓存中使用的共享变量的副本是一致的</strong>。</p><p>当一个 CPU 进行写入时，首先会给其它 CPU 发送 Invalid 消息，然后把当前写入的数据写入到 Store Buffer 中。然后异步在某个时刻真正的写入到 Cache 中。当前 CPU 核如果要读 Cache 中的数据，需要先扫描 Store Buffer 之后再读取 Cache。但是此时其它 CPU 核是看不到当前核的 Store Buffer 中的数据的，要等到 Store Buffer 中的数据被刷到了 Cache 之后才会触发失效操作。而当一个 CPU 核收到 Invalid 消息时，会把消息写入自身的 Invalidate Queue 中，随后异步将其设为 Invalid 状态。和 Store Buffer 不同的是，当前 CPU 核心使用 Cache 时并不扫描 Invalidate Queue 部分，所以可能会有极短时间的脏读问题。MESI 协议，可以保证缓存的一致性，但是无法保证实时性。所以我们需要通过内存屏障在执行到某些指令的时候强制刷新缓存来达到一致性。</p><p><strong>但是 MESI 只是一种抽象的协议规范，在不同的 cpu 上都会有不同的实现</strong>，对于 x86 架构来说，store buffer 是 FIFO，写入顺序就是刷入 cache 的顺序。但是对于 ARM&#x2F;Power 架构来说，store buffer 并未保证 FIFO，因此先写入 store buffer 的数据，是有可能比后写入 store buffer 的数据晚刷入 cache 的</p><p>而对于 JAVA 而言，他必须要屏蔽各个处理器的差异，所以才有了 java 内存模型 (JMM),volatile 只是内存模型的一小部分，实现了变量的可见性和禁止指令重排序优化的功能。整个内存模型必须要实现可见性，原子性，和有序性。而 volatile 实现了其中的可见性和有序性。</p><p>在我的理解中，<span style="background-color:#0f0">MESI 协议是实现 volatile 的所有语义的基础</span>，在我们对一个变量加上 volitile 之后，该变量的操作的指令前就会带有 LOCK#前缀，该前缀在 intel 的文档里面说的很清楚,可以通过上面的链接查看，这里只列举出部分</p><p>Lock 前缀具有如下作用：</p><p>带有 lock 前缀的指令在执行的时候会锁住总线或者利用 MESI 协议这两种方式来保证指令执行的原子性，<br>禁止该指令，与之前和之后的读和写指令重排序<br>把缓冲区的所有数据刷新到内存中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++">Argument <span class="hljs-number">0</span> is unknown.RIP: <span class="hljs-number">0x7f96b93132a0</span> Code size: <span class="hljs-number">0x00000150</span><br>[Entry Point]<br>[Verified Entry Point]<br>[Constants]<br>  # &#123;method&#125; &#123;<span class="hljs-number">0x00007f96b7106238</span>&#125; <span class="hljs-string">&#x27;main&#x27;</span> <span class="hljs-string">&#x27;([Ljava/lang/String;)V&#x27;</span> in <span class="hljs-string">&#x27;TestVolatile&#x27;</span><br>  # parm0:    rsi:rsi   = <span class="hljs-string">&#x27;[Ljava/lang/String;&#x27;</span><br>  #           [sp+<span class="hljs-number">0x40</span>]  (sp of caller)<br>  <span class="hljs-meta">#main方法入口</span><br>  <span class="hljs-number">0x00007f96b93132a0</span>: mov     %eax,<span class="hljs-number">0xfffffffffffec000</span>(%rsp)<br>  <span class="hljs-number">0x00007f96b93132a7</span>: push    %rbp<br>  <span class="hljs-number">0x00007f96b93132a8</span>: sub     $<span class="hljs-number">0x30</span>,%rsp<br>  <span class="hljs-number">0x00007f96b93132ac</span>: movabs  $<span class="hljs-number">0x7f96b7106300</span>,%rdi  ;   &#123;<span class="hljs-built_in">metadata</span>(method data <span class="hljs-keyword">for</span> &#123;method&#125; &#123;<span class="hljs-number">0x00007f96b7106238</span>&#125; <span class="hljs-string">&#x27;main&#x27;</span> <span class="hljs-string">&#x27;([Ljava/lang/String;)V&#x27;</span> in <span class="hljs-string">&#x27;TestVolatile&#x27;</span>)&#125;<br>  <span class="hljs-number">0x00007f96b93132b6</span>: mov     <span class="hljs-number">0xdc</span>(%rdi),%ebx<br>  <span class="hljs-number">0x00007f96b93132bc</span>: add     $<span class="hljs-number">0x8</span>,%ebx<br>  <span class="hljs-number">0x00007f96b93132bf</span>: mov     %ebx,<span class="hljs-number">0xdc</span>(%rdi)<br>  <span class="hljs-number">0x00007f96b93132c5</span>: movabs  $<span class="hljs-number">0x7f96b7106238</span>,%rdi  ;   &#123;<span class="hljs-built_in">metadata</span>(&#123;method&#125; &#123;<span class="hljs-number">0x00007f96b7106238</span>&#125; <span class="hljs-string">&#x27;main&#x27;</span> <span class="hljs-string">&#x27;([Ljava/lang/String;)V&#x27;</span> in <span class="hljs-string">&#x27;TestVolatile&#x27;</span>)&#125;<br>  <span class="hljs-number">0x00007f96b93132cf</span>: <span class="hljs-keyword">and</span>     $<span class="hljs-number">0x0</span>,%ebx<br>  <span class="hljs-number">0x00007f96b93132d2</span>: cmp     $<span class="hljs-number">0x0</span>,%ebx<br>  <span class="hljs-number">0x00007f96b93132d5</span>: je      <span class="hljs-number">0x7f96b931330c</span>    ;*bipush<br>                                                ; - TestVolatile::main@<span class="hljs-number">0</span> (line <span class="hljs-number">5</span>)<br> <br>  <span class="hljs-number">0x00007f96b93132db</span>: movabs  $<span class="hljs-number">0xf066da08</span>,%rsi  ;   &#123;<span class="hljs-built_in">oop</span>(a <span class="hljs-string">&#x27;java/lang/Class&#x27;</span> = <span class="hljs-string">&#x27;TestVolatile&#x27;</span>)&#125;<br>  #将<span class="hljs-number">9</span>赋值给edi寄存器<br>  <span class="hljs-number">0x00007f96b93132e5</span>: mov     $<span class="hljs-number">0x9</span>,%edi<br>  #将edi寄存器的值赋值给value<br>  <span class="hljs-number">0x00007f96b93132ea</span>: mov     %edi,<span class="hljs-number">0x68</span>(%rsi)<br>  #带lock前缀的加指令，把rsp所指向的地址中值加<span class="hljs-number">0</span>，这个指令没啥用，主要使用lock前缀做内存屏障的<br>  #防止lock之后的指令在lock之前执行，这里没使用mfence指令，主要是mfence在某些情况下比lock效率慢<br>  <span class="hljs-number">0x00007f96b93132ed</span>: lock addl $<span class="hljs-number">0x0</span>,(%rsp)     ;*putstatic value<br>                                                ; - TestVolatile::main@<span class="hljs-number">5</span> (line <span class="hljs-number">6</span>)<br>  #将value的值赋值给edi寄存器<br>  <span class="hljs-number">0x00007f96b93132f2</span>: mov     <span class="hljs-number">0x68</span>(%rsi),%edi   ;*getstatic value<br>                                                ; - TestVolatile::main@<span class="hljs-number">8</span> (line <span class="hljs-number">7</span>)<br>  #将edi寄存器加<span class="hljs-number">10</span><br>  <span class="hljs-number">0x00007f96b93132f5</span>: add     $<span class="hljs-number">0xa</span>,%edi<br>  #将edi寄存器赋值给value<br>  <span class="hljs-number">0x00007f96b93132f8</span>: mov     %edi,<span class="hljs-number">0x68</span>(%rsi)<br>  #加lock前缀做内存屏障，防止lock后的指令跑到lock前执行<br>  <span class="hljs-number">0x00007f96b93132fb</span>: lock addl $<span class="hljs-number">0x0</span>,(%rsp)     ;*putstatic value<br>                                                ; - TestVolatile::main@<span class="hljs-number">13</span> (line <span class="hljs-number">7</span>)<br>  #从main方法返回<br>  <span class="hljs-number">0x00007f96b9313300</span>: add     $<span class="hljs-number">0x30</span>,%rsp<br>  <span class="hljs-number">0x00007f96b9313304</span>: pop     %rbp<br>  <span class="hljs-number">0x00007f96b9313305</span>: test    %eax,<span class="hljs-number">0x165dcdf5</span>(%rip)  ;   &#123;poll_return&#125;<br>  <span class="hljs-number">0x00007f96b931330b</span>: retq<br></code></pre></td></tr></table></figure><p>看出来了什么没有，即使是加了 volatile 之后的变量，对应到的读取和写入指令都没有加上 Lock#前缀，从汇编语言中可以看到在对 volatile 变量赋值后会加一条 <code>lock addl $0x0,(%rsp)</code> 指令，lock 指令具有内存屏障的作用，lock 前后的指令不会重排序，<code>addl $0x0,(%rsp)</code> 是一条无意义的指令。所以说我们对 volatile 变量的操作其实还是不具有原子性，因为只是利用了#Lock 前缀保证了写操作会被马上刷新到内存而已，并没有保证 <code>读写改</code> 三个操作的原子性。<br>为什么是在写操作后面插入一条带有 Lock#的指令？<br>这一条指令其实是起到内存屏障的所用，LOCK 前缀虽然不是内存屏障指令，但是他能起到内存屏障的效果。因为我的测试环境是 X86 平台，在 X86 平台上，只会存在 StoreLoad 重排序，所以说 java 编译器在编译 volatile 变量的操作的时候，只需要<span style="background-color:#0f0">在所有的 volatile 写的后面插入一个 StoreLoad 屏障，以此来实现可见性。</span>lock 前缀让本核操作内存时锁定其他核，addl xxx 是个无意义的内存操作，可令 CPU 清空 WB，也起到了内存屏障的作用了。<br>CAS 就能保证原子性，CAS 也是加 LOCK#前缀啊，这又是为什么？因为 CAS 操作是在一条单独的指令 cmpxchg 前加上了#Lock 前缀 ，所以它具有原子性，LOCK#能保证一条指令执行的原子性。</p><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/P19777/article/details/103120433">https://blog.csdn.net/P19777/article/details/103120433</a></p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;CAS 原理和缺陷 huzb的博客]]</p><h1 id="4-深层剖析"><a href="#4-深层剖析" class="headerlink" title="4. 深层剖析"></a>4. 深层剖析</h1><h2 id="4-1-字节码层面"><a href="#4-1-字节码层面" class="headerlink" title="4.1. 字节码层面"></a>4.1. 字节码层面</h2><p>查看字节码我们发现，在 volatile 读写的前后并没有内存屏障信息的生成。即一个属性有没有加 volatile 进行修饰，<span style="background-color:#f0f">对 java 代码编译成字节码指令没有影响</span>，生成的字节码指令都一样的。这一点同时也说明前端编译 (即 javac 编译) 不会产生乱序，java 的编译期优化是发生在后端编译 (即 JIT 编译器)。</p><p><span style="background-color:#f0f">虽然生成的字节码指令是一样的。但是我们还是能发现属性描述的不同。</span></p><p>当属性被修饰为 volatile 时，在生成的字节码的 class 内属性对应 access_flags 是不一样的（比如上文字节码的代码行数 59 和 63 的地方）。添加了 volatile 的属性，对应的字节码属性描述中，access_flag 会多了一个 <code>ACC_VOLATILE</code> 的标记。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126064610.png"></p><h2 id="4-2-JDK-源码层面"><a href="#4-2-JDK-源码层面" class="headerlink" title="4.2. JDK 源码层面"></a>4.2. JDK 源码层面</h2><h3 id="4-2-1-运行逻辑"><a href="#4-2-1-运行逻辑" class="headerlink" title="4.2.1. 运行逻辑"></a>4.2.1. 运行逻辑</h3><p>通过 javap 可以看到 volatile 字节码层面有个关键字 <code>ACC_VOLATILE</code>，如上图所示👆🏻，通过这个关键字定位到 <code>accessFlags.hpp</code> 文件 <a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/utilities/accessFlags.hpp#:~:text=bool%20is_volatile%20%20%20%20()%20const%20%20%20%20%20%20%20%20%20%7B%20return%20(_flags%20%26%20JVM_ACC_VOLATILE%20%20%20%20)%20!%3D%200%3B%20%7D">accessFlags.hpp</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126071957.png"></p><p>再搜索关键字 <code>is_volatile</code>，在<font color="#ffff00">bytecodeInterpreter.cpp</font>可以看到如下代码<br><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp">bytecodeInterpreter.cpp</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126072251.png"></p><p>在这段代码中，会先判断 tos_type，后面分别有不同的基础类型的实现，比如 int 就调用 <code>release_int_field_put</code>，byte 就调用 release_byte_field_put 等等。以 int 类型为例，继续搜索方法 <code>release_int_field_put</code>，在<font color="#ffff00">oop.hpp</font>可以看到如下代码：<br><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/oops/oop.hpp">oop.hpp</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">void release_int_field_put(int offset, jint contents);<br></code></pre></td></tr></table></figure><p>这段代码实际是内联<font color="#ffff00">oop.inline.hpp</font>，具体的实现是这样的：<br><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/oops/oop.inline.hpp">oop.inline.hpp</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">inline void oopDesc::release_int_field_put(int offset, jint contents)       &#123; <br>OrderAccess::release_store(int_field_addr(offset), contents);  &#125;<br></code></pre></td></tr></table></figure><p>继续看 <code>OrderAccess::release_store</code>，可以在<font color="#ffff00">orderAccess.hpp</font>找到对应的实现方法：<br><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.hpp">orderAccess.hpp</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">static void release_store(volatile jint*    p, jint    v);<br></code></pre></td></tr></table></figure><p>实际上这个方法的实现又有很多内联的针对不同的 CPU 有不同的实现的，在 src&#x2F;os_cpu 目录下可以看到不同的实现，以<font color="#ffff00">orderAccess.inline.hpp</font>为例，是这么实现的：<br><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.inline.hpp">orderAccess.inline.hpp</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">inline void OrderAccess::release_store(volatile jint* p, jint v) &#123; specialized_release_store(p, v); &#125;<br></code></pre></td></tr></table></figure><p>可以看到其实 Java 的 volatile 操作，在 JVM 实现层面第一步是给予了 C++ 的原语实现</p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.inline.hpp#:~:text=template%3Ctypename%20T%3E%20inline%20void%20OrderAccess%3A%3Aspecialized_release_store%20%20%20%20%20%20(volatile%20T*%20p%2C%20T%20v)%20%20%7B%20ordered_store%3CT%2C%20RELEASE_X%3E(p%2C%20v)%3B%20%20%20%20%20%20%20%7D">specialized_release_store</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130075959.png"></p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.inline.hpp#:~:text=template%3C%3E%20inline%20void%20ScopedFenceGeneral%3CRELEASE_X%3E%3A%3Aprefix()%20%20%20%20%20%20%20%20%7B%20OrderAccess%3A%3Arelease()%3B%20%7D">RELEASE_X</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130080113.png"></p><p>releasestore 只在 store 之前插入了 release 函数.而并没有插入 storeload，storeload 是在最下面加上去的。<a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#:~:text=OrderAccess%3A%3Astoreload()%3B">位置</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130081619.png"></p><p>上面的分析是 volatile 写的分支逻辑，我们再把 bytecodeInterpreter.cpp 里面读的整体逻辑加上，读的逻辑调用的是 load_acquire，整体逻辑简化概括一下可得：<br>bytecodeInterpreter.cpp(int_field_acquire)<br>–&gt; oop.hpp(int_field_acquire)<br>–&gt; oop.inline.hpp(int_field_acquire)<br>–&gt; orderAccess.hpp(load_acquire)<br>–&gt; orderAccess.inline.hpp(load_acquire)<br>–&gt; orderAccess.inline.hpp(specialized_load_acquire)<br>–&gt; orderAccess.inline.hpp(<x_acquire>::postfix())<br>–&gt; orderAccess.inline.hpp(OrderAccess::acquire())</x_acquire></p><p>至此我们可以看出运行逻辑是 JVM 运行时访问方法区中的变量时，如果发现 flag 是 volatile 修饰，则<span style="background-color:#f0f">会分别给读写方法加上相应的内存屏障</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if(属性读指令操作)&#123;<br>     if(常量池拿到的属性描述 is volatile)&#123;<br>         读操作；<br>         OrderAccess::load_acquire(最后跟出来是OrderAccess::acquire())<br>     &#125;else&#123;<br>         正常读<br>     &#125;<br>     ......<br>&#125;else if(属性写指令操作)&#123;<br>    if(常量池拿到的属性描述 is volatile)&#123;<br>        OrderAccess::release_store(最后跟出来是OrderAccess::release())<br>        写操作；<br>        OrderAccess::storeload()<br>    &#125;else&#123;<br>        正常写<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221129220535.png"></p><p>参考鸣谢：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013291050/article/details/117335477">https://blog.csdn.net/u013291050/article/details/117335477</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/w329636271/article/details/54616543">https://blog.csdn.net/w329636271/article/details/54616543</a></p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk8u/blob/master/hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp">https://github.com/AdoptOpenJDK/openjdk-jdk8u/blob/master/hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp</a></p><h3 id="4-2-2-源码跟踪"><a href="#4-2-2-源码跟踪" class="headerlink" title="4.2.2. 源码跟踪"></a>4.2.2. 源码跟踪</h3><p>在 hotSpot 中对 volatile 的实现的地方有多处,这里主要看的是从 oops 中的实现<br><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/oop.hpp">https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/oop.hpp</a></p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp">https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class oopDesc &#123;<br>....<br> public:<br>  void obj_field_put_volatile(int offset, oop value);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void oopDesc::obj_field_put_volatile(int offset, oop value) &#123;<br> OrderAccess::release();<br> obj_field_put(offset, value);<br> OrderAccess::fence();<br>&#125;<br>oop oopDesc::obj_field_acquire(int offset) const &#123;<br> return UseCompressedOops ?<br>  decode_heap_oop((narrowOop)<br>  OrderAccess::load_acquire(obj_field_addr&lt;narrowOop&gt;(offset)))<br>  : decode_heap_oop((oop)<br>  OrderAccess::load_ptr_acquire(obj_field_addr&lt;oop&gt;(offset)));<br></code></pre></td></tr></table></figure><p>可以得出下图第二部分，正是内存屏障层面的实现原理，在下面章节中有具体介绍<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130065648.png"></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w329636271/article/details/54616543">https://blog.csdn.net/w329636271/article/details/54616543</a></p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/oops/oop.inline.hpp">https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/oops/oop.inline.hpp</a></p><h2 id="4-3-内存屏障层面"><a href="#4-3-内存屏障层面" class="headerlink" title="4.3. 内存屏障层面"></a>4.3. 内存屏障层面</h2><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.hpp">https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/share/vm/runtime/orderAccess.hpp</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130072149.png"></p><p>acquire 等价于 LoadLoad 屏障或 LoadStore 屏障。<br>release 等价于 LoadStore 屏障或 StoreStore 屏障。</p><h3 id="4-3-1-Acquire-和-Release"><a href="#4-3-1-Acquire-和-Release" class="headerlink" title="4.3.1. Acquire 和 Release"></a>4.3.1. Acquire 和 Release</h3><p>如上，关键涉及 OrderAccess::load_acquire,OrderAccess::release_store，OrderAccess::storeload 这三个方法。</p><p>很明显，OrderAccess::storeload 就对应 java 虚拟机抽象出来的 StoreLoad 屏障指令。</p><p>而 OrderAccess::release_store， OrderAccess::load_acquire 又是什么东西呢。</p><p>OrderAccess 就是 openjdk8 路径&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime 下的 orderAccess.hpp 文件。在 orderAccess.hpp 的代码头部注释里有着对这些方法的详细描述。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221125195347.png"></p><p>获取屏障（Acquire Barrier）：相当于上面的 <strong>LoadLoadBarrier</strong> 或者 <strong>LoadStoreBarrier</strong><br>释放屏障（Release Barrier）：相当于 <strong>LoadStoreBarrier</strong> 或者 <strong>StoreStoreBarrier</strong></p><p>Java 中又定义了 release 和 acquire,fence 三种不同的语境的内存栅栏. </p><p>如上图, loadLoad 和 loadStore 两种栅栏对应的都是 acquire 语境,acquire 语境一般定义在 java 的读之前; 在编译器阶段和 cpu 执行的时候, acquire 之后的所有的 (读和写) 操作不能越过 acquire, 重排到 acquire 之前, acquire 指令之后所有的读都是具有可见性的.</p><p>如上图, StoreStore 和 LoadStore 对应的是 release 语境, release 语境一般定义在 java 的写之后, 在编译器和 cpu 执行的时候, 所有 release 之前的所有的 (读和写) 操作都不能越过 release, 重排到 release 之后, release 指令之前所有的写都会刷新到主存中去, 其他核的 cpu 可以看到刷新的最新值.</p><p>对于 fence, 是由 storeload 栅栏组成的, 比较消耗性能. 在编译器阶段和 cpu 执行时候, 保证 fence 之前的任何操作不能重排到屏障之后, fence 之后的任何操作不能重排到屏障之前. fence 具有 acquire 和 release 这两个都有的语境, 即可以将 fence 之前的写刷新到内存中, fence 之后的读都是具有可见性的.</p><p>经上面分析可得 volatile 的 JVM 屏障逻辑如下图所示：</p><h3 id="4-3-2-读操作"><a href="#4-3-2-读操作" class="headerlink" title="4.3.2. 读操作"></a>4.3.2. 读操作</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126074530.png"></p><p>如上图，<del>加载屏障（<code>LoadStore屏障</code>）除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。</del><br><span style="background-color:#ff0">从代码中没有看到该屏障，暂且持怀疑态度！</span></p><p>Acquire Barrier: 获取屏障（<code>LoadLoad屏障</code> 或 <code>LoadStore屏障</code>）禁止了 volatile 读操作与其之后的任何读写操作进行重排序。保障了 volatile 变量读操作之后的任何读写操作，volatile 的写线程的更新已经对其可见。</p><h3 id="4-3-3-写操作"><a href="#4-3-3-写操作" class="headerlink" title="4.3.3. 写操作"></a>4.3.3. 写操作</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221126074511.png"></p><p>如上图，Release Barrier: 释放屏障（<code>LoadStore屏障</code> 或 <code>StoreStore屏障</code>）保证了 volatile 写操作与该操作之前的任何读、写操作都不会进行重排序。从而保证了 <span style="background-color:#f0f">volatile 写操作之前，任何的读写操作都会先于 volatile 被提交</span>。</p><p>而 Store Barrier: 存储屏障（<code>StoreLoad屏障</code>）除了使 volatile 写操作不会与之后的读操作重排序外，还会冲刷处理器缓存，<span style="background-color:#f0f">使 volatile 变量的写更新对其他线程可见，该内存屏障与读操作的加载屏障一起保障了可见性</span>。</p><p>参考鸣谢： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/43af2cc32f90">https://www.jianshu.com/p/43af2cc32f90</a></p><p>内存屏障详细内容请看 <a href="/2022/11/24/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" title="并发编程专题-基础-10、内存屏障">并发编程专题-基础-10、内存屏障</a></p><h2 id="4-4-汇编实现层面"><a href="#4-4-汇编实现层面" class="headerlink" title="4.4. 汇编实现层面"></a>4.4. 汇编实现层面</h2><p>分析到 orderAccess.hpp，OrderAccess 可以理解为是一个接口，根据不同操作系统不同 CPU 对应不同的实现。JSR-133 Cookbook 里定义了一堆 Barrier，但 JVM 虚拟机上实际还会定义更多一些 Barrier 在 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=4nvS/qoXNImI+l3uVxJuVg==.YDGKtIXxBNmoPCcLv5vquYwrxlQ95cJyunKmKZB2D0TqHO1LXpXvYSG3VYheZN6cM22DAenQjkqdavd0rms50I7DMDLt0YzICFmQ/YiYkDa2btjPZ3akek057RaZPStmmE0ZCkGZwekwmiP8D/AylnEC38noSrLTtQ1S8ZUUJRA=">src&#x2F;hotspot&#x2F;share&#x2F;runtime&#x2F;orderAccess.hpp</a></p><p><a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/openjdk-jdk9/blob/master/hotspot/src/os_cpu/linux_x86/vm/orderAccess_linux_x86.inline.hpp">orderAccess_linux_x86.inline.hpp</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221130070932.png"></p><p>此处  <strong>asm</strong> volatile(“” : : : “memory”); 是内嵌汇编.<br>解释:<br><strong>asm</strong> : 代表汇编代码开始.<br><strong>volatile</strong>: 禁止编译器对代码进行某些优化.</p><p>memory: memory 代表是内存; 这边用”memory”,来通知编译器内存的内容已经发生了修改,要重新生成加载指令 (不可以从缓存寄存器中取).因为存在着内存的改变,不可以将前后的代码进行乱序.</p><p>asm volatile(“” :::”memory”),这句内嵌汇编作为编译器屏障，可以防止编译器对相邻指令进行乱序，但是<span style="background-color:#0f0">它无法阻止 CPU 的乱序</span>；也就是说它仅仅禁止了编译器的乱序优化，不会阻止 CPU 的乱序执行。</p><p>compiler_barrier() 只是为了不做指令重排，但是对应的是空操作。看到上面只有 StoreLoad 是实际有效的，对应的是 fence()，看到 fence() 的实现是用 lock。</p><p>多核处理器才会执行处理，单核就不需要内存屏障了。实际指令是 <code>lock; addl $0,0(%%esp)</code>。rsp 是 esp 对应的 64 位指令。</p><p><code>addl $0,0(%%rsp)</code> 的意思就是把寄存器里的值加 0，也就是说这是个空操作。重点在于前缀</p><p>我们再回想起来上一篇文章中 MESI 中的内容。加了 lock 前缀的指令会严格保证 MESI 协议中的数据一致性，保证对某个内存的独占使用，保证该 CPU 对应缓存行为独占，其他 CPU 的缓存行则失效。在 x86 上，任何带 lock 前缀的指令都可以可以当成一个 StoreLoad 屏障。</p><p><code>IA32</code> 中对 lock 的说明是</p><blockquote><p>The LOCK # signal is asserted during execution of the instruction following the lock prefix. This signal can be used in a multiprocessor system to ensure exclusive use of shared memory while LOCK # is asserted</p></blockquote><p><span style="background-color:#f0f">LOCK 用于在多处理器中执行指令时对共享内存的独占使用。它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。另外还提供了有序的指令无法越过这个内存屏障的作用。</span></p><p><strong>正是 lock 实现了 volatile 的「防止指令重排」「内存可见」的特性</strong></p><h1 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h1><p>链接： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9abb4a23ab05">https://www.jianshu.com/p/9abb4a23ab05</a></p><p>必须具备以下两个条件（其实就是先保证原子性）：</p><ul><li>对变量的写 <strong>不依赖当前值</strong>（比如 ++ 操作）</li><li>该变量没有包含在 <strong>具有其他变量的不等式</strong> 中</li></ul><p>比如：</p><ul><li>状态标记（while(flag){})</li><li><strong>double check（单例模式）</strong></li><li><strong>读写锁的缓存中</strong></li><li>其他一写多读的场景</li></ul><h2 id="5-1-DCL"><a href="#5-1-DCL" class="headerlink" title="5.1. DCL"></a>5.1. DCL</h2><h5 id="5-1-1-二次验证的单例"><a href="#5-1-1-二次验证的单例" class="headerlink" title="5.1.1. 二次验证的单例"></a>5.1.1. 二次验证的单例</h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106121957.jpg" alt="image-20200131205812557"></p><p><span style="background-color:#f0f">加了二次判断，严谨了一些，但是仍然会有问题，就是初始化过程和引用赋值过程可能发生重排序，那么如果不加 volatile，就可能第二个非空判断跳过，但是实例对象有地址，但无内容，是一个空壳子对象。</span></p><p>所以要更加严谨一些，像 AQS 中的 hasQueuedPredecessors 一样，涉及多线程，就要判断任何有过程的中间过程，比如 <strong>初始化未完成的情况</strong></p><h5 id="5-1-2-加-volatile-必要性⭐️🔴"><a href="#5-1-2-加-volatile-必要性⭐️🔴" class="headerlink" title="5.1.2. 加 volatile 必要性⭐️🔴"></a>5.1.2. 加 volatile 必要性⭐️🔴</h5><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230409-1308%%</span>❕❕</p><p>![image-20200407150424535](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122007.jpg">https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122007.jpg</a> ^bicvoh)</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122017.jpg" alt="image-20200407150459902"></p><p>解析：因为步骤 2、3 不存在数据依赖关系，所以多线程下可能出现指令重拍。那么就可能导致 2 在 3 之前执行，而此时如果另一个线程的第一次 null 判断会得到不为空的结论，但是 instance 的内容却是空的，从而导致了线程安全问题。所以需要 volatile 来修饰 instance 对象，禁止 instance 对象操作的重排序</p><h2 id="5-2-读写锁缓存"><a href="#5-2-读写锁缓存" class="headerlink" title="5.2. 读写锁缓存"></a>5.2. 读写锁缓存</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230106122024.jpg" alt="image-20200407153136831"></p><p>【参考】volatile 解决多线程内存不可见问题对于一写多读，是可以解决变量同步问题，但是如果多</p><p>写，同样无法解决线程安全问题。<br>说明：如果是 count++ 操作，使用如下类实现：</p><p>AtomicInteger count &#x3D; new AtomicInteger();<br>count.addAndGet(1);<br>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p><h2 id="5-3-JUC"><a href="#5-3-JUC" class="headerlink" title="5.3. JUC"></a>5.3. JUC</h2><ul><li><a target="_blank" rel="noopener" href="https://monkeysayhi.github.io/2017/09/27/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/">面试中单例模式有几种写法？</a>：“饱汉 - 变种 3”在 DCL 的基础上，使用 volatile 修饰单例，以保证单例的可见性。</li></ul><p>复杂的利用 volatile 变量规则（结合了程序顺序规则、传递性）保证变量本身及周围其他变量的偏序：</p><ul><li><a target="_blank" rel="noopener" href="https://monkeysayhi.github.io/2017/12/05/%E6%BA%90%E7%A0%81%7C%E5%B9%B6%E5%8F%91%E4%B8%80%E6%9E%9D%E8%8A%B1%E4%B9%8BReentrantLock%E4%B8%8EAQS%EF%BC%881%EF%BC%89%EF%BC%9Alock%E3%80%81unlock/">源码|并发一枝花之ReentrantLock与AQS（1）：lock、unlock</a>：exclusiveOwnerThread 借助于 volatile 变量 state 保证其相对于 state 的偏序。</li><li><a target="_blank" rel="noopener" href="https://monkeysayhi.github.io/2017/10/24/%E6%BA%90%E7%A0%81%7C%E5%B9%B6%E5%8F%91%E4%B8%80%E6%9E%9D%E8%8A%B1%E4%B9%8BCopyOnWriteArrayList/">源码|并发一枝花之CopyOnWriteArrayList</a>：CopyOnWriteArrayList 借助于 volatile 变量 array，对外提供偏序语义。</li></ul><h1 id="6-synchronized-与-volatile-区别"><a href="#6-synchronized-与-volatile-区别" class="headerlink" title="6. synchronized 与 volatile 区别"></a>6. synchronized 与 volatile 区别</h1><ul><li>Volatile 保证线程可见性，当工作内存中副本数据无效之后，主动读取主内存中数据</li><li>Volatile 可以禁止重排序的问题，底层使用内存屏障</li><li>Volatile 不会导致线程阻塞，不能够保证线程安全问题 (不能保证原子性)，synchronized 会导致线程阻塞，能够保证线程安全问题</li></ul><h1 id="7-参考与感谢"><a href="#7-参考与感谢" class="headerlink" title="7. 参考与感谢"></a>7. 参考与感谢</h1><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;计算机与服务器底层世界-CPU架构篇-Core - 知乎]]</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;x86-TSO 适用于x86体系架构并发编程的内存模型 - 执生 - 博客园]]</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/it_lihongmin/article/details/109169260">https://blog.csdn.net/it_lihongmin/article/details/109169260</a></p><p><a target="_blank" rel="noopener" href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/orderAccess.hpp">https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/orderAccess.hpp</a></p><p>应用场景： <a target="_blank" rel="noopener" href="https://www.51cto.com/article/684725.html">https://www.51cto.com/article/684725.html</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-8%E3%80%81Volatile/">https://taylorluo.github.io/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-8%E3%80%81Volatile/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/1080" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-9%E3%80%81Java%E5%90%84%E7%A7%8D%E9%94%81/"><img class="prev-cover" src="https://picsum.photos/1920/1085" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发编程专题-基础-9、Java各种锁</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/11/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-0%E3%80%81Java%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover4.jpg" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础-1、Java-相关名词</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/10/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-6%E3%80%81CAS/" title="并发编程专题-基础-6、CAS"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">并发编程专题-基础-6、CAS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发编程专题-基础-7、Thread"><img class="cover" src="https://picsum.photos/1920/912" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-7、Thread</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-4、信号量与管程"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-4、信号量与管程</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-5%E3%80%81%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-5、进程 线程 纤程 协程 管程"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-5、进程 线程 纤程 协程 管程</div></div></a></div><div><a href="/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/" title="并发编程专题-基础-12、AQS"><img class="cover" src="https://picsum.photos/1920/1084" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-20</div><div class="title">并发编程专题-基础-12、AQS</div></div></a></div><div><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/" title="并发编程专题-基础-1、JMM与MESI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-09</div><div class="title">并发编程专题-基础-1、JMM与MESI</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E8%A6%81%E5%9B%9E%E7%AD%94"><span class="toc-text">1. 简要回答</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-text">2. 乱序问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">3. 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-JMM-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">3.1. JMM 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-JMM-%E5%8F%8A-MESI"><span class="toc-text">3.1.1. JMM 及 MESI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">3.2. 可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">3.2.1. 可见性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-JVM-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2.2. JVM 源码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">3.3. 有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">3.3.1. 指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-volatile-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">3.3.2. volatile 禁止重排的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">3.3.2.1. 读操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">3.3.2.2. 写操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-JVM-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.3.3. JVM 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">3.4. 不保证原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">3.4.1. 为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-text">3.4.2. 如何保证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Happens-Before"><span class="toc-text">3.5. Happens-Before</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%85%B7%E4%BD%93%E6%A1%88%E4%BE%8B"><span class="toc-text">3.5.1. 具体案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%B8%8E-MESI-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.6. 与 MESI 的关系</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%B7%B1%E5%B1%82%E5%89%96%E6%9E%90"><span class="toc-text">4. 深层剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-text">4.1. 字节码层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-JDK-%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-text">4.2. JDK 源码层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-text">4.2.1. 运行逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA"><span class="toc-text">4.2.2. 源码跟踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%B1%82%E9%9D%A2"><span class="toc-text">4.3. 内存屏障层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-Acquire-%E5%92%8C-Release"><span class="toc-text">4.3.1. Acquire 和 Release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">4.3.2. 读操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">4.3.3. 写操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2"><span class="toc-text">4.4. 汇编实现层面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-DCL"><span class="toc-text">5.1. DCL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%E7%9A%84%E5%8D%95%E4%BE%8B"><span class="toc-text">5.1.1. 二次验证的单例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E5%8A%A0-volatile-%E5%BF%85%E8%A6%81%E6%80%A7%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.1.2. 加 volatile 必要性⭐️🔴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%AF%BB%E5%86%99%E9%94%81%E7%BC%93%E5%AD%98"><span class="toc-text">5.2. 读写锁缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-JUC"><span class="toc-text">5.3. JUC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-synchronized-%E4%B8%8E-volatile-%E5%8C%BA%E5%88%AB"><span class="toc-text">6. synchronized 与 volatile 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">7. 参考与感谢</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/1080')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>