<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>框架源码专题-Spring-3、AOP | Taylor</title><meta name="keywords" content="框架源码专题,Spring,AOP"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. AOP1.1. 分类比较%%▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230507-1556%%❕ ^1m5ekc Spring AOP 和 AspectJ AOP(静态 AOP) 简而言之，Spring AOP 和 AspectJ 有不同的目标。Spring AOP 旨在通过 Spring IoC 提供一个简单的 AOP 实现，以解决编码人员面临的最常出"><meta property="og:type" content="article"><meta property="og:title" content="框架源码专题-Spring-3、AOP"><meta property="og:url" content="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. AOP1.1. 分类比较%%▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230507-1556%%❕ ^1m5ekc Spring AOP 和 AspectJ AOP(静态 AOP) 简而言之，Spring AOP 和 AspectJ 有不同的目标。Spring AOP 旨在通过 Spring IoC 提供一个简单的 AOP 实现，以解决编码人员面临的最常出"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/1082"><meta property="article:published_time" content="2022-12-04T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.677Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="框架源码专题"><meta property="article:tag" content="Spring"><meta property="article:tag" content="AOP"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/1082"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"框架源码专题-Spring-3、AOP",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/1082')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">框架源码专题-Spring-3、AOP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T16:00:00.000Z" title="发表于 2022-12-05 00:00:00">2022-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.677Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/">框架源码专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="框架源码专题-Spring-3、AOP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1. AOP"></a>1. AOP</h1><h2 id="1-1-分类比较"><a href="#1-1-分类比较" class="headerlink" title="1.1. 分类比较"></a>1.1. 分类比较</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230507-1556%%</span>❕ ^1m5ekc</p><p>Spring AOP 和 AspectJ AOP(静态 AOP)</p><p>简而言之，Spring AOP 和 AspectJ 有不同的目标。<br>Spring AOP 旨在通过 Spring IoC 提供一个简单的 AOP 实现，以解决编码人员面临的最常出现的问题。这并不是完整的 AOP 解决方案，<span style="background-color:#ff0">它只能用于 Spring 容器管理的 beans</span>。</p><p>另一方面，AspectJ 是最原始的 AOP 实现技术，提供了完整的的 AOP 解决方案。AspectJ 更为健壮，相对于 Spring AOP 也显得更为复杂。值得注意的是，AspectJ 能够被应用于所有的领域对象<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5a695b3cf265da3e47449471">https://juejin.im/post/5a695b3cf265da3e47449471</a></p><p><span style="background-color:#ff0">Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理 (Proxying)，而 AspectJ 基于字节码操作 (Bytecode Manipulation)。</span></p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44259720/article/details/95996541">https://blog.csdn.net/weixin_44259720/article/details/95996541</a></p><h2 id="1-2-方案选择"><a href="#1-2-方案选择" class="headerlink" title="1.2. 方案选择"></a>1.2. 方案选择</h2><ul><li>框架：如果应用程序不使用 Spring 框架，那么我们别无选择，只能放弃使用 Spring AOP 的想法，因为它无法管理任何超出 spring 容器范围的东西。 但是，如果我们的应用程序完全是使用 Spring 框架创建的，那么我们可以使用 Spring AOP，因为它很直接便于学习和应用。</li><li>灵活性：鉴于有限的连接点支持，Spring AOP 并不是一个完整的 AOP 解决方案，但它解决了程序员面临的最常见的问题。 如果我们想要深入挖掘并利用 AOP 达到其最大能力，并希望获得来自各种可用连接点的支持，那么 AspectJ 是最佳选择。</li><li>性能：如果我们使用有限的切面，那么性能差异很小。 但是，有时候应用程序有数万个切面的情况。 在这种情况下，我们不希望使用运行时织入，所以最好选择 AspectJ。 已知 AspectJ 比 Spring AOP 快 8 到 35 倍。</li><li>共同优点：这两个框架是完全兼容的。 我们可以随时利用 Spring AOP，并且仍然使用 AspectJ 来获得前者不支持的连接点。</li></ul><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218143952.png"></p><h2 id="1-3-术语解析"><a href="#1-3-术语解析" class="headerlink" title="1.3. 术语解析"></a>1.3. 术语解析</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av58225341?p=270">https://www.bilibili.com/video/av58225341?p=270</a></p><p>[[02_尚硅谷大数据技术之Spring(老师原版).docx]]</p><h3 id="1-3-1-配套代码"><a href="#1-3-1-配套代码" class="headerlink" title="1.3.1. 配套代码"></a>1.3.1. 配套代码</h3><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;Spring03&#x2F;src&#x2F;com&#x2F;atguigu&#x2F;spring&#x2F;aspectJ&#x2F;annotation&#x2F;LoggingAspect.java]]</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230114085041.jpg" alt="image-20200328181706288"></p><h3 id="1-3-2-目标-Target"><a href="#1-3-2-目标-Target" class="headerlink" title="1.3.2. 目标 (Target)"></a>1.3.2. 目标 (Target)</h3><p>业务逻辑：比如加、减、乘、除</p><h3 id="1-3-3-代理-Proxy"><a href="#1-3-3-代理-Proxy" class="headerlink" title="1.3.3. 代理 (Proxy)"></a>1.3.3. 代理 (Proxy)</h3><h3 id="1-3-4-横切关注点"><a href="#1-3-4-横切关注点" class="headerlink" title="1.3.4. 横切关注点"></a>1.3.4. 横切关注点</h3><p>在程序代码中的具体体现，对应程序执行的<span style="background-color:#0f0">某个特定位置</span>。例如：<span style="background-color:#0f0">某个方法调用前、调用后、方法捕获到异常后等</span>。</p><h3 id="1-3-5-通知-Advice"><a href="#1-3-5-通知-Advice" class="headerlink" title="1.3.5. 通知 (Advice)"></a>1.3.5. 通知 (Advice)</h3><p>在横切关注点所设定的地方，所要完成的特定动作</p><h3 id="1-3-6-切面-Aspect"><a href="#1-3-6-切面-Aspect" class="headerlink" title="1.3.6. 切面 (Aspect)"></a>1.3.6. 切面 (Aspect)</h3><p>将相关通知汇总到一个类中，管理切点和通知</p><h3 id="1-3-7-连接点-Joinpoint"><a href="#1-3-7-连接点-Joinpoint" class="headerlink" title="1.3.7. 连接点 (Joinpoint)"></a>1.3.7. 连接点 (Joinpoint)</h3><p>横切关注点与目标对象的目标方法的交叉点。比如<span style="background-color:#0f0">方法执行前</span>与<span style="background-color:#ff0">add()</span> ❕<span style="display:none">%%<br>1522-🏡⭐️◼️连接点怎么理解 ?🔜MSTM📝 可以理解为时空交叉点，方法执行为时间，增强要还在哪个位置，比如方法执行之前还是之后，这是空间，时空交叉点就是连接点；切点：是一种表达式，类似于查询语言一样，确定在什么地方什么时候插入增强逻辑；通知：就是公共的增强逻辑，包括前置、后置、环绕、返回、异常 5 种，而切面就是管理通知和切点的类◼️⭐️-point-202302091522%%</span> ^6c4nvo</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230102115010.png"></p><h2 id="1-4-实现方式"><a href="#1-4-实现方式" class="headerlink" title="1.4. 实现方式"></a>1.4. 实现方式</h2><p>[[(209条消息) AOP的实现的几种方式_Ydoing的博客-CSDN博客_aop实现]]</p><h1 id="2-SpringAOP-实现原理"><a href="#2-SpringAOP-实现原理" class="headerlink" title="2. SpringAOP 实现原理"></a>2. SpringAOP 实现原理</h1><h2 id="2-1-容器环境准备"><a href="#2-1-容器环境准备" class="headerlink" title="2.1. 容器环境准备"></a>2.1. 容器环境准备</h2><p>因为任何 Bean 创建都需要 <code>BeanDefinitionRegistryPostProcessor</code> 先将 BD 注册到容器中，而在 Spring 中唯一的实现类就是 <code>ConfigurationClassPostProcessor</code>，所以第一步就是它。</p><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><h2 id="2-2-注册-Creator-BD"><a href="#2-2-注册-Creator-BD" class="headerlink" title="2.2. 注册 Creator BD"></a>2.2. 注册 Creator BD</h2><p>在 refresh() 中的第 5 步 <strong>执行</strong>BeanFactoryPostProcessor 的方法中，<strong>BeanDefinitionRegistryPostProcessor</strong>.postProcessBeanDefinitionRegistry</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230210085318.png" alt="image.png"></p><h3 id="2-2-1-AspectJAutoProxyRegistrar-注册-CreatorBD"><a href="#2-2-1-AspectJAutoProxyRegistrar-注册-CreatorBD" class="headerlink" title="2.2.1. AspectJAutoProxyRegistrar(注册 CreatorBD)"></a>2.2.1. AspectJAutoProxyRegistrar(注册 CreatorBD)</h3><h4 id="2-2-1-1-EnableAspectJAutoProxy"><a href="#2-2-1-1-EnableAspectJAutoProxy" class="headerlink" title="2.2.1.1. @EnableAspectJAutoProxy"></a>2.2.1.1. @EnableAspectJAutoProxy</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217155821.png"></p><p>implements ImportBeanDefinitionRegistrar</p><p>利用重写的 registerBeanDefinitions 方法，给容器中注册一个自动代理创建器 <code>AnnotationAwareAspectJAutoProxyCreator</code>，放到 <code>beanDefinitionMap</code> 中</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217184124.png"></p><h4 id="2-2-1-2-AnnotationAwareAspectJAutoProxyCreator"><a href="#2-2-1-2-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="2.2.1.2. AnnotationAwareAspectJAutoProxyCreator"></a>2.2.1.2. AnnotationAwareAspectJAutoProxyCreator</h4><h5 id="2-2-1-2-1-继承关系"><a href="#2-2-1-2-1-继承关系" class="headerlink" title="2.2.1.2.1. 继承关系"></a>2.2.1.2.1. 继承关系</h5><pre><code>     AnnotationAwareAspectJAutoProxyCreator
         -&gt;AspectJAwareAdvisorAutoProxyCreator
             -&gt;AbstractAdvisorAutoProxyCreator
                 -&gt;AbstractAutoProxyCreator
                         implements 
                               SmartInstantiationAwareBeanPostProcessor,BeanFactoryAware
                     关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory
</code></pre><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230221112438.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230303124338.png" alt="image.png"></p><h5 id="2-2-1-2-2-关键方法"><a href="#2-2-1-2-2-关键方法" class="headerlink" title="2.2.1.2.2. 关键方法"></a>2.2.1.2.2. 关键方法</h5><p>AbstractAutoProxyCreator.setBeanFactory()</p><p>AbstractAutoProxyCreator.有后置处理器的逻辑；</p><p>AbstractAdvisorAutoProxyCreator.setBeanFactory() -&gt; initBeanFactory()</p><p>AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()-&gt;super.initBeanFactory</p><h3 id="2-2-2-注册-Creator-BPP-Bean"><a href="#2-2-2-注册-Creator-BPP-Bean" class="headerlink" title="2.2.2. 注册 Creator BPP Bean"></a>2.2.2. 注册 Creator BPP Bean</h3><h4 id="2-2-2-1-创建-BPP-Bean"><a href="#2-2-2-1-创建-BPP-Bean" class="headerlink" title="2.2.2.1. 创建 BPP Bean"></a>2.2.2.1. 创建 BPP Bean</h4><p>来到刷新的第 6 步，registerBeanPostProcessors() 中，用 <code>PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this)</code> 注册 postprocessor。<code>beanFactory.getBean(ppName, BeanPostProcessor.class)</code> 会创建所有 postprocessor 对象。BPP 的 bean 也是 bean，在 getBean 的过程中，12 大步都会走。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217183744.png"></p><h4 id="2-2-2-2-设置-BeanFactory"><a href="#2-2-2-2-设置-BeanFactory" class="headerlink" title="2.2.2.2. 设置 BeanFactory"></a>2.2.2.2. 设置 BeanFactory</h4><p>会在 initializeBean 中真正调用初始化方法之前，<code>invokeAwareMethods(beanName, bean)</code> 中调用 <code>setBeanFactory()</code>;<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218080356.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218080716.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218080940.png"></p><blockquote><ol start="2"><li>将 BPP(AnnotationAwareAspectJAutoProxyCreator) 保存到 <code>List&lt;BeanPostProcessor&gt;</code> beanPostProcessors<br><code>beanFactory.addBeanPostProcessor(postProcessor)</code></li></ol></blockquote><h2 id="2-3-增强逻辑"><a href="#2-3-增强逻辑" class="headerlink" title="2.3. 增强逻辑"></a>2.3. 增强逻辑</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211073953.png" alt="image.png"><br><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/63e4bfa27c423a1934f127a5">https://www.processon.com/diagraming/63e4bfa27c423a1934f127a5</a></p><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f1958a35653bb7fd24d0aad">https://www.processon.com/view/link/5f1958a35653bb7fd24d0aad</a></p><h3 id="2-3-1-postProcessBeforeInstantiation-解析切面并缓存通知"><a href="#2-3-1-postProcessBeforeInstantiation-解析切面并缓存通知" class="headerlink" title="2.3.1. postProcessBeforeInstantiation(解析切面并缓存通知)"></a>2.3.1. postProcessBeforeInstantiation(解析切面并缓存通知)</h3><p><span style="display:none">%%<br>▶28.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230323-0929%%</span>❕ ^o0kxx7</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230102185902.png"></p><p>在 11. finishBeanFactoryInitialization() 中，<span style="background-color:#f0f">任何一个 bean 创建实例之前</span>，会走到 <code>resolveBeforeInstantiation</code> 方法中，会执行类型为 <code>InstantiationAwareBeanPostProcessor</code> 的 postprocessor 的<span style="background-color:#0f0">applyBeanPostProcessorsBeforeInstantiation</span>方法。而我们的 AnnotationAwareAspectJAutoProxyCreator 正是此种类型。所以会执行其父类<span style="background-color:#0f0">AbstractAutoProxyCreator</span>重写的 <code>postProcessBeforeInstantiation</code> 方法<br><code>AnnotationAwareAspectJAutoProxyCreator</code> 是 <code>InstantiationAwareBeanPostProcessor</code> 类型的后置处理器，重写的方法为</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217195752.png"></p><h4 id="2-3-1-1-getCustomTargetSource"><a href="#2-3-1-1-getCustomTargetSource" class="headerlink" title="2.3.1.1. getCustomTargetSource"></a>2.3.1.1. getCustomTargetSource</h4><p>这个方法主要解析用户配置的切面类，getCustomTargetSource 用来处理用户自定义 TargetSource 的场景，一般没人自定义，除非我们的容器中有 TargetSourceCreator 并且我们的 bean 需要实现</p><h4 id="2-3-1-2-findCandidateAdvisors"><a href="#2-3-1-2-findCandidateAdvisors" class="headerlink" title="2.3.1.2. findCandidateAdvisors"></a>2.3.1.2. findCandidateAdvisors</h4><p>通过 Spring IoC 容器找到系统中实现了 Advisor 接口的 bean，<span style="background-color:#f0f">声明式事务的 advisor 就是在这里被查询到的</span>。❕<span style="display:none">%%<br>▶2.🏡⭐️◼️声明式事务的 advisor 是在哪里被查询到的 ?🔜MSTM📝 在第 11 步中的 9 大后置处理器中的第一个，即 InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 方法中，在解析切面中的 findCandidateAdvisors 方法中。这个方法是查询所有实现了 Advisor 接口的类，而在我们的声明式事务中，@EnableTransactionManagement 注解中注入了 TransactionManagementConfigurationSelector，在里面注入了 AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration，在里面显示注入了 Advisor(BeanFactoryTransactionAttributeSourceAdvisor)◼️⭐️-point-20230222-0731%%</span> ^q0d8rn</p><h4 id="2-3-1-3-buildAspectJAdvisors⭐️🔴"><a href="#2-3-1-3-buildAspectJAdvisors⭐️🔴" class="headerlink" title="2.3.1.3. buildAspectJAdvisors⭐️🔴"></a>2.3.1.3. buildAspectJAdvisors⭐️🔴</h4><p>通过 Spring IoC 容器获取<span style="background-color:#f0f">所有</span>标注 @AspectJ 注解的 Bean，再获取标注 AspectJ 注解（除了@Pointcut 其他的注解 @After、@Before、@AfterReturning 等）的方法，将这些方法封装为一个个 Advisor，<strong>缓存在 <code>this.advisorsCache</code> 中，以 <code>beanName</code> 为 key，<code>List&lt;Advisor&gt;</code> 为 value。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过封装的bean获取其Advice，如@Before，@After等等，并且将这些  </span><br><span class="hljs-comment">// Advice都解析并且封装为一个个的Advisor  </span><br>List&lt;Advisor&gt; classAdvisors = <span class="hljs-built_in">this</span>.advisorFactory.getAdvisors(factory);  <br><span class="hljs-comment">// 如果切面类是singleton类型，则将解析得到的Advisor进行缓存，  </span><br><span class="hljs-comment">// 否则将当前的factory进行缓存，以便再次获取时可以通过factory直接获取  </span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;  <br>   <span class="hljs-built_in">this</span>.advisorsCache.put(beanName, classAdvisors);  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-1-3-1-AspectJAdvisorFactory-getAdvisors"><a href="#2-3-1-3-1-AspectJAdvisorFactory-getAdvisors" class="headerlink" title="2.3.1.3.1. AspectJAdvisorFactory.getAdvisors"></a>2.3.1.3.1. AspectJAdvisorFactory.getAdvisors</h5><p>首先获取切面类型，然后获取除 Pointcut 注解的所有方法，根据方法注解来创建 Advisor 通知器。</p><p>判断当前方法是否标注有@Before，@After 或@Around 等注解，如果标注了，则将其封装为一个 Advisor，其中会调用 getPointcut 包含了切点信息<br><strong>AspectJAdvisorFactory.getAdvisor</strong></p><p>获取当前方法中@Before，@After 或者@Around 等标注的注解，并且获取该注解的值，将其封装为一个 AspectJExpressionPointcut 对象<br><strong>getPointcut</strong></p><p>将获取到的切点，切点方法等信息封装为一个 Advisor 对象，也就是说当前 Advisor 包含有所有当前切面进行环绕所需要的信息<br><strong>new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,this, aspectInstanceFactory, declarationOrderInAspect, aspectName)</strong></p><p><span style="background-color:red">InstantiationModelAwarePointcutAdvisorImpl 中的 <code>getAdvice()</code> 是个同步方法</span></p><h5 id="2-3-1-3-2-事务相关内容⭐️🔴⭐️🔴"><a href="#2-3-1-3-2-事务相关内容⭐️🔴⭐️🔴" class="headerlink" title="2.3.1.3.2. 事务相关内容⭐️🔴⭐️🔴"></a>2.3.1.3.2. 事务相关内容⭐️🔴⭐️🔴</h5><h4 id="2-3-1-4-结论"><a href="#2-3-1-4-结论" class="headerlink" title="2.3.1.4. 结论"></a>2.3.1.4. 结论</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230210140623.png" alt="image.png"><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041228253">https://segmentfault.com/a/1190000041228253</a> 我们的 aop 解析切面以及事务解析事务注解都是在这里完成的</p><p>AnnotationAwareAspectJAutoProxyCreator 的 postProcessBeforeInstantiation 方法的主要核心在于将容器中 <strong>所有的切面对应的通知都扫描出来并包装成 InstantiationModelAwarePointcutAdvisorImpl 类型的对象并添加到缓存中</strong>（<strong>这里要注意：不管是自定义的切面、还是实现了 Advisor 接口 (比如声明式事务注册进来的) 的切面都会被扫描出来</strong>）。这是一种预热机制，先把数据准备好，后续需要时直接再从缓存中拿。</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6978742789165187079">https://juejin.cn/post/6978742789165187079</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b45bf3befa25">https://www.jianshu.com/p/b45bf3befa25</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42419406/article/details/116640641">https://blog.csdn.net/qq_42419406/article/details/116640641</a></p><h3 id="2-3-2-postProcessAfterInitialization-使用缓存创建代理"><a href="#2-3-2-postProcessAfterInitialization-使用缓存创建代理" class="headerlink" title="2.3.2. postProcessAfterInitialization(使用缓存创建代理)"></a>2.3.2. postProcessAfterInitialization(使用缓存创建代理)</h3><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f1e93f25653bb7fd2549b7c">https://www.processon.com/view/link/5f1e93f25653bb7fd2549b7c</a></p><p><strong>时机：对象初始化完成之后</strong><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230102185744.png"></p><p>return &#96;wrapIfNecessary(bean, beanName, cacheKey)</p><p>1）、获取当前 bean 的所有增强器（通知方法） <code>Object[] specificInterceptors</code><br>1、找到候选的所有的增强器（找哪些通知方法是需要切入当前 bean 方法的）<br>2、<span style="background-color:#0f0">获取到能在 bean 使用的增强器</span>。<br>3、给增强器排序<br>2）、保存当前 bean 在 advisedBeans 中；<br><span style="background-color:#0f0">3）、如果当前 bean 需要增强，创建当前 bean 的代理对象；</span><br><span style="background-color:#0f0">1）、获取所有增强器（通知方法）</span><br><span style="background-color:#0f0">2）、保存到 proxyFactory</span><br><span style="background-color:#0f0">3）、创建代理对象：Spring 自动决定</span><br><span style="background-color:#0f0">JdkDynamicAopProxy(config);jdk 动态代理；</span><br>ObjenesisCglibAopProxy(config);cglib 的动态代理；<br>4）、给容器中返回当前组件使用 cglib 增强了的代理对象；<br>5）、<span style="background-color:#0f0">以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</span>；</p><h4 id="2-3-2-1-wrapIfNecessary"><a href="#2-3-2-1-wrapIfNecessary" class="headerlink" title="2.3.2.1. wrapIfNecessary"></a>2.3.2.1. wrapIfNecessary</h4><h4 id="2-3-2-2-getAdvicesAndAdvisorsForBean"><a href="#2-3-2-2-getAdvicesAndAdvisorsForBean" class="headerlink" title="2.3.2.2. getAdvicesAndAdvisorsForBean"></a>2.3.2.2. getAdvicesAndAdvisorsForBean</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang489687009/article/details/121099165">https://blog.csdn.net/wang489687009/article/details/121099165</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yy_diego/article/details/118213155">https://blog.csdn.net/yy_diego/article/details/118213155</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230210215209.png" alt="image.png"></p><h4 id="2-3-2-3-findEligibleAdvisors"><a href="#2-3-2-3-findEligibleAdvisors" class="headerlink" title="2.3.2.3. findEligibleAdvisors"></a>2.3.2.3. findEligibleAdvisors</h4><p>AbstractAdvisorAutoProxyCreator：findCandidateAdvisors→<br>AnnotationAwareAspectJAutoProxyCreator：advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过所有的aspectNames在缓存中获取切面对应的Advisor，这里如果是单例的，则直接从advisorsCache  </span><br><span class="hljs-comment">// 获取，如果是多例类型的，则通过MetadataAwareAspectInstanceFactory立即生成一个</span><br>List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-built_in">this</span>.advisorsCache.get(aspectName);<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 提供的 hook 方法，用于对目标 Advisor 进行扩展<br>extendAdvisors(eligibleAdvisors);<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230323143217.png" alt="image.png"></p><h4 id="2-3-2-4-createProxy"><a href="#2-3-2-4-createProxy" class="headerlink" title="2.3.2.4. createProxy"></a>2.3.2.4. createProxy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前bean的Advices和Advisors  </span><br>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean<br><span class="hljs-title function_">createProxy</span><span class="hljs-params">(bean.getClass()</span>, beanName, specificInterceptors, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(bean))<br></code></pre></td></tr></table></figure><h2 id="2-4-执行逻辑"><a href="#2-4-执行逻辑" class="headerlink" title="2.4. 执行逻辑"></a>2.4. 执行逻辑</h2><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f4dd513e0b34d1abc735998">https://www.processon.com/view/link/5f4dd513e0b34d1abc735998</a></p><p>容器中保存了组件的代理对象（cglib 增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）<br><span style="background-color:#0f0">拦截器链：每一个通知方法又被包装为方法拦截器，利用 MethodInterceptor 机制执行方法逻辑</span>。如果没有拦截器链，直接执行目标方法</p><h3 id="2-4-1-获取并封装拦截器链⭐️🔴"><a href="#2-4-1-获取并封装拦截器链⭐️🔴" class="headerlink" title="2.4.1. 获取并封装拦截器链⭐️🔴"></a>2.4.1. 获取并封装拦截器链⭐️🔴</h3><p>执行目标方法执行时，<span style="background-color:#f0f">CglibAopProxy.intercept()</span> 会拦截目标方法的执行，根据 ProxyFactory 对象 (<code>this.advised</code>) 获取<span style="background-color:#0f0">将要执行的目标方法的</span>拦截器链</p><ol><li><font color="#ff0000"><span style="background-color:#ff0">遍历所有的增强器，将其转换为 MethodInterceptor</span></font><br>如果是 MethodInterceptor 类型，直接加入到集合中。如果不是，使用 AdvisorAdapter 将增强器转为 MethodInterceptor 类型；<font color="#ff0000"><span style="background-color:#ff0">转换完成返回 MethodInterceptor 数组</span></font>；</li><li>如果是 PointcutAdvisor 需要 match 切点，匹配成功则放入 <code>List&lt;Object&gt;</code> 返回</li><li>获得拦截器链之后，<span style="background-color:#f0f">把需要执行的目标对象，目标方法，</span><br><span style="background-color:#f0f">拦截器链等信息封装起来，创建一个 <code>CglibMethodInvocation 对象</code></span>，并调用 Object retVal &#x3D; mi.proceed();</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217230956.png"></p><h3 id="2-4-2-触发执行拦截器链"><a href="#2-4-2-触发执行拦截器链" class="headerlink" title="2.4.2. 触发执行拦截器链"></a>2.4.2. 触发执行拦截器链</h3><h4 id="2-4-2-1-执行入口"><a href="#2-4-2-1-执行入口" class="headerlink" title="2.4.2.1. 执行入口"></a>2.4.2.1. 执行入口</h4><ol><li>创建 CglibMethodInvocation 对象后调用 <code>proceed()</code> 方法<br><code>new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed()</code></li><li>执行进入 <code>proceed()</code> 方法中，获取第 <code>++this.currentInterceptorIndex</code> 个拦截器。<code>this.currentInterceptorIndex</code> 默认值是 <code>-1</code></li><li>调用拦截器的 <code>invoke(this)</code> 方法，<code>this</code> 就是当前 <code>CglibMethodInvocation</code> 对象</li><li>在不同拦截器中的 invoke 方法中，会再次调用 <code>mi.proceed()</code>，进入到第 2 步，依次递归，执行每个拦截器中的方法，直到递归调用的执行出口为止<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️cglibMethodInvocation 对象是链式调用的控制对象◼️⭐️-point-20230223-1444%%</span></li><li>值得注意的是在第一个默认的拦截器 <code>ExposeInvocationInterceptor</code> 中将 CglibMethodInvocation 对象放到了 ThreadLocal 中以便共享使用<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230323154744.png" alt="image.png"></li></ol><h4 id="2-4-2-2-执行出口"><a href="#2-4-2-2-执行出口" class="headerlink" title="2.4.2.2. 执行出口"></a>2.4.2.2. 执行出口</h4><p><code>this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1</code><br>如果没有拦截器，或者拦截器的索引等于拦截器数组 -1 （即执行到了最后一个拦截器）就会执行目标方法；</p><h4 id="2-4-2-3-执行过程"><a href="#2-4-2-3-执行过程" class="headerlink" title="2.4.2.3. 执行过程"></a>2.4.2.3. 执行过程</h4><p><span style="background-color:#0f0">链式获取每一个拦截器，拦截器执行 invoke 方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br>拦截器链的触发过程，即 proceed 方法的执行过程。拦截器链的机制，保证了通知方法与目标方法的执行顺序</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217233439.png"></p><p>每种拦截器的执行逻辑不同，比如 <code>AspectJAfterThrowingAdvice</code>，advice 方法在 catch 块里执行。其他拦截器请看 <a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217233822.png"></p><p><span style="background-color:#f0f">而 this.advice.afterReturing 没有设置 catch 块，所以出错之后也就不会被执行到了</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217233758.png"></p><h4 id="2-4-2-4-执行顺序分析"><a href="#2-4-2-4-执行顺序分析" class="headerlink" title="2.4.2.4. 执行顺序分析"></a>2.4.2.4. 执行顺序分析</h4><p>流程图<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218103312.png"><br>❕<span style="display:none">%%<br>1904-🏡⭐️◼️拦截器链的调用逻辑 ?🔜MSTM📝 在创建 advisors 时，由于 ReflectiveAspectJAdvisorFactory 静态代码块中设定了 Around、Before、After、AfterReturning、AfterThrowing 的顺序，所以加入 advisorsCache 中的 declarationOrder 也是这个顺序。在创建代理时，除了用于辅助拦截器链执行的 ExposeInvocationInterceptor 之外，其他 advisors 按 declarationOrder 做了倒序排列，所以在拦截器链中的顺序为 Expose、AfterThrowing、AfterReturning、After、Before、Around◼️⭐️-point-20230211-1904%%</span></p><h2 id="2-5-简单概述"><a href="#2-5-简单概述" class="headerlink" title="2.5. 简单概述"></a>2.5. 简单概述</h2><p>总结：<br>1）、 @ EnableAspectJAutoProxy 开启 AOP 功能<br>2）、 @ EnableAspectJAutoProxy 会给容器中注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code><br>3）、AnnotationAwareAspectJAutoProxyCreator 是一个后置处理器；<br>4）、容器的创建流程：<br>1）、registerBeanPostProcessors（）注册后置处理器；创建 AnnotationAwareAspectJAutoProxyCreator 对象<br>2）、finishBeanFactoryInitialization（）初始化剩下的单实例 bean<br>1）、创建业务逻辑组件和切面组件<br>2）、AnnotationAwareAspectJAutoProxyCreator 拦截组件的创建过程<br>3）、组件创建完之后，判断组件是否需要增强<br>是：切面的通知方法，包装成增强器（Advisor）; 给业务逻辑组件创建一个代理对象（cglib）；<br>5）、执行目标方法：<br>1）、代理对象执行目标方法<br>2）、CglibAopProxy.intercept()；<br>1）、得到目标方法的拦截器链（增强器包装成拦截器 MethodInterceptor）<br>2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>3）、效果：<br>正常执行：前置通知 -》目标方法 -》后置通知 -》返回通知<br>出现异常：前置通知 -》目标方法 -》后置通知 -》异常通知</p><h2 id="2-6-顺序问题-【两种顺序】⭐️🔴"><a href="#2-6-顺序问题-【两种顺序】⭐️🔴" class="headerlink" title="2.6. 顺序问题 -【两种顺序】⭐️🔴"></a>2.6. 顺序问题 -【两种顺序】⭐️🔴</h2><p><span style="display:none">%%<br>▶29.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230323-1550%%</span>❕ ^8u7u46</p><h4 id="2-6-1-通知执行与目标方法执行之间的顺序在哪确定的⭐️🔴"><a href="#2-6-1-通知执行与目标方法执行之间的顺序在哪确定的⭐️🔴" class="headerlink" title="2.6.1. 通知执行与目标方法执行之间的顺序在哪确定的⭐️🔴"></a>2.6.1. 通知执行与目标方法执行之间的顺序在哪确定的⭐️🔴</h4><p>在各种通知的源码中写死的，这种顺序是不会变的，而拦截器链中通知的顺序可以通过 <code>@Order</code> 注解改变 ❕<span style="display:none">%%<br>1608-🏡⭐️◼️通知方法和目标方法之间的执行顺序 ?🔜MSTM📝 各种不同的通知写死在源码里的，这个顺序是不能变化的◼️⭐️-point-20230211-1608%%</span></p><h5 id="2-6-1-1-通知种类"><a href="#2-6-1-1-通知种类" class="headerlink" title="2.6.1.1. 通知种类"></a>2.6.1.1. 通知种类</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Ethan_199402/article/details/109491789">https://blog.csdn.net/Ethan_199402/article/details/109491789</a><br>是否是 MethodInterceptor 类型的<br>ExposeInvocationInterceptor：是<br><span style="background-color:#f0f">AspectJAfterThrowingAdvice: 是</span><br><span style="background-color:#ff0">AspectJAfterReturningAdvice: 不是，转换为 AfterReturningAdviceInterceptor</span><br>AspectJAfterAdvice: 是<br>AspectJAroundAdvice 是<br><span style="background-color:#ff0">AspectJMethodBeforeAdvice 不是，转换为 MethodBeforeAdviceInterceptor</span></p><p>PS: 虽然有适配器，但 AspectJAfterThrowingAdvice 实现了 MethodInterceptor<br><a target="_blank" rel="noopener" href="https://www.vnjohn.com/aop-process-source.html">https://www.vnjohn.com/aop-process-source.html</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211110153.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211110253.png" alt="image.png"></p><h5 id="2-6-1-2-ExposeInvocationInterceptor"><a href="#2-6-1-2-ExposeInvocationInterceptor" class="headerlink" title="2.6.1.2. ExposeInvocationInterceptor"></a>2.6.1.2. ExposeInvocationInterceptor</h5><p>当生成代理对象之后，该进行逻辑方法的调用了；但此时，有 6 个 advisor，除了五种增强通知之外，还有一个是 ExposeInvocationInterceptor（将当前 methodInvocation 存入线程上下文）它起着一个桥梁的作用，它们在执行时是按照某个顺序来执行的，而且由一个通知跳转到另外一个通知，所以此时，我们需要构建一个拦截器链（责任链模式）只有创建好链式结构，才能顺序的往下执行.</p><p>在 <code>findEligibleAdvisors</code> 方法中调用 <code>makeAdvisorChainAspectJCapableIfNecessary</code> 创建增强器链时被加入到增强器链中<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230323161037.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230323161550.png" alt="png"></p><h5 id="2-6-1-3-AspectJAfterThrowingAdvice"><a href="#2-6-1-3-AspectJAfterThrowingAdvice" class="headerlink" title="2.6.1.3. AspectJAfterThrowingAdvice"></a>2.6.1.3. AspectJAfterThrowingAdvice</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAfterThrowingAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAspectJAdvice</span>  <br>      <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span>, AfterAdvice, Serializable &#123;<br> ...     <br>	<span class="hljs-meta">@Override</span>  <br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>	   <span class="hljs-keyword">try</span> &#123;  <br>	      <span class="hljs-keyword">return</span> mi.proceed();  <br>	   &#125;  <br>	   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;  <br>	      <span class="hljs-keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;  <br>	         invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-literal">null</span>, ex);  <br>	      &#125;  <br>	      <span class="hljs-keyword">throw</span> ex;  <br>	   &#125;  <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-6-1-4-AfterReturningAdviceInterceptor⭐️"><a href="#2-6-1-4-AfterReturningAdviceInterceptor⭐️" class="headerlink" title="2.6.1.4. AfterReturningAdviceInterceptor⭐️"></a>2.6.1.4. AfterReturningAdviceInterceptor⭐️</h5><p>由 AfterReturningAdvice 适配而来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span>, AfterAdvice, Serializable &#123;  <br>  <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AfterReturningAdvice advice;  <br>  <br>   <span class="hljs-meta">@Override</span>  <br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>      <span class="hljs-type">Object</span> <span class="hljs-variable">retVal</span> <span class="hljs-operator">=</span> mi.proceed();  <br>      <span class="hljs-built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());  <br>      <span class="hljs-keyword">return</span> retVal;  <br>   &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-6-1-5-AspectJAfterAdvice"><a href="#2-6-1-5-AspectJAfterAdvice" class="headerlink" title="2.6.1.5. AspectJAfterAdvice"></a>2.6.1.5. AspectJAfterAdvice</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAfterAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAspectJAdvice</span>  <br>      <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span>, AfterAdvice, Serializable &#123;  <br>  ...<br>   <span class="hljs-meta">@Override</span>  <br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>      <span class="hljs-keyword">try</span> &#123;  <br>         <span class="hljs-comment">// 执行下一个通知/拦截器  </span><br>         <span class="hljs-keyword">return</span> mi.proceed();  <br>      &#125;  <br>      <span class="hljs-keyword">finally</span> &#123;  <br>         <span class="hljs-comment">// 后置通知的方法总是会被执行,原因就在这finally  </span><br>         invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <br>      &#125;  <br>   &#125;  <br>...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-6-1-6-AspectJAroundAdvice"><a href="#2-6-1-6-AspectJAroundAdvice" class="headerlink" title="2.6.1.6. AspectJAroundAdvice"></a>2.6.1.6. AspectJAroundAdvice</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAroundAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAspectJAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span>, Serializable &#123;  <br>...<br>   <span class="hljs-meta">@Override</span>  <br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>      <span class="hljs-keyword">if</span> (!(mi <span class="hljs-keyword">instanceof</span> ProxyMethodInvocation)) &#123;  <br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);  <br>      &#125;  <br>      <span class="hljs-type">ProxyMethodInvocation</span> <span class="hljs-variable">pmi</span> <span class="hljs-operator">=</span> (ProxyMethodInvocation) mi;  <br>      <span class="hljs-type">ProceedingJoinPoint</span> <span class="hljs-variable">pjp</span> <span class="hljs-operator">=</span> lazyGetProceedingJoinPoint(pmi);  <br>      <span class="hljs-type">JoinPointMatch</span> <span class="hljs-variable">jpm</span> <span class="hljs-operator">=</span> getJoinPointMatch(pmi);  <br>      <span class="hljs-keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <br>   &#125;  <br>...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-6-1-7-MethodBeforeAdviceInterceptor⭐️"><a href="#2-6-1-7-MethodBeforeAdviceInterceptor⭐️" class="headerlink" title="2.6.1.7. MethodBeforeAdviceInterceptor⭐️"></a>2.6.1.7. MethodBeforeAdviceInterceptor⭐️</h5><p>由 AspectJMethodBeforeAdvice 适配而来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MethodBefore前置通知Interceptor</span><br><span class="hljs-comment">// 实现了MethodInterceptor接口,持有AspectJMethodBeforeAdvice对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodBeforeAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span>, BeforeAdvice, Serializable &#123;  <br>  <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodBeforeAdvice advice;  <br>   <span class="hljs-comment">/**  </span><br><span class="hljs-comment">    * 为指定的advice创建对应的MethodBeforeAdviceInterceptor对象  </span><br><span class="hljs-comment">    *  </span><br><span class="hljs-comment">    * Create a new MethodBeforeAdviceInterceptor for the given advice.    * <span class="hljs-doctag">@param</span> advice the MethodBeforeAdvice to wrap  </span><br><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodBeforeAdviceInterceptor</span><span class="hljs-params">(MethodBeforeAdvice advice)</span> &#123;  <br>      Assert.notNull(advice, <span class="hljs-string">&quot;Advice must not be null&quot;</span>);  <br>      <span class="hljs-built_in">this</span>.advice = advice;  <br>   &#125;  <br>    <br>   <span class="hljs-comment">// 这个invoke方法是拦截器的回调方法，会在代理对应的方法被调用时触发回调  </span><br>   <span class="hljs-meta">@Override</span>  <br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>      <span class="hljs-comment">// 执行前置通知的方法  </span><br>      <span class="hljs-built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());  <br>      <span class="hljs-comment">// 执行下一个通知/拦截器，但是该拦截器是最后一个了，所以会调用目标方法  </span><br>      <span class="hljs-keyword">return</span> mi.proceed();  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-2-拦截器链中通知的顺序是在哪里确定的⭐️🔴"><a href="#2-6-2-拦截器链中通知的顺序是在哪里确定的⭐️🔴" class="headerlink" title="2.6.2. 拦截器链中通知的顺序是在哪里确定的⭐️🔴"></a>2.6.2. 拦截器链中通知的顺序是在哪里确定的⭐️🔴</h4><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-0837%%</span>❕ ^q5brru</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230213062027.png" alt="image.png"></p><p><span style="background-color:#ff0">shouldskip 流程</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230213062138.png" alt="image.png"></p><p><code>METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);</code><br>是在 <span style="background-color:#f0f">ReflectiveAspectJAdvisorFactory</span> 中的静态代码块中定义的 ❕<span style="display:none">%%<br>1615-🏡⭐️◼️拦截器链中通知的顺序是如何确定的 ?🔜MSTM📝 拦截器链中的顺序最初是从创建通知的时候确定的，是在 ReflectiveAspectJAdvisorFactory 工厂的静态代码块中定义了：Around、Before、After、AfterReturning、AfterThrowing。创建 advisor 时 declarationOrder 就是 size 大小的数值，所以分别是 0 到 4。然后在创建代理时，获取 advisorsCache 中的 advisors 之后进行了排序，除了用于辅助创建拦截器链的 ExposeInvocationInterceptor 之外，都按 declarationOrder 做了倒序排列，所以最后拦截器链中的顺序就是 ExposeInvocationInterceptor、AfterThrowing、AfterRetruning、After、Before、Around。◼️⭐️-point-20230211-1615%%</span></p><p><code>findCandidateAdvisors</code> → <code>buildAspectJAdvisors</code> → <code>getAdvisors</code> → <code>getAdvisorMethods</code> → <code>getAdvisor</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211141542.png" alt="image.png"></p><p>获取所有不包含 Pointcut 注解的方法，然后进行排序，根据对应的顺序 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211145421.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211160555.png" alt="image.png"></p><h5 id="2-6-2-1-findEligibleAdvisors-sortAdvisors⭐️🔴"><a href="#2-6-2-1-findEligibleAdvisors-sortAdvisors⭐️🔴" class="headerlink" title="2.6.2.1. findEligibleAdvisors.sortAdvisors⭐️🔴"></a>2.6.2.1. findEligibleAdvisors.sortAdvisors⭐️🔴</h5><p>在使用时，除了用于创建链条的 <code>ExposeInvocationInterceptor</code> ，<span style="background-color:#f0f">其他通知都做了倒序排列</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211120820.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211135310.png" alt="image.png"></p><p><strong>不同优先级</strong><br>compareTo → compare → doCompare</p><p><strong>相同优先级且同属一个切面</strong><br>AspectJPrecedenceComparator.comparePrecedenceWithinAspect →<br>getAspectDeclarationOrder</p><h5 id="2-6-2-2-getAdvicesAndAdvisorsForBean"><a href="#2-6-2-2-getAdvicesAndAdvisorsForBean" class="headerlink" title="2.6.2.2. getAdvicesAndAdvisorsForBean"></a>2.6.2.2. getAdvicesAndAdvisorsForBean</h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211121352.png" alt="image.png"></p><h5 id="2-6-2-3-getInterceptorsAndDynamicInterceptionAdvice"><a href="#2-6-2-3-getInterceptorsAndDynamicInterceptionAdvice" class="headerlink" title="2.6.2.3. getInterceptorsAndDynamicInterceptionAdvice"></a>2.6.2.3. getInterceptorsAndDynamicInterceptionAdvice</h5><p>得到的顺序与 <code>getAdvicesAndAdvisorsForBean</code> 是一致的，也就是说排序的地方就在 <code>findEligibleAdvisors.sortAdvisors</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211121913.png" alt="image.png"></p><h5 id="2-6-2-4-自定义顺序"><a href="#2-6-2-4-自定义顺序" class="headerlink" title="2.6.2.4. 自定义顺序"></a>2.6.2.4. 自定义顺序</h5><p><span style="display:none">%%<br>▶8.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230307-0928%%</span>❕ ^1mjgqz</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_KONGlX/article/details/125486683">https://blog.csdn.net/CSDN_KONGlX/article/details/125486683</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/inventory/657/article/1526899">https://cloud.tencent.com/developer/inventory/657/article/1526899</a></p><p>多个@Aspect、Advisor 排序规则</p><p><strong>1、在 spring 容器中获取@Aspect、Advisor 类型的所有 bean，得到一个列表 list1</strong><br><strong>2、对 list1 按照 order 的值升序排序，得到结果 list2</strong><br><strong>3、然后再对 list2 中@Aspect 类型的 bean 内部的通知进行排序，规则</strong><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230211162401.png" alt="image.png"><br>如上图所示，这 2 个 Aspect 就像 2 个圆圈在外面拦截，中间是目标方法。当一个请求进来要执行目标方法：</p><ul><li>首先会被外圈的 <code>@Order(1)</code> 拦截器拦截</li><li>然后被内圈 <code>@Order(2)</code> 拦截器拦截</li><li>执行完目标方法后，先经过 <code>@Order(2)</code> 的后置拦截器</li><li>最后再通过 <code>@Order(1)</code> 的后置拦截器</li></ul><h1 id="3-注解式开发"><a href="#3-注解式开发" class="headerlink" title="3. 注解式开发"></a>3. 注解式开发</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ME411o7Uu?p=8">https://www.bilibili.com/video/BV1ME411o7Uu?p=8</a></p><h2 id="3-1-使用示例"><a href="#3-1-使用示例" class="headerlink" title="3.1. 使用示例"></a>3.1. 使用示例</h2><p>Spring 注解驱动开发 - 尚硅谷 - 雷丰阳&#x2F;spring-annotation&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;atguigu&#x2F;config&#x2F;MainConfigOfAOP.java<br>[[MainConfigOfAOP.java]]</p><h2 id="3-2-主要三步"><a href="#3-2-主要三步" class="headerlink" title="3.2. 主要三步"></a>3.2. 主要三步</h2><ul><li>1）、将业务逻辑组件和切面类都加入到容器中；告诉 Spring 哪个是切面类（@Aspect）</li><li>2）、在切面类上的每一个通知方法上标注通知注解，告诉 Spring 何时何地运行（切入点表达式）</li><li>3）、开启基于注解的 aop 模式；@EnableAspectJAutoProxy</li></ul><h2 id="3-3-详细步骤"><a href="#3-3-详细步骤" class="headerlink" title="3.3. 详细步骤"></a>3.3. 详细步骤</h2><ul><li>1、导入 aop 模块；Spring AOP：(spring-aspects)</li><li>2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</li><li>3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知 MathCalculator.div 运行到哪里然后执行；</li><li><pre><code>通知方法：  
</code></pre></li><li><pre><code>   前置通知(@Before)：logStart：在目标方法(div)运行之前运行  
</code></pre></li><li><pre><code>   后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）  
</code></pre></li><li><pre><code>   返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行  
</code></pre></li><li><pre><code>   异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行  
</code></pre></li><li><pre><code>   环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）  
</code></pre></li><li>4、给切面类的目标方法标注何时何地运行（通知注解）；</li><li>5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</li><li>6、必须告诉 Spring 哪个类是切面类 (给切面类上加一个注解：@Aspect)</li><li>7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的 aop 模式】</li><li><pre><code>在Spring中很多的 @EnableXXX;
</code></pre></li></ul><h1 id="4-设计模式"><a href="#4-设计模式" class="headerlink" title="4. 设计模式"></a>4. 设计模式</h1><h2 id="4-1-代理模式"><a href="#4-1-代理模式" class="headerlink" title="4.1. 代理模式"></a>4.1. 代理模式</h2><h2 id="4-2-适配器模式"><a href="#4-2-适配器模式" class="headerlink" title="4.2. 适配器模式"></a>4.2. 适配器模式</h2><p>Spring AOP 的增强或通知 (Advice) 使用到了适配器模式，与之相关的接口是 <code>AdvisorAdapter</code></p><p>Advice 常用的类型有：BeforeAdvice（目标方法调用前,前置通知）、AfterAdvice（目标方法调用后,后置通知）、AfterReturningAdvice(目标方法执行结束后，return 之前) 等等。</p><p>每个类型 Advice（通知）都有对应的拦截器:MethodBeforeAdviceInterceptor、AfterReturningAdviceAdapter、AfterReturningAdviceInterceptor。</p><p>Spring 预定义的通知要通过对应的适配器，适配成 MethodInterceptor 接口 (方法拦截器) 类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。</p><h1 id="5-实战经验"><a href="#5-实战经验" class="headerlink" title="5. 实战经验"></a>5. 实战经验</h1><h2 id="5-1-通知的版本变化"><a href="#5-1-通知的版本变化" class="headerlink" title="5.1. 通知的版本变化"></a>5.1. 通知的版本变化</h2><p><span style="display:none">%%<br>▶34.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-1035%%</span>📙❕ ^nj3sol</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hy4y1B78T?p=32&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Hy4y1B78T?p=32&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221218113347.png"></p><p>确切的说是<span style="background-color:#0f0">5.2.7 版本</span>就发生了变化，将 After 放在 AfterThrowing 或者 AfterReturning 后面，更符合人们的正常思维习惯。</p><p>[[001-Spring面试题笔记#8 2 Spring通知有哪些类型？]]</p><p><span style="background-color:red">顺序的源头</span>：<a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></p><h2 id="5-2-默认动态代理变化⭐️🔴"><a href="#5-2-默认动态代理变化⭐️🔴" class="headerlink" title="5.2. 默认动态代理变化⭐️🔴"></a>5.2. 默认动态代理变化⭐️🔴</h2><p><span style="display:none">%%<br>▶27.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-0949%%</span>❕❕ ^5vgexk</p><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1532547">https://cloud.tencent.com/developer/article/1532547</a></p><ol><li>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。</li><li>SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302143216.png" alt="image.png"></li><li>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项 <code>spring.aop.proxy-target-class=false</code> 来进行修改，<code>proxyTargetClass</code> 配置已无效。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#在application.properties文件中通过spring.aop.proxy-target-class来配置 spring.aop.proxy-target-class=false</span><br></code></pre></td></tr></table></figure><p>自定义注解<br><a target="_blank" rel="noopener" href="http://www.imooc.com/article/22556">http://www.imooc.com/article/22556</a></p><h1 id="6-参考与感谢"><a href="#6-参考与感谢" class="headerlink" title="6. 参考与感谢"></a>6. 参考与感谢</h1><h2 id="6-1-尚硅谷-雷丰阳-Spring-注解驱动开发"><a href="#6-1-尚硅谷-雷丰阳-Spring-注解驱动开发" class="headerlink" title="6.1. 尚硅谷 - 雷丰阳 -Spring 注解驱动开发"></a>6.1. 尚硅谷 - 雷丰阳 -Spring 注解驱动开发</h2><h3 id="6-1-1-视频"><a href="#6-1-1-视频" class="headerlink" title="6.1.1. 视频"></a>6.1.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV114411c7hV/?p=36&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV114411c7hV/?p=36&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="6-1-2-配套代码"><a href="#6-1-2-配套代码" class="headerlink" title="6.1.2. 配套代码"></a>6.1.2. 配套代码</h3><p>[[MainConfigOfAOP.java]]</p><h3 id="6-1-3-配套笔记"><a href="#6-1-3-配套笔记" class="headerlink" title="6.1.3. 配套笔记"></a>6.1.3. 配套笔记</h3><p><a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111413608">https://liayun.blog.csdn.net/article/details/111413608</a></p><h2 id="6-2-尚硅谷-周阳-大厂面试第三季"><a href="#6-2-尚硅谷-周阳-大厂面试第三季" class="headerlink" title="6.2. 尚硅谷 - 周阳 - 大厂面试第三季"></a>6.2. 尚硅谷 - 周阳 - 大厂面试第三季</h2><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;brain-mapping&#x2F;docs&#x2F;大厂面试题第3季.mmap]]</p><h2 id="6-3-图灵徐庶"><a href="#6-3-图灵徐庶" class="headerlink" title="6.3. 图灵徐庶"></a>6.3. 图灵徐庶</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mf4y1c7cV?p=88&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV?p=88&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>[[Spring全家桶面试题—图灵徐庶.pdf]]<br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f5075c763768959e2d109df#map">https://www.processon.com/view/link/5f5075c763768959e2d109df#map</a></p><h2 id="6-4-尚硅谷大数据技术之-Spring"><a href="#6-4-尚硅谷大数据技术之-Spring" class="headerlink" title="6.4. 尚硅谷大数据技术之 Spring"></a>6.4. 尚硅谷大数据技术之 Spring</h2><h3 id="6-4-1-视频"><a href="#6-4-1-视频" class="headerlink" title="6.4.1. 视频"></a>6.4.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av58225341?p=270">https://www.bilibili.com/video/av58225341?p=270</a></p><h3 id="6-4-2-配套代码"><a href="#6-4-2-配套代码" class="headerlink" title="6.4.2. 配套代码"></a>6.4.2. 配套代码</h3><p>[[02_尚硅谷大数据技术之Spring(老师原版).docx]]</p><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;Spring03&#x2F;src&#x2F;com&#x2F;atguigu&#x2F;spring&#x2F;aspectJ&#x2F;xml&#x2F;LoggingAspect.java]]</p><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;Spring03&#x2F;src&#x2F;com&#x2F;atguigu&#x2F;spring&#x2F;aspectJ&#x2F;annotation&#x2F;LoggingAspect.java]]</p><h2 id="6-5-网络笔记"><a href="#6-5-网络笔记" class="headerlink" title="6.5. 网络笔记"></a>6.5. 网络笔记</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/andy_zhang2007/article/details/86479685">https://blog.csdn.net/andy_zhang2007/article/details/86479685</a> <sup><span style="font-size:10px;color:green">»20230220-0911</span></sup><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42419406/article/details/116640641">https://blog.csdn.net/qq_42419406/article/details/116640641</a> <sup><span style="font-size:10px;color:green">»20230220-0928</span></sup></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan882696yan/article/details/115359291">https://blog.csdn.net/yuan882696yan/article/details/115359291</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan882696yan/article/details/116137802">https://blog.csdn.net/yuan882696yan/article/details/116137802</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7037839773267918879#heading-3">https://juejin.cn/post/7037839773267918879#heading-3</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6978742789165187079#heading-6">https://juejin.cn/post/6978742789165187079#heading-6</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041228253">https://segmentfault.com/a/1190000041228253</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b45bf3befa25">https://www.jianshu.com/p/b45bf3befa25</a></p><p><a target="_blank" rel="noopener" href="https://www.luckfirefly.com/archives/spring%E6%8F%AD%E7%A7%98-%E6%B7%B1%E5%85%A5advisedsupport">https://www.luckfirefly.com/archives/spring%E6%8F%AD%E7%A7%98-%E6%B7%B1%E5%85%A5advisedsupport</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lom9357bye/article/details/124659927">https://blog.csdn.net/lom9357bye/article/details/124659927</a> <sup><span style="font-size:10px;color:green">»20230220-0841</span></sup></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/">https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/">框架源码专题</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/AOP/">AOP</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/1082" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/"><img class="prev-cover" src="https://picsum.photos/1920/1080" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-Spring-2、IOC</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/03/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-10%E3%80%81JVM-%E5%90%AF%E5%8A%A8/"><img class="next-cover" src="https://picsum.photos/1920/992" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">性能调优专题-基础-10、JVM-启动</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-0%E3%80%81PostProcessor/" title="框架源码专题-Spring-0、PostProcessor"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">框架源码专题-Spring-0、PostProcessor</div></div></a></div><div><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="框架源码专题-Spring-10、"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">框架源码专题-Spring-10、</div></div></a></div><div><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="1"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">1</div></div></a></div><div><a href="/2022/12/08/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-5%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-@EnableTransactionManagement/" title="框架源码专题-Spring-5、声明式事务"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">框架源码专题-Spring-5、声明式事务</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="框架源码专题-Spring-8、BeanDefinition"><img class="cover" src="https://picsum.photos/1920/1080" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-02</div><div class="title">框架源码专题-Spring-8、BeanDefinition</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-AOP"><span class="toc-text">1. AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%86%E7%B1%BB%E6%AF%94%E8%BE%83"><span class="toc-text">1.1. 分类比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9"><span class="toc-text">1.2. 方案选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E6%9E%90"><span class="toc-text">1.3. 术语解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3.1. 配套代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E7%9B%AE%E6%A0%87-Target"><span class="toc-text">1.3.2. 目标 (Target)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E4%BB%A3%E7%90%86-Proxy"><span class="toc-text">1.3.3. 代理 (Proxy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="toc-text">1.3.4. 横切关注点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5-%E9%80%9A%E7%9F%A5-Advice"><span class="toc-text">1.3.5. 通知 (Advice)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-6-%E5%88%87%E9%9D%A2-Aspect"><span class="toc-text">1.3.6. 切面 (Aspect)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-7-%E8%BF%9E%E6%8E%A5%E7%82%B9-Joinpoint"><span class="toc-text">1.3.7. 连接点 (Joinpoint)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4. 实现方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SpringAOP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. SpringAOP 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">2.1. 容器环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B3%A8%E5%86%8C-Creator-BD"><span class="toc-text">2.2. 注册 Creator BD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-AspectJAutoProxyRegistrar-%E6%B3%A8%E5%86%8C-CreatorBD"><span class="toc-text">2.2.1. AspectJAutoProxyRegistrar(注册 CreatorBD)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-1-EnableAspectJAutoProxy"><span class="toc-text">2.2.1.1. @EnableAspectJAutoProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-2-AnnotationAwareAspectJAutoProxyCreator"><span class="toc-text">2.2.1.2. AnnotationAwareAspectJAutoProxyCreator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-1-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">2.2.1.2.1. 继承关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-2-%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.1.2.2. 关键方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%B3%A8%E5%86%8C-Creator-BPP-Bean"><span class="toc-text">2.2.2. 注册 Creator BPP Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-%E5%88%9B%E5%BB%BA-BPP-Bean"><span class="toc-text">2.2.2.1. 创建 BPP Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-%E8%AE%BE%E7%BD%AE-BeanFactory"><span class="toc-text">2.2.2.2. 设置 BeanFactory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A2%9E%E5%BC%BA%E9%80%BB%E8%BE%91"><span class="toc-text">2.3. 增强逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-postProcessBeforeInstantiation-%E8%A7%A3%E6%9E%90%E5%88%87%E9%9D%A2%E5%B9%B6%E7%BC%93%E5%AD%98%E9%80%9A%E7%9F%A5"><span class="toc-text">2.3.1. postProcessBeforeInstantiation(解析切面并缓存通知)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-1-getCustomTargetSource"><span class="toc-text">2.3.1.1. getCustomTargetSource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-2-findCandidateAdvisors"><span class="toc-text">2.3.1.2. findCandidateAdvisors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-3-buildAspectJAdvisors%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.3.1.3. buildAspectJAdvisors⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-1-AspectJAdvisorFactory-getAdvisors"><span class="toc-text">2.3.1.3.1. AspectJAdvisorFactory.getAdvisors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-2-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.3.1.3.2. 事务相关内容⭐️🔴⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-4-%E7%BB%93%E8%AE%BA"><span class="toc-text">2.3.1.4. 结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-postProcessAfterInitialization-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86"><span class="toc-text">2.3.2. postProcessAfterInitialization(使用缓存创建代理)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-wrapIfNecessary"><span class="toc-text">2.3.2.1. wrapIfNecessary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-getAdvicesAndAdvisorsForBean"><span class="toc-text">2.3.2.2. getAdvicesAndAdvisorsForBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-3-findEligibleAdvisors"><span class="toc-text">2.3.2.3. findEligibleAdvisors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-4-createProxy"><span class="toc-text">2.3.2.4. createProxy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-text">2.4. 执行逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%B0%81%E8%A3%85%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.4.1. 获取并封装拦截器链⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%A7%A6%E5%8F%91%E6%89%A7%E8%A1%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-text">2.4.2. 触发执行拦截器链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-1-%E6%89%A7%E8%A1%8C%E5%85%A5%E5%8F%A3"><span class="toc-text">2.4.2.1. 执行入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-2-%E6%89%A7%E8%A1%8C%E5%87%BA%E5%8F%A3"><span class="toc-text">2.4.2.2. 执行出口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-3-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.2.3. 执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-4-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-text">2.4.2.4. 执行顺序分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0"><span class="toc-text">2.5. 简单概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98-%E3%80%90%E4%B8%A4%E7%A7%8D%E9%A1%BA%E5%BA%8F%E3%80%91%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.6. 顺序问题 -【两种顺序】⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E4%B9%8B%E9%97%B4%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%9C%A8%E5%93%AA%E7%A1%AE%E5%AE%9A%E7%9A%84%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.6.1. 通知执行与目标方法执行之间的顺序在哪确定的⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-1-%E9%80%9A%E7%9F%A5%E7%A7%8D%E7%B1%BB"><span class="toc-text">2.6.1.1. 通知种类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-2-ExposeInvocationInterceptor"><span class="toc-text">2.6.1.2. ExposeInvocationInterceptor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-3-AspectJAfterThrowingAdvice"><span class="toc-text">2.6.1.3. AspectJAfterThrowingAdvice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-4-AfterReturningAdviceInterceptor%E2%AD%90%EF%B8%8F"><span class="toc-text">2.6.1.4. AfterReturningAdviceInterceptor⭐️</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-5-AspectJAfterAdvice"><span class="toc-text">2.6.1.5. AspectJAfterAdvice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-6-AspectJAroundAdvice"><span class="toc-text">2.6.1.6. AspectJAroundAdvice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-7-MethodBeforeAdviceInterceptor%E2%AD%90%EF%B8%8F"><span class="toc-text">2.6.1.7. MethodBeforeAdviceInterceptor⭐️</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E4%B8%AD%E9%80%9A%E7%9F%A5%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%9C%A8%E5%93%AA%E9%87%8C%E7%A1%AE%E5%AE%9A%E7%9A%84%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.6.2. 拦截器链中通知的顺序是在哪里确定的⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-1-findEligibleAdvisors-sortAdvisors%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.6.2.1. findEligibleAdvisors.sortAdvisors⭐️🔴</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-2-getAdvicesAndAdvisorsForBean"><span class="toc-text">2.6.2.2. getAdvicesAndAdvisorsForBean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-3-getInterceptorsAndDynamicInterceptionAdvice"><span class="toc-text">2.6.2.3. getInterceptorsAndDynamicInterceptionAdvice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.6.2.4. 自定义顺序</span></a></li></ol></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-text">3. 注解式开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1. 使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%BB%E8%A6%81%E4%B8%89%E6%AD%A5"><span class="toc-text">3.2. 主要三步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.3. 详细步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">4. 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1. 代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2. 适配器模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">5. 实战经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%80%9A%E7%9F%A5%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">5.1. 通知的版本变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%BB%98%E8%AE%A4%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%98%E5%8C%96%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.2. 默认动态代理变化⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">6. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E9%9B%B7%E4%B8%B0%E9%98%B3-Spring-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-text">6.1. 尚硅谷 - 雷丰阳 -Spring 注解驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E8%A7%86%E9%A2%91"><span class="toc-text">6.1.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81"><span class="toc-text">6.1.2. 配套代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E9%85%8D%E5%A5%97%E7%AC%94%E8%AE%B0"><span class="toc-text">6.1.3. 配套笔记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3-%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3"><span class="toc-text">6.2. 尚硅谷 - 周阳 - 大厂面试第三季</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%9B%BE%E7%81%B5%E5%BE%90%E5%BA%B6"><span class="toc-text">6.3. 图灵徐庶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B-Spring"><span class="toc-text">6.4. 尚硅谷大数据技术之 Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E8%A7%86%E9%A2%91"><span class="toc-text">6.4.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81"><span class="toc-text">6.4.2. 配套代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0"><span class="toc-text">6.5. 网络笔记</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/1082')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>