<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>框架源码专题-Spring-2、IOC | Taylor</title><meta name="keywords" content="框架源码专题,Spring,IOC"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 容器 API  BeanDefinitionRegistry: 定义对 BeanDefinition 的各种增删改查操作 DefaultSingletonBeanRegistry: Bean 仓库 AutowireCapableBeanFactory: 提供创建 Bean, 自动注入, 初始化已经应用 Bean 的后处理器 ConfigurableListableBeanFactory: B"><meta property="og:type" content="article"><meta property="og:title" content="框架源码专题-Spring-2、IOC"><meta property="og:url" content="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 容器 API  BeanDefinitionRegistry: 定义对 BeanDefinition 的各种增删改查操作 DefaultSingletonBeanRegistry: Bean 仓库 AutowireCapableBeanFactory: 提供创建 Bean, 自动注入, 初始化已经应用 Bean 的后处理器 ConfigurableListableBeanFactory: B"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/1080"><meta property="article:published_time" content="2022-12-04T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.677Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="框架源码专题"><meta property="article:tag" content="Spring"><meta property="article:tag" content="IOC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/1080"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"框架源码专题-Spring-2、IOC",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/1080')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">框架源码专题-Spring-2、IOC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T16:00:00.000Z" title="发表于 2022-12-05 00:00:00">2022-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.677Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/">框架源码专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="框架源码专题-Spring-2、IOC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-容器-API"><a href="#1-容器-API" class="headerlink" title="1. 容器 API"></a>1. 容器 API</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230303200238.png" alt="image.png"></p><ul><li>BeanDefinitionRegistry: 定义对 BeanDefinition 的各种增删改查操作</li><li><span style="background-color:#f0f">DefaultSingletonBeanRegistry: Bean 仓库</span></li><li>AutowireCapableBeanFactory: 提供创建 Bean, 自动注入, 初始化已经应用 Bean 的后处理器</li><li>ConfigurableListableBeanFactory: BeanFactory 配置清单, 指定忽略类型及接口等</li><li><span style="background-color:#f0f">DefaultListableBeanFactory: Bean 工厂</span></li></ul><h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><h2 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1. 工作流程"></a>2.1. 工作流程</h2><ol><li>IOC 是什么</li><li>Bean 的声明方式</li><li>IOC 的工作流程</li></ol><p>IOC 的全称是 Inversion Of Control, 也就是控制反转，它的核心思想是把对象的管理权限交给容器。应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。使得程序的整个体系结构变得更加灵活。</p><h3 id="2-1-1-Bean-定义注册"><a href="#2-1-1-Bean-定义注册" class="headerlink" title="2.1.1. Bean 定义注册"></a>2.1.1. Bean 定义注册</h3><p>Spring 里面很多方式去定义 Bean，（如图）比如 XML 里面的 <code>&lt;bean&gt;</code> 标签、@Service、 @Component、@Repository、@Configuration 配置类中的@Bean 注解等等。 Spring 在启动的时候，会去解析这些 Bean 然后保存到 IOC 容器里面。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230603223202.png" alt="image.png"></p><h3 id="2-1-2-IOC-容器的初始化"><a href="#2-1-2-IOC-容器的初始化" class="headerlink" title="2.1.2. IOC 容器的初始化"></a>2.1.2. IOC 容器的初始化</h3><p>这个阶段主要是根据程序中定义的 XML 或者注解等 Bean 的声明方式 (如图）通过解析和加载后生成 BeanDefinition，然后把 BeanDefinition 注册到 IOC 容器<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230603223452.png" alt="image.png"><br>通过注解或者 xml 声明的 bean 都会解析得到一个 BeanDefinition 实体，实体中包含 这个 bean 中定义的基本属性。 最后把这个 BeanDefinition 保存到一个 Map 集合里面，从而完成了 IOC 的初始化。 IoC 容器的作用就是对这些注册的 Bean 的定义信息进行处理和维护，它 IoC 容器控制 反转的核心。</p><h3 id="2-1-3-Bean-初始化及依赖注入"><a href="#2-1-3-Bean-初始化及依赖注入" class="headerlink" title="2.1.3. Bean 初始化及依赖注入"></a>2.1.3. Bean 初始化及依赖注入</h3><p>然后进入到第二个阶段，这个阶段会做两个事情（如图） 1. 通过反射针对没有设置 lazy-init 属性的单例 bean 进行初始化。 2. 完成 Bean 的依赖注入。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230603223858.png" alt="image.png"></p><h3 id="2-1-4-Bean-的使用"><a href="#2-1-4-Bean-的使用" class="headerlink" title="2.1.4. Bean 的使用"></a>2.1.4. Bean 的使用</h3><p>（如图）通常我们会通过@Autowired 或者 BeanFactory.getBean() 从 IOC 容器中获取指定的 bean 实例。另外，针对设置 lazy-init 属性以及非单例 bean 的实例化，是在每次获取 bean 对象的时候，调用 bean 的初始化方法来完成实例化的，并且 Spring IOC 容器不会去管理这些 Bean<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230603223932.png" alt="image.png"></p><h2 id="2-2-生命周期"><a href="#2-2-生命周期" class="headerlink" title="2.2. 生命周期"></a>2.2. 生命周期</h2><p>Spring 加载流程图 (徐庶)<br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f15341b07912906d9ae8642">https://www.processon.com/view/link/5f15341b07912906d9ae8642</a></p><h1 id="3-容器刷新"><a href="#3-容器刷新" class="headerlink" title="3. 容器刷新"></a>3. 容器刷新</h1><p>Spring 容器刷新 12 步详细<br><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/639548487d9c084a6a3d4021">https://www.processon.com/diagraming/639548487d9c084a6a3d4021</a></p><h1 id="4-循环依赖"><a href="#4-循环依赖" class="headerlink" title="4. 循环依赖"></a>4. 循环依赖</h1><h2 id="4-1-循环依赖的种类⭐️🔴"><a href="#4-1-循环依赖的种类⭐️🔴" class="headerlink" title="4.1. 循环依赖的种类⭐️🔴"></a>4.1. 循环依赖的种类⭐️🔴</h2><h3 id="4-1-1-属性注入依赖"><a href="#4-1-1-属性注入依赖" class="headerlink" title="4.1.1. 属性注入依赖"></a>4.1.1. 属性注入依赖</h3><p>通过三级缓存解决 ❕<span style="display:none">%%<br>2153-🏡⭐️◼️Spring 是如何解决循环依赖的？🔜MSTM📝◼️⭐️-point-202301282153%%</span></p><h3 id="4-1-2-构造方法依赖"><a href="#4-1-2-构造方法依赖" class="headerlink" title="4.1.2. 构造方法依赖"></a>4.1.2. 构造方法依赖</h3><p>解决方案：<a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/" title="Spring-2、IOC">Spring-2、IOC</a></p><p>懒加载原理：<a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a></p><h3 id="4-1-3-多例模式"><a href="#4-1-3-多例模式" class="headerlink" title="4.1.3. 多例模式"></a>4.1.3. 多例模式</h3><p>无解</p><h2 id="4-2-变更历史"><a href="#4-2-变更历史" class="headerlink" title="4.2. 变更历史"></a>4.2. 变更历史</h2><p>大概是在<span style="background-color:#f0f">Spring2.0.3</span>加入了循环依赖的解决方案，在 springBean 的生命周期管理之后加入的新代码。其中涉及到了代理类生成时机的冲突问题<br>Spring 正常的代理应该是发生在 bean 初始化后，由 AbstractAutoProxyCreator.postProcessAfterInitialization 处理。而循环依赖要求 bean 在填充属性前就提前生成代理，否则就会出现最终版本不一致错误。所以 Spring 在代码中开了个口子，循环依赖发生时，提前代理，没有循环依赖，代理方式不变，依然是初始化以后代理。<br>其实也可以不分提前代理和正常代理，全部的 Bean 都直接提前生成代理，但那样的话 AbstractAutoProxyCreator.postProcessAfterInitialization 直接废了，相当于把原本的逻辑推翻重写，如此只是为了解决循环依赖的话就会变得得不偿失，没有完全必要的情况下对核心代码大改甚至推翻重写是一种大忌。</p><p>而三级缓存的实现提供了提前生成代理的口子，而不是直接生成代理，只有发生循环依赖<span style="background-color:#0f0">执行 getObject 才会生成代理</span>，达到上述循环依赖发生时，提前代理，没有循环依赖，代理方式不变，依然是初始化以后代理的目的。</p><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012098021/article/details/107352463/">https://blog.csdn.net/u012098021/article/details/107352463/</a></p><h3 id="4-2-1-关闭默认支持循环依赖"><a href="#4-2-1-关闭默认支持循环依赖" class="headerlink" title="4.2.1. 关闭默认支持循环依赖"></a>4.2.1. 关闭默认支持循环依赖</h3><p>SpringBoot2.6 之后关闭了默认支持循环依赖的开关<br>开启方法： <code>spring.main.allow-circular-references=true</code></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7096798740593246222">https://juejin.cn/post/7096798740593246222</a></p><h2 id="4-3-循环依赖流程⭐️🔴"><a href="#4-3-循环依赖流程⭐️🔴" class="headerlink" title="4.3. 循环依赖流程⭐️🔴"></a>4.3. 循环依赖流程⭐️🔴</h2><p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/639c04ed1efad465c9cd90da">https://www.processon.com/diagraming/639c04ed1efad465c9cd90da</a><br><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/639e8c7f1efad465c9cfdd1a">https://www.processon.com/diagraming/639e8c7f1efad465c9cfdd1a</a></p><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f1fb2cf1e08533a628a7b4c">https://www.processon.com/view/link/5f1fb2cf1e08533a628a7b4c</a></p><h3 id="4-3-1-各级缓存的加入时机"><a href="#4-3-1-各级缓存的加入时机" class="headerlink" title="4.3.1. 各级缓存的加入时机"></a>4.3.1. 各级缓存的加入时机</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322180813.png" alt="image.png"></p><h4 id="4-3-1-1-一级缓存"><a href="#4-3-1-1-一级缓存" class="headerlink" title="4.3.1.1. 一级缓存"></a>4.3.1.1. 一级缓存</h4><p><code>Map&lt;String, Object&gt; singletonObjects</code><br>new ConcurrentHashMap&lt;&gt;(256)<br><span style="background-color:#f0f">解决完整 Bean 与不完整 Bean 混乱问题</span></p><h4 id="4-3-1-2-二级缓存"><a href="#4-3-1-2-二级缓存" class="headerlink" title="4.3.1.2. 二级缓存"></a>4.3.1.2. 二级缓存</h4><p><span style="display:none">%%<br>▶39.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-1708%%</span>❕ ^kyatt6</p><p><code>Map&lt;String, Object&gt; earlySingletonObjects</code><br>new ConcurrentHashMap&lt;&gt;(16)<br><span style="background-color:#f0f">提供缓存功能，以便从中获取原始或者代理对象，同时能够解决动态代理多次创建问题</span><br><span style="background-color:red">只要有循环依赖，不管有没有 AOP，<code>earlySingletonObjects</code> 里都会有数据，比如 ABA，AB 在 3 级缓存中都有数据，B 在后面填充属性 A 时将 A 的三级缓存用掉，生成半成品 A 放入 2 级缓存中，3 级缓存的 A 被删除。而 B 直接从 3 级来到 1 级。</span><br><span style="background-color:#f0f">只是二级缓存中可能是原始 Bean，也可能是代理 Bean</span></p><h4 id="4-3-1-3-三级缓存"><a href="#4-3-1-3-三级缓存" class="headerlink" title="4.3.1.3. 三级缓存"></a>4.3.1.3. 三级缓存</h4><p><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code><br>new HashMap&lt;&gt;(16)</p><p><span style="background-color:red">实例对象创建之后，属性填充之前</span><br>检测循环依赖条件：<span style="background-color:#f0f">单例&amp;允许循环依赖&amp;当前 bean 正在创建中</span><br><span style="background-color:#f0f">解决死循环问题</span></p><p><span style="background-color:#f0f">不管有没有循环依赖，三级缓存中都会有数据</span></p><h2 id="4-4-循环依赖问题汇总"><a href="#4-4-循环依赖问题汇总" class="headerlink" title="4.4. 循环依赖问题汇总"></a>4.4. 循环依赖问题汇总</h2><h3 id="4-4-1-为什么一级二级是-ConcurrentHashMap"><a href="#4-4-1-为什么一级二级是-ConcurrentHashMap" class="headerlink" title="4.4.1. 为什么一级二级是 ConcurrentHashMap"></a>4.4.1. 为什么一级二级是 ConcurrentHashMap</h3><p>因为先手线程加锁加在查询一级、二级缓存之后，所以一级、二级缓存的查询需要支持并发而不影响性能</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pe4y1h7wK?p=19&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1pe4y1h7wK?p=19&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217082853.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217082919.png"></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ET4y1N7Sp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1ET4y1N7Sp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>debug 了 AOP+ 循环依赖</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221216174022.png" alt=" zzzz"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221216111636.png"></p><p>最新 Spring 全家桶 -2021 面试 - 重灾区：Spring&#x2F;SpringCloud&#x2F;SpringBoot&#x2F;SpringMVC，肝完就跳槽</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x64y1x71b?p=56">https://www.bilibili.com/video/BV1x64y1x71b?p=56</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pY4y1A7Pv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204!%5B%5D(https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221216101945.png)">https://www.bilibili.com/video/BV1pY4y1A7Pv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204![](https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221216101945.png)</a></p><h2 id="4-5-AOP-提前代理逻辑"><a href="#4-5-AOP-提前代理逻辑" class="headerlink" title="4.5. AOP 提前代理逻辑"></a>4.5. AOP 提前代理逻辑</h2><h3 id="4-5-1-正常代理"><a href="#4-5-1-正常代理" class="headerlink" title="4.5.1. 正常代理"></a>4.5.1. 正常代理</h3><p>对象初始化之后创建动态代理，这是 SpringBean 的正常生命周期<br>BeanPostProcessor.<span style="background-color:#f0f">postProcessAfterInitialization()</span>，具体实现类是<span style="background-color:#f0f">AbstractAutoProxyCreator</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230129150239.png" alt="image.png"></p><h3 id="4-5-2-提前代理"><a href="#4-5-2-提前代理" class="headerlink" title="4.5.2. 提前代理"></a>4.5.2. 提前代理</h3><h4 id="4-5-2-1-getEarlyBeanReference"><a href="#4-5-2-1-getEarlyBeanReference" class="headerlink" title="4.5.2.1. getEarlyBeanReference"></a>4.5.2.1. getEarlyBeanReference</h4><p><span style="display:none">%%<br>▶32.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230323-1933%%</span>❕ ^qideqv</p><p><span style="background-color:#f0f">getEarlyBeanReference 方法就是为了生成提前代理对象而设计的。</span><br>如果有代理❕<span style="display:none">%%<br>▶9.🏡⭐️◼️项目中开启 AOP 的情况 ?🔜MSTM📝 项目中使用了@EnableAspectJAutoProxyCreator 或者@EnableTransactionManagement 注解，或者是 SpringBoot 项目 (自动开启 AOP)，并且代码中使用了切面及通知方法◼️⭐️-point-20230303-1940%%</span>，那么在 6. registerBeanPostProcessors() 中会将提供 AOP 功能的 Bean(AnnotationAwareAspectJAutoProxyCreator) 注册完成，然后在后面的 getEarlyBeanReference(beanName, mbd, bean) 方法中就会走 AbstractAutoProxyCreator 的实现，返回 proxy。否则，如果没有 AOP 代理，那么会走 SmartInstantiationAwareBeanPostProcessor 的默认实现，返回正常 bean</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230129150452.png" alt="image.png"></p><h4 id="4-5-2-2-细节"><a href="#4-5-2-2-细节" class="headerlink" title="4.5.2.2. 细节"></a>4.5.2.2. 细节</h4><p>防止提前代理后，正常代理再生成一次代理<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221216185956.png"></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012098021/article/details/107352463/">https://blog.csdn.net/u012098021/article/details/107352463/</a></p><p>代理对象示例</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221217144110.png"></p><h4 id="4-5-2-3-产生的影响⭐️🔴"><a href="#4-5-2-3-产生的影响⭐️🔴" class="headerlink" title="4.5.2.3. 产生的影响⭐️🔴"></a>4.5.2.3. 产生的影响⭐️🔴</h4><p><span style="display:none">%%<br>▶10.🏡⭐️◼️【如果开启了代理，并且当前 Bean 使用了切面或者事务就会注入动态代理】◼️⭐️-point-20230303-2023%%</span><br><span style="background-color:#f0f">@Autowired 自动注入的对象有可能会是代理对象，取决于 Bean 是否使用了 AOP 注解</span><br>spring 很多功能都是通过 aop 来实现，比如事务，缓存注解，异步、还有一些自定义的 aop 等等，而 aop 是通过动态代理来实现的，spring 主要用到的动态代理有 jdk 的动态代理和 cglib。</p><ul><li>Spring 在没有使用 aop 的时候自动注入的时候是原始类型对象</li><li>在发生 aop 的时候，若代理对象有实现接口，则默认会使用 jdk 动态代理</li><li>在发生 aop 的时候，若代理对象没有实现接口，则默认会使用 cglib 动态代理</li><li>jdk 动态代理必须有实现接口</li><li>可以强制使用 cglib 来做 spring 动态代理</li></ul><p>示例代码： <a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/29ce37bd3f6f4c5b405549c06">https://xie.infoq.cn/article/29ce37bd3f6f4c5b405549c06</a></p><h3 id="4-5-3-二级缓存的作用"><a href="#4-5-3-二级缓存的作用" class="headerlink" title="4.5.3. 二级缓存的作用"></a>4.5.3. 二级缓存的作用</h3><ol><li><p>如果调用 getEarlyBeanReference 生成动态代理对象立即返回，不使用二级缓存来缓存起来，就会出现多次生成同一个对象的动态代理的情况，比如 B、C 都与 A 循环依赖，那么不用缓存判断，直接返回的话，就会生成 2 次 A 的代理对象 ❕<span style="display:none">%%<br>1519-🏡⭐️◼️二级缓存的作用是什么？🔜MSTM📝 除了缓存正常对象的半成品对象，最主要的功能是防止重复生成动态代理对象◼️⭐️-point-202301291519%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230129151801.png" alt="image.png"></p></li><li><p>如果提前代理，后面需要从二级缓存中取出返回出去。</p></li></ol><h3 id="4-5-4-测试程序"><a href="#4-5-4-测试程序" class="headerlink" title="4.5.4. 测试程序"></a>4.5.4. 测试程序</h3><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;spring-framework&#x2F;springsource-test&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;atguigu&#x2F;spring&#x2F;config&#x2F;MainConfig.java]]</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322165716.png" alt="image.png"><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y117RJ?p=188&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y117RJ?p=188&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="4-6-Async-导致循环依赖报错⭐️🔴"><a href="#4-6-Async-导致循环依赖报错⭐️🔴" class="headerlink" title="4.6. @Async 导致循环依赖报错⭐️🔴"></a>4.6. @Async 导致循环依赖报错⭐️🔴</h2><h3 id="4-6-1-原因分析"><a href="#4-6-1-原因分析" class="headerlink" title="4.6.1. 原因分析"></a>4.6.1. 原因分析</h3><p>❕<span style="display:none">%%<br>0836-🏡⭐️◼️一句话概括@Async 导致循环依赖报错的原因🔜MSTM📝 一句话：发生循环依赖时，没有像 AOP 一样做到提前代理：在实例化之后放入三级缓存，在属性填充时真正用到的时候调用 <code>singletonFactory.getObject()</code> 时根据是否用到 AOP 来决定填充一个代理对象。@EnableAsync 在属性填充时给了一个半成品对象，而在初始化完成之后又变成了动态代理对象，导致前后不一致。◼️⭐️-point-202302030836%%</span><br>@EnableAsync 开启时它会向容器内注入 <code>AsyncAnnotationBeanPostProcessor</code>，它是一个 BeanPostProcessor，实现了<span style="background-color:#f0f">postProcessAfterInitialization</span>方法。此处我们看代码，创建代理的动作在抽象父类 AbstractAdvisingBeanPostProcessor 上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @since 3.2   注意：@EnableAsync在Spring3.1后出现</span><br><span class="hljs-comment">// 继承自ProxyProcessorSupport，所以具有动态代理相关属性~ 方便创建代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAdvisingBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ProxyProcessorSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>	<span class="hljs-comment">// 这里会缓存所有被处理的Bean~~~  eligible：合适的</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Boolean&gt; eligibleBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br>	<span class="hljs-comment">//postProcessBeforeInitialization方法什么不做~</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br><br>	<span class="hljs-comment">// 关键是这里。当Bean初始化完成后这里会执行，这里会决策看看要不要对此Bean创建代理对象再返回~~~</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisor == <span class="hljs-literal">null</span> || bean <span class="hljs-keyword">instanceof</span> AopInfrastructureBean) &#123;<br>			<span class="hljs-comment">// Ignore AOP infrastructure such as scoped proxies.</span><br>			<span class="hljs-keyword">return</span> bean;<br>		&#125;<br><br>		<span class="hljs-comment">// 如果此Bean已经被代理了（比如已经被事务那边给代理了~~）</span><br>		<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Advised) &#123;<br>			<span class="hljs-type">Advised</span> <span class="hljs-variable">advised</span> <span class="hljs-operator">=</span> (Advised) bean;<br>		<br>			<span class="hljs-comment">// 此处拿的是AopUtils.getTargetClass(bean)目标对象，做最终的判断</span><br>			<span class="hljs-comment">// isEligible()是否合适的判断方法  是本文最重要的一个方法，下文解释~</span><br>			<span class="hljs-comment">// 此处还有个小细节：isFrozen为false也就是还没被冻结的时候，就只向里面添加一个切面接口   并不要自己再创建代理对象了  省事</span><br>			<span class="hljs-keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;<br>				<span class="hljs-comment">// Add our local Advisor to the existing proxy&#x27;s Advisor chain...</span><br>				<span class="hljs-comment">// beforeExistingAdvisors决定这该advisor最先执行还是最后执行</span><br>				<span class="hljs-comment">// 此处的advisor为：AsyncAnnotationAdvisor  它切入Class和Method标注有@Aysnc注解的地方~~~</span><br>				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beforeExistingAdvisors) &#123;<br>					advised.addAdvisor(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.advisor);<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					advised.addAdvisor(<span class="hljs-built_in">this</span>.advisor);<br>				&#125;<br>				<span class="hljs-keyword">return</span> bean;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// 若不是代理对象，此处就要下手了~~~~isEligible() 这个方法特别重要</span><br>		<span class="hljs-keyword">if</span> (isEligible(bean, beanName)) &#123;<br>			<span class="hljs-comment">// copy属性  proxyFactory.copyFrom(this); 生成一个新的ProxyFactory </span><br>			<span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> prepareProxyFactory(bean, beanName);<br>			<span class="hljs-comment">// 如果没有强制采用CGLIB 去探测它的接口~</span><br>			<span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>				evaluateProxyInterfaces(bean.getClass(), proxyFactory);<br>			&#125;<br>			<span class="hljs-comment">// 添加进此切面~~ 最终为它创建一个getProxy 代理对象</span><br>			proxyFactory.addAdvisor(<span class="hljs-built_in">this</span>.advisor);<br>			<span class="hljs-comment">//customize交给子类复写（实际子类目前都没有复写~）</span><br>			customizeProxyFactory(proxyFactory);<br>			<span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());<br>		&#125;<br><br>		<span class="hljs-comment">// No proxy needed.</span><br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 我们发现BeanName最终其实是没有用到的~~~</span><br>	<span class="hljs-comment">// 但是子类AbstractBeanFactoryAwareAdvisingPostProcessor是用到了的  没有做什么 可以忽略~~~</span><br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEligible</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>		<span class="hljs-keyword">return</span> isEligible(bean.getClass());<br>	&#125;<br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEligible</span><span class="hljs-params">(Class&lt;?&gt; targetClass)</span> &#123;<br>		<span class="hljs-comment">// 首次进来eligible的值肯定为null~~~</span><br>		<span class="hljs-type">Boolean</span> <span class="hljs-variable">eligible</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.eligibleBeans.get(targetClass);<br>		<span class="hljs-keyword">if</span> (eligible != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> eligible;<br>		&#125;<br>		<span class="hljs-comment">// 如果根本就没有配置advisor  也就不用看了~</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisor == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>		<br>		<span class="hljs-comment">// 最关键的就是canApply这个方法，如果AsyncAnnotationAdvisor  能切进它  那这里就是true</span><br>		<span class="hljs-comment">// 本例中方法标注有@Aysnc注解，所以铁定是能被切入的  返回true继续上面方法体的内容</span><br>		eligible = AopUtils.canApply(<span class="hljs-built_in">this</span>.advisor, targetClass);<br>		<span class="hljs-built_in">this</span>.eligibleBeans.put(targetClass, eligible);<br>		<span class="hljs-keyword">return</span> eligible;<br>	&#125;<br>	...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>根本原理是只要能被切面 <code>AsyncAnnotationAdvisor</code> 切入（即只需要类&#x2F;方法有标注 <code>@Async</code> 注解即可）的 Bean，在初始化完成之后，经过 <code>BeanPostProcessor.postProcessAfterInitialization()</code> 最终都会生成一个代理对象（若已经是代理对象里，只需要加入该切面即可了）赋值给上面的 <code>exposedObject</code> 作为返回最终 add 进 Spring 容器内。</p><h3 id="4-6-2-流程分析"><a href="#4-6-2-流程分析" class="headerlink" title="4.6.2. 流程分析"></a>4.6.2. 流程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AInterface</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BInterface b;<br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">funA</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BInterface</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AInterface a;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">funB</span><span class="hljs-params">()</span> &#123;<br>        a.funA();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>A-&gt;B: context.getBean(A) 开始创建 A，A 实例化完成后给 A 的依赖属性 b 开始赋值</li><li>B-&gt;A: context.getBean(B) 开始创建 B，B 实例化完成后给 B 的依赖属性 a 开始赋值</li></ol><blockquote><p>重点：此时因为 A 支持循环依赖，而且没有动态代理所以会执行 A 的 getEarlyBeanReference 方法得到它的早期引用。而执行 getEarlyBeanReference() 的时候因为@Async 根本还没执行，所以最终返回的仍旧是原始对象的地址</p></blockquote><ol start="3"><li>B 完成初始化、完成属性的赋值，此时属性 field 持有的是 Bean A<span style="background-color:#0f0">原始类型的引用</span></li><li>继续 A 的创建流程：完成了 A 的属性的赋值（此时已持有 B 的实例的引用），继续执行初始化方法 initializeBean(…)，在此处会解析@Aysnc 注解，从而生成一个代理对象，所以最终 exposedObject 是一个代理对象（而非原始对象）最终加入到容器里</li></ol><p><span style="display:none">%%<br>▶11.🏡⭐️◼️【原因是 ABA 时，A 实例化完成将原始类型引用放入三级缓存，属性填充 B 时触发 B 的创建流程，B 实例化完成后填充属性时从三级缓存中拿到的是原始类型的 A 的早期引用，B 创建完成后，继续 A 的创建流程，但最后初始化完成后 A 上的@Async 注解生效生成了动态代理，但是 B 中的引用还是原始类型的引用，造成前后不一致】◼️⭐️-point-20230303-2035%%</span> ^vlhwms</p><blockquote><p>上演尴尬的场面：<span style="background-color:#0f0">B 引用的属性 A 是个原始对象，而此处准备 return 的实例 A 竟然是个代理对象，也就是说 B 引用的并非是最终对象（不是最终放进容器里的对象）</span><br>执行自检程序：由于 allowRawInjectionDespiteWrapping 默认值是 false，表示不允许上面不一致的情况发生，so 最终就抛错了</p></blockquote><h3 id="4-6-3-解决方案"><a href="#4-6-3-解决方案" class="headerlink" title="4.6.3. 解决方案"></a>4.6.3. 解决方案</h3><p>通过上面分析，知道了问题的根本原因，现总结出解决上述新问题的解决方案，可分为下面三种方案：</p><ol><li>把 allowRawInjectionDespiteWrapping 设置为 true</li><li>使用@Lazy 或者@ComponentScan(lazyInit &#x3D; true) 解决</li><li>不要让@Async 的 Bean 参与循环依赖</li></ol><p>@Lazy 原理： <a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a></p><h3 id="4-6-4-其他"><a href="#4-6-4-其他" class="headerlink" title="4.6.4. 其他"></a>4.6.4. 其他</h3><p>本质上：@Async 的后置处理器，没有在 getEarlyRefrence 时，创建被@Async 修饰代理对象，而是在 initlizeBean 方法中创建了代理对象。作为对比，被@Aspect 修饰的 Aop 对象会在 getEarlyRefrence 阶段，提前创建代理对象，顾 aop 时不存在该问题</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/92797058">https://blog.csdn.net/f641385712/article/details/92797058</a></p><p>[[(210条消息) 使用@Async异步注解导致该Bean在循环依赖时启动报BeanCurrentlyInCreationException异常的根本原因分析，以及提供解决方案【享学Spring】_YourBatman的博客-CSDN博客]]</p><h2 id="4-7-BFPP-导致自动配置失败"><a href="#4-7-BFPP-导致自动配置失败" class="headerlink" title="4.7. BFPP 导致自动配置失败"></a>4.7. BFPP 导致自动配置失败</h2><p><span style="background-color:#f0f">Bean 工厂后置处理器在容器刷新的第 5 步，远在第 11 步中的 9 大 Bean 后置处理器之上</span><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y117RJ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y117RJ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322185831.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322190004.png" alt="image.png"></p><ol><li>BFPP 尽量使用静态工厂方法</li><li>依赖注入使用局部变量</li></ol><h2 id="4-8-多例的循环依赖"><a href="#4-8-多例的循环依赖" class="headerlink" title="4.8. 多例的循环依赖"></a>4.8. 多例的循环依赖</h2><p>Spring 有没有解决多例 Bean 的循环依赖？<br>a. 多例不会使用缓存进行存储（多例 Bean 每次使用都需要重新创建）<br>b. 不缓存早期对象就无法解决循环</p><p><span style="background-color:#f0f">  关键： 一定要有一个缓存保存它的早期对象作为死循环的出口</span></p><h2 id="4-9-构造方法的循环依赖"><a href="#4-9-构造方法的循环依赖" class="headerlink" title="4.9. 构造方法的循环依赖"></a>4.9. 构造方法的循环依赖</h2><p><span style="display:none">%%<br>▶6.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230322-1813%%</span>❕ ^7cjsyr</p><h3 id="4-9-1-Lazy"><a href="#4-9-1-Lazy" class="headerlink" title="4.9.1. @Lazy"></a>4.9.1. @Lazy</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322174213.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230129154529.png" alt="image.png"></p><p>使用@Lazy 注解，会创建 cglib 动态代理<br><span style="display:none"></span></p><ul><li><input checked disabled type="checkbox"> 🚩 - todo：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/562691467">https://zhuanlan.zhihu.com/p/562691467</a> - 🏡 2023-01-29 15:53 <a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a></li></ul><p><a target="_blank" rel="noopener" href="https://www.yuanjava.cn/posts/spring-constructor-circular-dependencies/">https://www.yuanjava.cn/posts/spring-constructor-circular-dependencies/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/WX10301075WX/article/details/123904543">https://blog.csdn.net/WX10301075WX/article/details/123904543</a></p><p>循环依赖</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220190226.png"></p><h3 id="4-9-2-ObjectFactory"><a href="#4-9-2-ObjectFactory" class="headerlink" title="4.9.2. ObjectFactory"></a>4.9.2. ObjectFactory</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322174709.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322174447.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322174621.png" alt="image.png"></p><h3 id="4-9-3-Provider"><a href="#4-9-3-Provider" class="headerlink" title="4.9.3. Provider"></a>4.9.3. Provider</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322174904.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322175411.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322175431.png" alt="image.png"></p><h3 id="4-9-4-Scope"><a href="#4-9-4-Scope" class="headerlink" title="4.9.4. @Scope"></a>4.9.4. @Scope</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230322175605.png" alt="image.png"></p><h2 id="4-10-防止获取到不完整的-Bean⭐️🔴"><a href="#4-10-防止获取到不完整的-Bean⭐️🔴" class="headerlink" title="4.10. 防止获取到不完整的 Bean⭐️🔴"></a>4.10. 防止获取到不完整的 Bean⭐️🔴</h2><p><span style="display:none">%%<br>▶75.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230306-1455%%</span>❕ ^d4s7ab</p><p><span style="display:none">%%<br>▶12.🏡⭐️◼️【创建对象时用同一把锁同时锁住 2 个地方，分别是 2 个重载的 getsingleton 方法。第一个锁住创建 Bean 的整个流程，包括实例化、属性填充和初始化，在此过程中，第二把锁在三级缓存前面，其他线程按次序到一级、二级缓存中拿都是空的，被阻塞在三级缓存前面。第一个线程创建完对象，放入 1 级缓存，并清空 23 级缓存，第二个线程通过双重检查锁机制，再次查看 1 级缓存就拿到了需要的 Bean】◼️⭐️-point-20230303-2218%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230102105440.png"><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t44y1C73F?p=29&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1t44y1C73F?p=29&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><span style="background-color:#0f0"><font color="#ff0000">上面这个图对应的版本为 5.0.X，后面版本 5.2.X 之后，Spring 只锁在三级缓存前面，也正因此一级、二级缓存用的是 ConcurrentHashMap</font></span> ❕<span style="display:none">%%<br>1741-🏡⭐️◼️Spring 防止不完整的 Bean 的源码中版本变化🔜MSTM📝 5.2.X 之后，只锁三级缓存，把二级缓存拿到了锁外面，没看出来什么特殊作用，也没有影响，因为线程 1 最终将完整的 bean 加入了一级缓存，并清空了二三级缓存，线程 2 获得锁之后，按一二三级缓存进行查询，先查到一级缓存中有就返回了◼️⭐️-point-202301291741%%</span></p><ol><li>两个地方加了同一把锁，即锁住了一级缓存</li><li>先在创建 bean 的过程中加了锁，具体位置在 <code>doGetBean</code> 中的第二个 <code>getSingleton</code>，即入参为 <code>beanName</code> 和 <code>ObjectFactory&lt;?&gt;</code></li><li><span style="background-color:red">于此同时，相当于也在 getSingleton(beanName, boolean) 中加了锁，因为是同一把对象锁</span> ❕<span style="display:none">%%<br>1538-🏡⭐️◼️Spring 如何防止获取到不完整的 Bean 的🔜MSTM📝 分别在创建 bean(getSingleton(beanName,beanFactory)) 和获取 bean 的 (getSingleton(beanName)) 方法这 2 个地方加了同一个对象锁，使用了一级缓存对象。在创建过程中先进入 getSingleton(beanName)，但是因为判断逻辑没有进入到加锁的地方，第一次加锁是在 getSingleton(beanName,beanFactory)，然后对象锁就生效了，相当于同时在 getSingleton(beanName) 里也加了锁◼️⭐️-point-202301301538%%</span></li></ol><p><span style="background-color:#f0f">只能说太精妙了，2 个锁都是在单例仓库 <code>DefaultSingletonBeanRegistry</code> 中，<code>getSingleton</code> 的 2 个重载的方法里：</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230130144138.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230130144101.png" alt="image.png"></p><h1 id="5-扩展点"><a href="#5-扩展点" class="headerlink" title="5. 扩展点"></a>5. 扩展点</h1><p>^ywsrjj</p><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="Spring-7、扩展点">Spring-7、扩展点</a><h1 id="6-设计模式"><a href="#6-设计模式" class="headerlink" title="6. 设计模式"></a>6. 设计模式</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221213090019.png"></p><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><p>手动集成 Bean 到容器中<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuan882696yan/article/details/99082252">https://blog.csdn.net/yuan882696yan/article/details/99082252</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 装配外部bean（不在spring容器中的bean）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<span class="hljs-string">&quot;C:\\Users\\IdeaProjects\\springDemo\\src\\main\\java\\com\\beanfactory\\autowireCapableBeanFactory\\test.xml&quot;</span>);<br>        <span class="hljs-type">AutowireCapableBeanFactory</span> <span class="hljs-variable">autowireCapableBeanFactory</span> <span class="hljs-operator">=</span> context.getAutowireCapableBeanFactory();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> autowireCapableBeanFactory.autowire(Foo.class, AutowireCapableBeanFactory.AUTOWIRE_BY_NAME, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// Foo没有在test.xml中注册，不受spring容器管制</span><br><span class="hljs-comment">// 通过autowireCapableBeanFactory的方式，依然可以获取到foo，并执行foo里的test方法</span><br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> (Foo) bean;<br>        foo.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><h2 id="8-1-图灵徐庶"><a href="#8-1-图灵徐庶" class="headerlink" title="8.1. 图灵徐庶"></a>8.1. 图灵徐庶</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t44y1C73F/?p=24&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1t44y1C73F/?p=24&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a> 75p</p><p>[[Spring全家桶面试题—图灵徐庶.pdf]]</p><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f5075c763768959e2d109df#map">https://www.processon.com/view/link/5f5075c763768959e2d109df#map</a><br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f1fb2cf1e08533a628a7b4c">https://www.processon.com/view/link/5f1fb2cf1e08533a628a7b4c</a><br>Bean 创建过程： <a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f15341b07912906d9ae8642">https://www.processon.com/view/link/5f15341b07912906d9ae8642</a></p><h2 id="8-2-尚硅谷雷丰阳"><a href="#8-2-尚硅谷雷丰阳" class="headerlink" title="8.2. 尚硅谷雷丰阳"></a>8.2. 尚硅谷雷丰阳</h2><h3 id="8-2-1-配套视频"><a href="#8-2-1-配套视频" class="headerlink" title="8.2.1. 配套视频"></a>8.2.1. 配套视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1gW411W7wy/?spm_id_from=333.337.search-card.all.click</a></p><h3 id="8-2-2-配套代码"><a href="#8-2-2-配套代码" class="headerlink" title="8.2.2. 配套代码"></a>8.2.2. 配套代码</h3><p>spring 注解驱动开发 _spring 源码版 - 雷丰阳 - 尚硅谷<br>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;Spring注解驱动开发-尚硅谷-雷丰阳&#x2F;spring-annotation&#x2F;src&#x2F;main&#x2F;resources&#x2F;SpringSource.txt]]</p><h3 id="8-2-3-配套笔记"><a href="#8-2-3-配套笔记" class="headerlink" title="8.2.3. 配套笔记"></a>8.2.3. 配套笔记</h3><p><a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111413608">https://liayun.blog.csdn.net/article/details/111413608</a></p><h2 id="8-3-马士兵-lianpengju"><a href="#8-3-马士兵-lianpengju" class="headerlink" title="8.3. 马士兵 -lianpengju"></a>8.3. 马士兵 -lianpengju</h2><p>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;lianpengju&#x2F;spring-beans&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springframework&#x2F;beans&#x2F;factory&#x2F;support&#x2F;DefaultSingletonBeanRegistry.java]] ❕<span style="display:none">%%<br>0915-🏡⭐️◼️gradle 配置有问题，测试例子使用的是尚硅谷的 spring-framework：springsource-test◼️⭐️-point-202301290915%%</span></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11B4y1175J?p=6&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV11B4y1175J?p=6&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="8-4-黑马"><a href="#8-4-黑马" class="headerlink" title="8.4. 黑马"></a>8.4. 黑马</h2><h3 id="8-4-1-视频"><a href="#8-4-1-视频" class="headerlink" title="8.4.1. 视频"></a>8.4.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y117RJ?p=196&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y117RJ?p=196&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-4-2-资料"><a href="#8-4-2-资料" class="headerlink" title="8.4.2. 资料"></a>8.4.2. 资料</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/Users/taylor/Nutstore Files/Obsidian_data/pages/002-schdule/001-Arch/001-Subject/011-面试专题/黑马面试题<br></code></pre></td></tr></table></figure><h2 id="8-5-测试-Demo"><a href="#8-5-测试-Demo" class="headerlink" title="8.5. 测试 Demo"></a>8.5. 测试 Demo</h2><p>013-DemoCode&#x2F;spring-framework&#x2F;spring<br>[[AnnotationMainTest.java]]</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/">https://taylorluo.github.io/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/">框架源码专题</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/IOC/">IOC</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/1080" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-6%E3%80%81%E6%95%B4%E5%90%88Mybatis-@MapperScan/"><img class="prev-cover" src="https://picsum.photos/1920/1082" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-Spring-6、整合Mybatis</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/"><img class="next-cover" src="https://picsum.photos/1920/1082" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">框架源码专题-Spring-3、AOP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="框架源码专题-Spring-8、BeanDefinition"><img class="cover" src="https://picsum.photos/1920/1080" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-02</div><div class="title">框架源码专题-Spring-8、BeanDefinition</div></div></a></div><div><a href="/2022/12/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-0%E3%80%81PostProcessor/" title="框架源码专题-Spring-0、PostProcessor"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-13</div><div class="title">框架源码专题-Spring-0、PostProcessor</div></div></a></div><div><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="框架源码专题-Spring-10、"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">框架源码专题-Spring-10、</div></div></a></div><div><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="1"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">1</div></div></a></div><div><a href="/2022/12/08/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-5%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-@EnableTransactionManagement/" title="框架源码专题-Spring-5、声明式事务"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">框架源码专题-Spring-5、声明式事务</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8-API"><span class="toc-text">1. 容器 API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2. 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.1. 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Bean-%E5%AE%9A%E4%B9%89%E6%B3%A8%E5%86%8C"><span class="toc-text">2.1.1. Bean 定义注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-IOC-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.1.2. IOC 容器的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-Bean-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">2.1.3. Bean 初始化及依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-Bean-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.1.4. Bean 的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.2. 生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0"><span class="toc-text">3. 容器刷新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">4. 循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E7%A7%8D%E7%B1%BB%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.1. 循环依赖的种类⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">4.1.1. 属性注入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BE%9D%E8%B5%96"><span class="toc-text">4.1.2. 构造方法依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1.3. 多例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2"><span class="toc-text">4.2. 变更历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%85%B3%E9%97%AD%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">4.2.1. 关闭默认支持循环依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.3. 循环依赖流程⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%90%84%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8A%A0%E5%85%A5%E6%97%B6%E6%9C%BA"><span class="toc-text">4.3.1. 各级缓存的加入时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">4.3.1.1. 一级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-2-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">4.3.1.2. 二级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-3-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">4.3.1.3. 三级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-text">4.4. 循环依赖问题汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E7%BA%A7%E4%BA%8C%E7%BA%A7%E6%98%AF-ConcurrentHashMap"><span class="toc-text">4.4.1. 为什么一级二级是 ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-AOP-%E6%8F%90%E5%89%8D%E4%BB%A3%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">4.5. AOP 提前代理逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E6%AD%A3%E5%B8%B8%E4%BB%A3%E7%90%86"><span class="toc-text">4.5.1. 正常代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%8F%90%E5%89%8D%E4%BB%A3%E7%90%86"><span class="toc-text">4.5.2. 提前代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-getEarlyBeanReference"><span class="toc-text">4.5.2.1. getEarlyBeanReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-%E7%BB%86%E8%8A%82"><span class="toc-text">4.5.2.2. 细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-3-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BD%B1%E5%93%8D%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.5.2.3. 产生的影响⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.5.3. 二级缓存的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">4.5.4. 测试程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Async-%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%8A%A5%E9%94%99%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.6. @Async 导致循环依赖报错⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">4.6.1. 原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">4.6.2. 流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4.6.3. 解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-4-%E5%85%B6%E4%BB%96"><span class="toc-text">4.6.4. 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-BFPP-%E5%AF%BC%E8%87%B4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5"><span class="toc-text">4.7. BFPP 导致自动配置失败</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%A4%9A%E4%BE%8B%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">4.8. 多例的循环依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">4.9. 构造方法的循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-Lazy"><span class="toc-text">4.9.1. @Lazy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-ObjectFactory"><span class="toc-text">4.9.2. ObjectFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-Provider"><span class="toc-text">4.9.3. Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4-Scope"><span class="toc-text">4.9.4. @Scope</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E9%98%B2%E6%AD%A2%E8%8E%B7%E5%8F%96%E5%88%B0%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84-Bean%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.10. 防止获取到不完整的 Bean⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95%E7%82%B9"><span class="toc-text">5. 扩展点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">6. 设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">7. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">8. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%9B%BE%E7%81%B5%E5%BE%90%E5%BA%B6"><span class="toc-text">8.1. 图灵徐庶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%B0%9A%E7%A1%85%E8%B0%B7%E9%9B%B7%E4%B8%B0%E9%98%B3"><span class="toc-text">8.2. 尚硅谷雷丰阳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91"><span class="toc-text">8.2.1. 配套视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E9%85%8D%E5%A5%97%E4%BB%A3%E7%A0%81"><span class="toc-text">8.2.2. 配套代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E9%85%8D%E5%A5%97%E7%AC%94%E8%AE%B0"><span class="toc-text">8.2.3. 配套笔记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E9%A9%AC%E5%A3%AB%E5%85%B5-lianpengju"><span class="toc-text">8.3. 马士兵 -lianpengju</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E9%BB%91%E9%A9%AC"><span class="toc-text">8.4. 黑马</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-%E8%A7%86%E9%A2%91"><span class="toc-text">8.4.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-%E8%B5%84%E6%96%99"><span class="toc-text">8.4.2. 资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E6%B5%8B%E8%AF%95-Demo"><span class="toc-text">8.5. 测试 Demo</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/1080')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>