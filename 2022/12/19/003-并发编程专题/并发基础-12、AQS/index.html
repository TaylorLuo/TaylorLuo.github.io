<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>并发编程专题-基础-12、AQS | Taylor</title><meta name="keywords" content="并发编程专题,关键字,AQS"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 是什么   1.1. 大致结构在 AbstractQueuedSynchronizer 类中，有几个属性和一个双向队列（CLH 队列） AQS 就是并发包下的一个基类 AQS &#x3D; state + CLH 队列 Node &#x3D; waitStatud + Thread 1.2. 涉及锁 1.3. 模板设计模式由子类实现具体方法逻辑  1.4. 类关系图 1.5. 加锁过程 如果"><meta property="og:type" content="article"><meta property="og:title" content="并发编程专题-基础-12、AQS"><meta property="og:url" content="https://taylorluo.github.io/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 是什么   1.1. 大致结构在 AbstractQueuedSynchronizer 类中，有几个属性和一个双向队列（CLH 队列） AQS 就是并发包下的一个基类 AQS &#x3D; state + CLH 队列 Node &#x3D; waitStatud + Thread 1.2. 涉及锁 1.3. 模板设计模式由子类实现具体方法逻辑  1.4. 类关系图 1.5. 加锁过程 如果"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/1084"><meta property="article:published_time" content="2022-12-19T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.681Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="并发编程专题"><meta property="article:tag" content="关键字"><meta property="article:tag" content="AQS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/1084"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发编程专题-基础-12、AQS",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/1084')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发编程专题-基础-12、AQS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-19T16:00:00.000Z" title="发表于 2022-12-20 00:00:00">2022-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.681Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="并发编程专题-基础-12、AQS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107132139.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230603111921.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107132213.png"></p><h2 id="1-1-大致结构"><a href="#1-1-大致结构" class="headerlink" title="1.1. 大致结构"></a>1.1. 大致结构</h2><p>在 AbstractQueuedSynchronizer 类中，有几个属性和一个双向队列（CLH 队列）</p><p>AQS 就是并发包下的一个基类</p><p>AQS &#x3D; state + CLH 队列</p><p>Node &#x3D; waitStatud + Thread<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107132402.png"></p><h2 id="1-2-涉及锁"><a href="#1-2-涉及锁" class="headerlink" title="1.2. 涉及锁"></a>1.2. 涉及锁</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107132510.png"></p><h2 id="1-3-模板设计模式"><a href="#1-3-模板设计模式" class="headerlink" title="1.3. 模板设计模式"></a>1.3. 模板设计模式</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107150343.png"><br>由子类实现具体方法逻辑</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107150420.png"></p><h2 id="1-4-类关系图"><a href="#1-4-类关系图" class="headerlink" title="1.4. 类关系图"></a>1.4. 类关系图</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107133442.png"></p><h2 id="1-5-加锁过程"><a href="#1-5-加锁过程" class="headerlink" title="1.5. 加锁过程"></a>1.5. 加锁过程</h2><ol><li>如果是第一个线程 t1，那么和队列无关，线程直接持有锁。并且也不会初始化队列，如果接下来的线程都是交替执行，那么永远和 AQS 队列无关，都是直接线程持有锁</li><li>如果发生了竞争，比如 t1 持有锁的过程中 t2 来 lock，那么这个时候就会初始化 AQS，初始化 AQS 的时候会在队列的头部虚拟一个 Thread 为 NULL 的 Node，因为队列当中的 head 永远是持有锁的那个 node（除了第一次会虚拟一个，其他时候都是持有锁的那个线程锁封装的 node）</li><li>现在第一次的时候持有锁的是 t1 ，而 t1 不在队列当中所以虚拟了一个 node 节点，队列当中的除了 head 之外的所有的 node 都在 park</li><li>当 t1 释放锁之后 unpark 某个（基本是队列当中的第二个，为什么是第二个呢？前面说过 head 永远是持有锁的那个 node，当有时候也不会是第二个，比如第二个被 cancel 之后，至于为什么会被 cancel，不在我们讨论范围之内，cancel 的条件很苛刻，基本不会发生）node 之后，node 被唤醒，假设 node 是 t2，那么这个时候会首先把 t2 变成 head（sethead）</li><li>在 sethead 方法里面会把 t2 代表的 node 设置为 head，并且把 node 的 Thread 设置为 null，为什么需要设置 null？其实原因很简单，现在 t2 已经拿到锁了，node 就不要排队了，那么 node 对 Thread 的引用就没有意义了。所以队列的 head 里面的 Thread 永远为 null</li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/java_lyvee/article/details/98966684">JUC AQS ReentrantLock源码分析（一）</a></li></ol><h2 id="1-6-解锁过程"><a href="#1-6-解锁过程" class="headerlink" title="1.6. 解锁过程"></a>1.6. 解锁过程</h2><ol><li>调用 unlock()，会调用到 release()，进而调用到 tryRelease(arg)</li><li>tryRelease() 由 Sync 进行实现，其内部对 state 进行减一，完成一次释放锁，如果锁还有其它层未释放，返回 false，然后不做其它操作</li><li>如果锁已经完全释放，即 state&#x3D;0，则将队列中的 head 节点的 waitStatusCAS 地设置为 0， 然后将第二个节点设置为 head 节点，并将其代表的 Thread，unpark 唤醒。该线程获得锁</li><li>如果第二个节点被取消，则从 tail 向前获得一个为被取消的 node 进行 Thread 唤醒。</li></ol><h1 id="2-面试题"><a href="#2-面试题" class="headerlink" title="2. 面试题"></a>2. 面试题</h1><h2 id="2-1-谈谈对-AQS-的理解"><a href="#2-1-谈谈对-AQS-的理解" class="headerlink" title="2.1. 谈谈对 AQS 的理解"></a>2.1. 谈谈对 AQS 的理解</h2><p>AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、 CountDownLatch、Semaphore 等都用到了 AQS. 从本质上来说，AQS 提供了两种锁机制，分别是排它锁，和共享锁。排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重入锁实现就是用到了 AQS 中的排它锁功能。共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如 CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。</p><p>设计 AQS 整个体系需要解决的三个核心的问题：<br>①互斥变量的设计以及多线程同时更新互斥变量时的安全性<br>②未竞争到锁资源的线程的等待以及竞争到锁资源的线程释放锁之后的唤醒<br>③锁竞争的公平性和非公平性。</p><p>AQS 采用了一个 <code>volatile int</code> 类型的互斥变量 <code>state</code> 用来记录锁竞争的一个状态，0 表示当前没有任何线程竞争锁资源，而大于等于 1 表示已经有线程正在持有锁资源。<br>一个线程来获取锁资源的时候，首先判断 state 是否等于 0，如果是 (无锁状态)，则把这个 state 通过 CAS 更新成 1，表示占用到锁。此时如果多个线程进行同样的操作，会造成线程安全问题。AQS 采用了 CAS 机制来保证互斥变量 state 的原子性。<br>未获取到锁资源的线程通过 LockSupport 的 park 方法 (底层是 Unsafe 类的 park 方法) 对线程进行阻塞，把阻塞的线程按照先进先出的原则加入到一个双向链表的结构中，当获得锁资源的线程释放锁之后，会从双向链表的头部去唤醒下一个等待的线程再去竞争锁。<br>另外关于公平性和非公平性问题，AQS 的处理方式是，在竞争锁资源的时候，公平锁需要判断双向链表中是否有阻塞的线程，如果有，则需要去排队等待；而非公平锁的处理方式是，不管双向链表中是否存在等待锁的线程，都会直接尝试更改互斥变量 state 去竞争锁。</p><h2 id="2-2-AQS-为什么要使用双向链表"><a href="#2-2-AQS-为什么要使用双向链表" class="headerlink" title="2.2. AQS 为什么要使用双向链表"></a>2.2. AQS 为什么要使用双向链表</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1br4y1g7Mm?t=208.9">https://www.bilibili.com/video/BV1br4y1g7Mm?t=208.9</a></p><p>加入队列等待时需要判断前驱节点状态<br>竞争锁是需要判断前驱节点是否是头节点<br>需要查找 cancel 的节点</p><h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107132954.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107133056.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107133121.png"></p><h2 id="3-1-重要变量"><a href="#3-1-重要变量" class="headerlink" title="3.1. 重要变量"></a>3.1. 重要变量</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107134050.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107134237.png"></p><h2 id="3-2-lock-gt-A-CAS-成功抢到锁"><a href="#3-2-lock-gt-A-CAS-成功抢到锁" class="headerlink" title="3.2. lock-&gt;A CAS 成功抢到锁"></a>3.2. lock-&gt;A CAS 成功抢到锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">// sync分为了公平和非公平</span><br>    sync.lock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-1-非公平锁"><a href="#3-2-1-非公平锁" class="headerlink" title="3.2.1. 非公平锁"></a>3.2.1. 非公平锁</h3><p>通过 <code>CAS的方式</code> 尝试将 state 从 0 修改为 1，如果返回 true，代表修改成功，如果修改失败，返回 false。将一个属性设置为当前线程，这个属性是 AQS 的父类提供的<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220075540.png"></p><p><span style="background-color:#f0f">A 线程 <code>compareAndSetState(0, 1)</code> 成功</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220075637.png"></p><h3 id="3-2-2-区别"><a href="#3-2-2-区别" class="headerlink" title="3.2.2. 区别"></a>3.2.2. 区别</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220072922.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107151037.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107151146.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220073037.png"></p><h2 id="3-3-acquire"><a href="#3-3-acquire" class="headerlink" title="3.3. acquire"></a>3.3. acquire</h2><p>有 3 个判断方法：tryAcquire、acquireQueued、selfInterrupt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>	<span class="hljs-comment">// tryAcquire再次尝试获取锁资源，如果尝试成功，返回true</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>		<span class="hljs-comment">// 获取锁资源失败后，需要将当前线程封装成一个Node，追加到AQS的队列中</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>		<span class="hljs-comment">// 线程中断</span><br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-1-tryAcquire"><a href="#3-3-1-tryAcquire" class="headerlink" title="3.3.1. tryAcquire"></a>3.3.1. tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>	<span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>	<span class="hljs-comment">// 获取AQS的state的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>	<span class="hljs-comment">// 如果state为0，代表，尝试再次获取锁资源</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">// CAS尝试修改state，从0-1，如果成功，设置ExclusiveOwnerThread属性为当前线程</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">// 当前占有锁资源的线程是否是当前线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>		<span class="hljs-comment">// 将state + 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>		<span class="hljs-comment">// 如果加1后，小于0，超所锁可重入的最大值，抛出Error</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>		<span class="hljs-comment">// 没问题，就重新对state进行复制</span><br>        setState(nextc);<br>		<span class="hljs-comment">// 锁重入成功</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-1-nonfairTryAcquire-gt-B-抢占失败"><a href="#3-3-1-1-nonfairTryAcquire-gt-B-抢占失败" class="headerlink" title="3.3.1.1. nonfairTryAcquire-&gt;B 抢占失败"></a>3.3.1.1. nonfairTryAcquire-&gt;B 抢占失败</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220080937.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220101550.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107160811.png"></p><p><span style="background-color:#f0f">B 线程进入 nonfairTryAcquire() 方法，返回 false</span>，取反后为 true，判断&amp;&amp;后面的条件，从而进入 <code>addWaiter</code> 方法</p><h3 id="3-3-2-addWaiter-gt-B-节点参与竞争抢占失败"><a href="#3-3-2-addWaiter-gt-B-节点参与竞争抢占失败" class="headerlink" title="3.3.2. addWaiter-&gt;B 节点参与竞争抢占失败"></a>3.3.2. addWaiter-&gt;B 节点参与竞争抢占失败</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 说明前面获取锁资源失败，放到队列中等待。。。</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>	<span class="hljs-comment">// 创建Node类，并且设置thread为当前线程，设置为排它锁</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>  	<span class="hljs-comment">// 获取AQS中队列的尾部节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>	<span class="hljs-comment">// 如果tail != null，现在队列有人排队</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-comment">// 将当前节点的prev，设置为刚才的尾部节点</span><br>        node.prev = pred;<br>		<span class="hljs-comment">// 基于CAS的方式，将tail节点设置为当前节点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>			<span class="hljs-comment">// 将之前的为节点的next，设置为当前节点</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">// 查看下面~</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">//-------------------------------</span><br><span class="hljs-comment">// 现在没人排队，我是第一个~~，  如果前面CAS失败，也会进到这个位置重新往队列尾巴塞。</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>	<span class="hljs-comment">// 死循环~~</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>		<span class="hljs-comment">// 重新获取当前的tail节点为t</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <br>			<span class="hljs-comment">// 现在没人排队, 我是第一个，没头没尾，都是空</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))	<span class="hljs-comment">// 初始化一个Node作为head，而这个head没有意义。</span><br>				<span class="hljs-comment">// 将头尾都指向了这个初始化的Node</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// 有人排队，往队列尾巴塞</span><br>			<span class="hljs-comment">// 当前节点的上一个指向tail。</span><br>            node.prev = t;<br>			<span class="hljs-comment">// 基于CAS的方式，将tail节点设置为当前节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;   <br>				<span class="hljs-comment">// 将之前的为节点的next，设置为当前节点</span><br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-1-B-第一个等待-enq"><a href="#3-3-2-1-B-第一个等待-enq" class="headerlink" title="3.3.2.1. B 第一个等待 enq"></a>3.3.2.1. B 第一个等待 enq</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220081933.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220085632.png"></p><h4 id="3-3-2-2-死循环先生成-1-个占位节点"><a href="#3-3-2-2-死循环先生成-1-个占位节点" class="headerlink" title="3.3.2.2. 死循环先生成 1 个占位节点"></a>3.3.2.2. 死循环先生成 1 个占位节点</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220082550.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220082621.png"></p><h4 id="3-3-2-3-第二次循环-B-节点入队"><a href="#3-3-2-3-第二次循环-B-节点入队" class="headerlink" title="3.3.2.3. 第二次循环 B 节点入队"></a>3.3.2.3. 第二次循环 B 节点入队</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220082852.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220083010.png"></p><h4 id="3-3-2-4-其他节点类似-C-节点入队"><a href="#3-3-2-4-其他节点类似-C-节点入队" class="headerlink" title="3.3.2.4. 其他节点类似 C 节点入队"></a>3.3.2.4. 其他节点类似 C 节点入队</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220085948.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220090333.png"></p><h3 id="3-3-3-acquireQueued-gt-处理队列中的节点"><a href="#3-3-3-acquireQueued-gt-处理队列中的节点" class="headerlink" title="3.3.3. acquireQueued-&gt;处理队列中的节点"></a>3.3.3. acquireQueued-&gt;处理队列中的节点</h3><p>第二个死循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已经将node加入到了双向队列中，然后执行当前方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>	<span class="hljs-comment">// 标识！！！！</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-comment">// 标识！！！！</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>			<span class="hljs-comment">// 获取当前节点的上一个节点p</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>			<span class="hljs-comment">// 如果p是头，再次尝试获取锁资源（state从0-1，锁重入操作），成功返回true，失败返回false</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>				<span class="hljs-comment">// 拿到锁资源设置head节点为当前节点，将thread，prev设置为null，因为拿到锁资源了，排队跟我没关系</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// 帮助GC回收</span><br>                failed = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 将标识修改为false</span><br>                <span class="hljs-keyword">return</span> interrupted;  <span class="hljs-comment">// 返回interrupted </span><br>            &#125;<br>			<span class="hljs-comment">// 保证上一个节点是-1，才会返回true，才会将线程阻塞，等待唤醒获取锁资源</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>				<span class="hljs-comment">// 基于Unsafe类的park方法，挂起线程~~~</span><br>                parkAndCheckInterrupt())    <span class="hljs-comment">// 针对fail属性，这里是唯一可能出现异常的地方，JVM内部出现问题时，可以这么理解，fianlly代码块中的内容，执行的几率约等于0~</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-1-tryAcquire"><a href="#3-3-3-1-tryAcquire" class="headerlink" title="3.3.3.1. tryAcquire"></a>3.3.3.1. tryAcquire</h4><p><code>acquireQueued</code> 方法处理队列，因为 B 在队头，所以先处理 B。如果 p 是占位节点，继续&amp;&amp;后面的判断，即<span style="background-color:#f0f">B 线程会执行 tryAcquire，再次进行尝试</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220103100.png"></p><p>predecessor 返回前驱节点，如果前驱节点为 null，抛出 NPE</p><p><span style="background-color:#f0f">B 节点 tryAcquire，再次尝试仍然失败，进入下面 if 判断中的 shouldParkAfterFailedAcquire 方法</span></p><h4 id="3-3-3-2-shouldParkAfterFailedAcquire"><a href="#3-3-3-2-shouldParkAfterFailedAcquire" class="headerlink" title="3.3.3.2. shouldParkAfterFailedAcquire"></a>3.3.3.2. shouldParkAfterFailedAcquire</h4><h5 id="3-3-3-2-1-第-1-次循环-gt-将前面节点-waitStatus-置为-1"><a href="#3-3-3-2-1-第-1-次循环-gt-将前面节点-waitStatus-置为-1" class="headerlink" title="3.3.3.2.1. 第 1 次循环 -&gt;将前面节点 waitStatus 置为 -1"></a>3.3.3.2.1. 第 1 次循环 -&gt;将前面节点 waitStatus 置为 -1</h5><p>队头第一个线程节点 B 再次尝试失败时进入 <code>shouldParkAfterFailedAcquire</code> 方法<br>自旋进入第 1 次循环时，会走最下面的分支，将<span style="background-color:#0f0">占位节点</span>的 <code>waitStatus</code> 改为 -1<br>compareAndSetWaitStatus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// node是当前节点，pred是上一个节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>	<span class="hljs-comment">// 获取上一个节点的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>	<span class="hljs-comment">// 如果上一个节点状态为SIGNAL，一切正常！</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-comment">// 如果上一个节点已经失效了</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>			<span class="hljs-comment">// 将当前节点的prev指针指向了上一个的上一个！</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// 一致找到小于等于0的</span><br>		<span class="hljs-comment">// 将重新标识好的最近的有效节点的next</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 小于等于0，不等于-1，将上一个有效节点状态修改为-1</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220105351.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220105429.png"></p><h5 id="3-3-3-2-2-第-2-次循环-gt-B-park-住"><a href="#3-3-3-2-2-第-2-次循环-gt-B-park-住" class="headerlink" title="3.3.3.2.2. 第 2 次循环 -&gt;B park 住"></a>3.3.3.2.2. 第 2 次循环 -&gt;B park 住</h5><p>自旋进入第 2 次循环时，<code>shouldParkAfterFailedAcquire</code> 中的 if 判断 <code>ws == Node.SIGNAL</code> 返回 ture，继续进行 acquireQueued 方法中第 2 个 if 判断中的 <code>parkAndCheckInterrupt()</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220105715.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220105614.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220105851.png"></p><h4 id="3-3-3-3-parkAndCheckInterrupt-gt-park-B-节点"><a href="#3-3-3-3-parkAndCheckInterrupt-gt-park-B-节点" class="headerlink" title="3.3.3.3. parkAndCheckInterrupt-&gt;park B 节点"></a>3.3.3.3. parkAndCheckInterrupt-&gt;park B 节点</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220110118.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220101905.png"></p><h4 id="3-3-3-4-C-节点重复-shouldParkAfterFailedAcquire-中的循环"><a href="#3-3-3-4-C-节点重复-shouldParkAfterFailedAcquire-中的循环" class="headerlink" title="3.3.3.4. C 节点重复 shouldParkAfterFailedAcquire 中的循环"></a>3.3.3.4. C 节点重复 shouldParkAfterFailedAcquire 中的循环</h4><p><span style="background-color:#0f0">第 1 次循环，将其前面的 B 节点的 waitStatus 置为 -1</span> <span style="background-color:#f0f">（规律就是后面节点将前面节点的 waitStatus 置为 -1，表示已就绪）</span><br><span style="background-color:#0f0">第 2 次循环，执行 parkAndCheckInterrupt，将自己 park 住</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107174849.png"></p><p>被 park 后，线程 B、C 等都进入 <code>WATING</code> 状态，等待被唤醒</p><p>线程状态复习：<a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发基础-7、Thread">并发基础-7、Thread</a></p><h2 id="3-4-unlock"><a href="#3-4-unlock" class="headerlink" title="3.4. unlock"></a>3.4. unlock</h2><p>release(1)</p><h2 id="3-5-release"><a href="#3-5-release" class="headerlink" title="3.5. release"></a>3.5. release</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107182307.png"></p><h3 id="3-5-1-tryRelease-gt-返回-true"><a href="#3-5-1-tryRelease-gt-返回-true" class="headerlink" title="3.5.1. tryRelease-&gt;返回 true"></a>3.5.1. tryRelease-&gt;返回 true</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220112725.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220112845.png"></p><h3 id="3-5-2-unparkSuccessor"><a href="#3-5-2-unparkSuccessor" class="headerlink" title="3.5.2. unparkSuccessor"></a>3.5.2. unparkSuccessor</h3><h4 id="3-5-2-1-compareAndSetWaitStatus"><a href="#3-5-2-1-compareAndSetWaitStatus" class="headerlink" title="3.5.2.1. compareAndSetWaitStatus"></a>3.5.2.1. compareAndSetWaitStatus</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107182938.png"></p><h4 id="3-5-2-2-unpark"><a href="#3-5-2-2-unpark" class="headerlink" title="3.5.2.2. unpark"></a>3.5.2.2. unpark</h4><p>unpark 就会唤醒上面 parkAndCheckInterrupt 中 park 的线程，线程 B 被唤醒后，<code>从parkAndCheckInterrupt</code> 方法中的 837 行继续执行，出来后在自旋中继续循环</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107183229.png"></p><p>假设没有线程中断的特殊情况，B 节点出来 parkAndCheckInterrupt 方法之后，还在 acquireQueued 方法的死循环中继续循环。此时 node 是 B 节点，那么 p 就是占位节点，进入 if 判断中，<code>p==head</code> 为 true，继续&amp;&amp;后面的 tryAcquire 方法</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107184607.png"></p><h5 id="3-5-2-2-1-B-在-tryAcquire-方法中-CAS-成功抢到锁"><a href="#3-5-2-2-1-B-在-tryAcquire-方法中-CAS-成功抢到锁" class="headerlink" title="3.5.2.2.1. B 在 tryAcquire 方法中 CAS 成功抢到锁"></a>3.5.2.2.1. B 在 tryAcquire 方法中 CAS 成功抢到锁</h5><p>state 变为 1，占有窗口的 Thread 变为 Thread B<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220132848.png"></p><p>将节点 B 设置为 head，占位节点的 next 置为 null<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220132951.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230107185011.png"></p><p><span style="background-color:#f0f">也就是将原来的占位节点出队，B 变为新的占位节点</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220133021.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220133102.png"></p><h2 id="3-6-selfInterrupt"><a href="#3-6-selfInterrupt" class="headerlink" title="3.6. selfInterrupt"></a>3.6. selfInterrupt</h2><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这里简单分析一下：</p><p>因为 LockSupport.park 阻塞线程后，有两种可能被唤醒。</p><p><strong>第一种情况</strong>，前节点是头节点，释放锁后，会调用 LockSupport.unpark 唤醒当前线程。整个过程没有涉及到中断，最终 acquireQueued 返回 false 时，不需要调用 selfInterrupt。</p><p><strong>第二种情况</strong>，LockSupport.park 支持响应中断请求，能够被其他线程通过 interrupt() 唤醒。但这种唤醒并没有用，因为线程前面可能还有等待线程，在 acquireQueued 的循环里，线程会再次被阻塞。parkAndCheckInterrupt 返回的是 Thread.interrupted()，不仅返回中断状态，还会清除中断状态，保证阻塞线程忽略中断。最终 acquireQueued 返回 true 时，真正的中断状态已经被清除，需要调用 selfInterrupt 维持中断状态，即要进行“中断补偿”操作。</p><p>优雅退出线程中，也有设计中断补偿：<a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发基础-7、Thread">并发基础-7、Thread</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221220170534.png"></p><h1 id="4-实战经验"><a href="#4-实战经验" class="headerlink" title="4. 实战经验"></a>4. 实战经验</h1><h1 id="5-参考与感谢"><a href="#5-参考与感谢" class="headerlink" title="5. 参考与感谢"></a>5. 参考与感谢</h1><h2 id="5-1-尚硅谷周阳"><a href="#5-1-尚硅谷周阳" class="headerlink" title="5.1. 尚硅谷周阳"></a>5.1. 尚硅谷周阳</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uX4y1u7ht">https://www.bilibili.com/video/BV1uX4y1u7ht</a></p><h2 id="5-2-测试程序"><a href="#5-2-测试程序" class="headerlink" title="5.2. 测试程序"></a>5.2. 测试程序</h2><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;juc-day02<br>[[ReentrantLock3.java]]<br>[[AQSDemo.java]]<br>selfInterrupt：[[Java 并发之 AQS 详解（下） HeapDump性能社区]]</p><h2 id="5-3-整体流程图"><a href="#5-3-整体流程图" class="headerlink" title="5.3. 整体流程图"></a>5.3. 整体流程图</h2><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/5e29b0e8e4b04579e40c15a7?fromnew=1">https://www.processon.com/view/5e29b0e8e4b04579e40c15a7?fromnew=1</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/">https://taylorluo.github.io/2022/12/19/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-12%E3%80%81AQS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/">并发编程专题</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E9%94%AE%E5%AD%97/">关键字</a><a class="post-meta__tags" href="/tags/AQS/">AQS</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/1084" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/21/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E7%BC%93%E5%AD%98-Redis-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="https://picsum.photos/1920/982" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-Redis-1、基本原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-0%E3%80%81PostProcessor/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">框架源码专题-Spring-0、PostProcessor</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/10/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-6%E3%80%81CAS/" title="并发编程专题-基础-6、CAS"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">并发编程专题-基础-6、CAS</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-7%E3%80%81Thread/" title="并发编程专题-基础-7、Thread"><img class="cover" src="https://picsum.photos/1920/912" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-7、Thread</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-4、信号量与管程"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-4、信号量与管程</div></div></a></div><div><a href="/2022/11/09/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-5%E3%80%81%E8%BF%9B%E7%A8%8B%20%E7%BA%BF%E7%A8%8B%20%E7%BA%A4%E7%A8%8B%20%E5%8D%8F%E7%A8%8B%20%E7%AE%A1%E7%A8%8B/" title="并发编程专题-基础-5、进程 线程 纤程 协程 管程"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-10</div><div class="title">并发编程专题-基础-5、进程 线程 纤程 协程 管程</div></div></a></div><div><a href="/2022/11/08/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-1%E3%80%81JMM%E4%B8%8EMESI/" title="并发编程专题-基础-1、JMM与MESI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-09</div><div class="title">并发编程专题-基础-1、JMM与MESI</div></div></a></div><div><a href="/2022/11/12/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-9%E3%80%81Java%E5%90%84%E7%A7%8D%E9%94%81/" title="并发编程专题-基础-9、Java各种锁"><img class="cover" src="https://picsum.photos/1920/1085" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">并发编程专题-基础-9、Java各种锁</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1. 是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%A4%A7%E8%87%B4%E7%BB%93%E6%9E%84"><span class="toc-text">1.1. 大致结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B6%89%E5%8F%8A%E9%94%81"><span class="toc-text">1.2. 涉及锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3. 模板设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">1.4. 类关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">1.5. 加锁过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">1.6. 解锁过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2. 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%B0%88%E8%B0%88%E5%AF%B9-AQS-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2.1. 谈谈对 AQS 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-AQS-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">2.2. AQS 为什么要使用双向链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">3. 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%87%8D%E8%A6%81%E5%8F%98%E9%87%8F"><span class="toc-text">3.1. 重要变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-lock-gt-A-CAS-%E6%88%90%E5%8A%9F%E6%8A%A2%E5%88%B0%E9%94%81"><span class="toc-text">3.2. lock-&gt;A CAS 成功抢到锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">3.2.1. 非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%8C%BA%E5%88%AB"><span class="toc-text">3.2.2. 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-acquire"><span class="toc-text">3.3. acquire</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-tryAcquire"><span class="toc-text">3.3.1. tryAcquire</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-nonfairTryAcquire-gt-B-%E6%8A%A2%E5%8D%A0%E5%A4%B1%E8%B4%A5"><span class="toc-text">3.3.1.1. nonfairTryAcquire-&gt;B 抢占失败</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-addWaiter-gt-B-%E8%8A%82%E7%82%B9%E5%8F%82%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%8A%A2%E5%8D%A0%E5%A4%B1%E8%B4%A5"><span class="toc-text">3.3.2. addWaiter-&gt;B 节点参与竞争抢占失败</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-B-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AD%89%E5%BE%85-enq"><span class="toc-text">3.3.2.1. B 第一个等待 enq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%85%88%E7%94%9F%E6%88%90-1-%E4%B8%AA%E5%8D%A0%E4%BD%8D%E8%8A%82%E7%82%B9"><span class="toc-text">3.3.2.2. 死循环先生成 1 个占位节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF-B-%E8%8A%82%E7%82%B9%E5%85%A5%E9%98%9F"><span class="toc-text">3.3.2.3. 第二次循环 B 节点入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-4-%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9%E7%B1%BB%E4%BC%BC-C-%E8%8A%82%E7%82%B9%E5%85%A5%E9%98%9F"><span class="toc-text">3.3.2.4. 其他节点类似 C 节点入队</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-acquireQueued-gt-%E5%A4%84%E7%90%86%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">3.3.3. acquireQueued-&gt;处理队列中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-1-tryAcquire"><span class="toc-text">3.3.3.1. tryAcquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-2-shouldParkAfterFailedAcquire"><span class="toc-text">3.3.3.2. shouldParkAfterFailedAcquire</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-2-1-%E7%AC%AC-1-%E6%AC%A1%E5%BE%AA%E7%8E%AF-gt-%E5%B0%86%E5%89%8D%E9%9D%A2%E8%8A%82%E7%82%B9-waitStatus-%E7%BD%AE%E4%B8%BA-1"><span class="toc-text">3.3.3.2.1. 第 1 次循环 -&gt;将前面节点 waitStatus 置为 -1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-2-2-%E7%AC%AC-2-%E6%AC%A1%E5%BE%AA%E7%8E%AF-gt-B-park-%E4%BD%8F"><span class="toc-text">3.3.3.2.2. 第 2 次循环 -&gt;B park 住</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-3-parkAndCheckInterrupt-gt-park-B-%E8%8A%82%E7%82%B9"><span class="toc-text">3.3.3.3. parkAndCheckInterrupt-&gt;park B 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-4-C-%E8%8A%82%E7%82%B9%E9%87%8D%E5%A4%8D-shouldParkAfterFailedAcquire-%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.3.3.4. C 节点重复 shouldParkAfterFailedAcquire 中的循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-unlock"><span class="toc-text">3.4. unlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-release"><span class="toc-text">3.5. release</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-tryRelease-gt-%E8%BF%94%E5%9B%9E-true"><span class="toc-text">3.5.1. tryRelease-&gt;返回 true</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-unparkSuccessor"><span class="toc-text">3.5.2. unparkSuccessor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-1-compareAndSetWaitStatus"><span class="toc-text">3.5.2.1. compareAndSetWaitStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-2-unpark"><span class="toc-text">3.5.2.2. unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-2-2-1-B-%E5%9C%A8-tryAcquire-%E6%96%B9%E6%B3%95%E4%B8%AD-CAS-%E6%88%90%E5%8A%9F%E6%8A%A2%E5%88%B0%E9%94%81"><span class="toc-text">3.5.2.2.1. B 在 tryAcquire 方法中 CAS 成功抢到锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-selfInterrupt"><span class="toc-text">3.6. selfInterrupt</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">4. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">5. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%91%A8%E9%98%B3"><span class="toc-text">5.1. 尚硅谷周阳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">5.2. 测试程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">5.3. 整体流程图</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/1084')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>