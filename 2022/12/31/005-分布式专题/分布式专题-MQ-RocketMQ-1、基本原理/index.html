<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>框架源码专题-RocketMQ-1、基本原理 | Taylor</title><meta name="keywords" content="RocketMQ,MQ"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 历史 Kafka：一个 topic 中每个 Queue 都是一个单独的文件，所有消息都存在其中RocketMQ：所有 topic 所有 Queue 的消息都放在一种文件中，即 CommitLog，默认大小为 1G。但又为每个 topic 创建一个目录，然后为每个 Queue 创建一个文件，即 ConsumeQueue，用来存储索引信息。存储使用 CommitLog，查询使用 ConsumeQ"><meta property="og:type" content="article"><meta property="og:title" content="框架源码专题-RocketMQ-1、基本原理"><meta property="og:url" content="https://taylorluo.github.io/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 历史 Kafka：一个 topic 中每个 Queue 都是一个单独的文件，所有消息都存在其中RocketMQ：所有 topic 所有 Queue 的消息都放在一种文件中，即 CommitLog，默认大小为 1G。但又为每个 topic 创建一个目录，然后为每个 Queue 创建一个文件，即 ConsumeQueue，用来存储索引信息。存储使用 CommitLog，查询使用 ConsumeQ"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/912"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.692Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="RocketMQ"><meta property="article:tag" content="MQ"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/912"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"框架源码专题-RocketMQ-1、基本原理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/912')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">框架源码专题-RocketMQ-1、基本原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.692Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MQ/">MQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="框架源码专题-RocketMQ-1、基本原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a>1. 历史</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404090718.png" alt="image.png"></p><p>Kafka：<span style="background-color:#f0f">一个 topic 中每个 Queue 都是一个单独的文件</span>，所有消息都存在其中<br>RocketMQ：所有 topic 所有 Queue 的消息都放在一种文件中，即 CommitLog，默认大小为 1G。但又为每个 topic 创建一个目录，然后为每个 Queue 创建一个文件，即 ConsumeQueue，用来存储索引信息。存储使用 CommitLog，查询使用 ConsumeQueue。实现了读写分离。</p><h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><h2 id="2-1-消息（Message）"><a href="#2-1-消息（Message）" class="headerlink" title="2.1. 消息（Message）"></a>2.1. 消息（Message）</h2><p>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p><h2 id="2-2-主题（Topic）-消费者-消费者组"><a href="#2-2-主题（Topic）-消费者-消费者组" class="headerlink" title="2.2. 主题（Topic）- 消费者 - 消费者组"></a>2.2. 主题（Topic）- 消费者 - 消费者组</h2><p>Topic 表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。 topic:message 1:n <span style="background-color:#0f0">message : topic 1:1</span><br>一个生产者可以同时发送多种 Topic 的消息；而<span style="background-color:#f0f">一个消费者</span>只对某种特定的 Topic 感兴趣，即<span style="background-color:#f0f">只可以订阅和消费一种 Topic 的消息</span>。 producer:topic 1:n <span style="background-color:#0f0">consumer:topic 1:1</span></p><h2 id="2-3-队列（Queue）-同消费组只能-1-个消费者"><a href="#2-3-队列（Queue）-同消费组只能-1-个消费者" class="headerlink" title="2.3. 队列（Queue）- 同消费组只能 1 个消费者"></a>2.3. 队列（Queue）- 同消费组只能 1 个消费者</h2><p>存储消息的物理实体。一个 Topic 中可以包含多个 Queue，每个 Queue 中存放的就是该 Topic 的消息。一个 Topic 的 Queue 也被称为一个 Topic 中消息的分区（Partition）。<br><span style="background-color:#ff0">一个 Topic 的 Queue 中的消息只能被一个消费者组中的一个消费者消费</span>。<span style="background-color:#f0f">一个 Queue 中的消息不允许同一个消费者组中的多个消费者同时消费。</span></p><p>在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在 RocketMQ 中，分片指的是存放相应 Topic 的 Broker。每个分片中会创建出相应数量的分区，即 Queue，每个 Queue 的大小都是相同的。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230103213426.png"></p><h2 id="2-4-消息标识（MessageId-x2F-Key）"><a href="#2-4-消息标识（MessageId-x2F-Key）" class="headerlink" title="2.4. 消息标识（MessageId&#x2F;Key）"></a>2.4. 消息标识（MessageId&#x2F;Key）</h2><p>RocketMQ 中每个消息拥有唯一的 MessageId，且可以携带具有业务标识的 Key，以方便对消息的查询。<br><span style="background-color:#0f0">不过需要注意的是，MessageId 有两个</span>：<span style="background-color:#ff0">在生产者 send() 消息时会自动生成一个 MessageId</span>（msgId)，<span style="background-color:#ff0">当消息到达 Broker 后，Broker 也会自动生成一个 MessageId(offsetMsgId)</span>。msgId、offsetMsgId 与 key 都称为消息标识。<br><strong>msgId</strong>：由 producer 端生成，其生成规则为：<br>&#x3D;&#x3D;producerIp + 进程 pid + MessageClientIDSetter 类的 ClassLoader 的 hashCode + 当前时间 + AutomicInteger 自增计数器&#x3D;&#x3D;<br><strong>offsetMsgId</strong>：由 broker 端生成，其生成规则为：&#x3D;&#x3D;brokerIp + 物理分区的 offset（Queue 中的偏移量）&#x3D;&#x3D;<br><strong>key</strong>：由用户指定的业务相关的唯一标识</p><h1 id="3-系统组成"><a href="#3-系统组成" class="headerlink" title="3. 系统组成"></a>3. 系统组成</h1><h2 id="3-1-Producer"><a href="#3-1-Producer" class="headerlink" title="3.1. Producer"></a>3.1. Producer</h2><p>消息生产者，负责生产消息。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。<br>例如，业务系统产生的日志写入到 MQ 的过程，就是消息生产的过程。再如，电商平台中用户提交的秒杀请求写入到 MQ 的过程，就是消息生产的过程</p><h2 id="3-2-Consumer"><a href="#3-2-Consumer" class="headerlink" title="3.2. Consumer"></a>3.2. Consumer</h2><p>RocketMQ 中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类 Consumer 消费的是同一个 Topic 类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个 Topic 中的不同的 Queue 平均分配给同一个 Consumer Group 的不同的 Consumer，注意，并不是将消息负载均衡）和容错（一个 Consmer 挂了，该 Consumer Group 中的其它 Consumer 可以接着消费原 Consumer 消费的 Queue）的目标变得非常容易。<br><span style="background-color:#0f0">消费者组中 Consumer 的数量应该小于等于订阅 Topic 的 Queue 数量。如果超出 Queue 数量，则多出的 Consumer 将不能消费消息。</span></p><p>不过，<span style="background-color:#f0f">一个 Topic 类型的消息可以被多个消费者组同时消费</span>。<br><strong>注意</strong><br><span style="background-color:#ff0">1）消费者组只能消费一个 Topic 的消息，不能同时消费多个 Topic 消息</span><br><span style="background-color:#ff0">2）一个消费者组中的消费者必须订阅完全相同的 Topic</span></p><h2 id="3-3-Broker"><a href="#3-3-Broker" class="headerlink" title="3.3. Broker"></a>3.3. Broker</h2><h3 id="3-3-1-功能介绍"><a href="#3-3-1-功能介绍" class="headerlink" title="3.3.1. 功能介绍"></a>3.3.1. 功能介绍</h3><p>Broker 充当着消息中转角色，<span style="background-color:#0f0">负责存储消息、转发消息</span>。Broker 在 RocketMQ 系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker 同时也存储着消息相关的元数据，<span style="background-color:#0f0">包括消费者组消费进度偏移 offset、主题、队列等</span>。</p><h3 id="3-3-2-模块构成"><a href="#3-3-2-模块构成" class="headerlink" title="3.3.2. 模块构成"></a>3.3.2. 模块构成</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104084614.png"><br><strong>Remoting Module</strong>：整个 Broker 的实体，负责处理来自 clients 端的请求。而这个 Broker 实体则由以下模块构成。<br><strong>Client Manager</strong>：客户端管理器。负责接收、解析客户端 (Producer&#x2F;Consumer) 请求，管理客户端。例如，维护 Consumer 的 Topic 订阅信息<br><strong>Store Service</strong>：存储服务。提供方便简单的 API 接口，处理消息存储到物理硬盘和消息查询功能。<br><strong>HA Service</strong>：高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。<br><strong>Index Service</strong>：索引服务。根据特定的 Message key，对投递到 Broker 的消息进行索引服务，同时也提供根据 Message Key 对消息进行快速查询的功能。</p><h3 id="3-3-3-集群部署"><a href="#3-3-3-集群部署" class="headerlink" title="3.3.3. 集群部署"></a>3.3.3. 集群部署</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104084837.png"></p><p>为了增强 Broker 性能与吞吐量，Broker 一般都是以集群形式出现的。各集群节点中可能存放着<span style="background-color:#f0f">相同 Topic 的不同 Queue，即所有主 Broker 分摊所有 Topic 的所有 messageQueue</span>。<br>不过，这里有个问题，如果某 Broker 节点宕机，如何保证数据不丢失呢？其解决<br>方案是，<span style="background-color:#f0f">将每个 Broker 集群节点进行横向扩展，即将 Broker 节点再建为一个 HA 集群，解决单点问题。</span><br><span style="background-color:#0f0">Broker 节点集群是一个主从集群，即集群中具有 Master 与 Slave 两种角色。Master 负责处理读写操作请求，Slave 负责对 Master 中的数据进行备份。当 Master 挂掉了，Slave 则会自动切换为 Master 去工作。所以这个 Broker 集群是<font color="#ff0000">主备集群</font>。</span>一个 Master 可以包含多个 Slave，但一个 Slave 只能隶属于一个 Master。 Master 与 Slave 的对应关系是通过<span style="background-color:#f0f">指定相同的 BrokerName、不同的 BrokerId 来确定的</span>。BrokerId 为 0 表 示 Master，非 0 表示 Slave。每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer。</p><h2 id="3-4-NameServer"><a href="#3-4-NameServer" class="headerlink" title="3.4. NameServer"></a>3.4. NameServer</h2><p>NameServer 是一个 <strong>Broker 与 Topic 路由的注册中心</strong>，支持 Broker 的动态注册与发现。<br>RocketMQ 的思想来自于 Kafka，而 Kafka 是依赖了 Zookeeper 的。所以，在 RocketMQ 的早期版本，即在 MetaQ v1.0 与 v2.0 版本中，也是依赖于 Zookeeper 的。从 MetaQ v3.0，即 RocketMQ 开始<span style="background-color:#ff0">去掉了 Zookeeper 依赖</span>，<span style="background-color:#0f0">使用了自己的 NameServer</span>。</p><p>主要包括两个功能：<br><strong>Broker 管理</strong>：接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据；<span style="background-color:#0f0">提供心跳检测机制</span>，检查 Broker 是否还存活。<br><strong>路由信息管理</strong>：每个 NameServer 中都保存着 Broker 集群的整个路由信息和用于客户端查询的队列信息。<span style="background-color:#0f0">Producer 和 Conumser 通过 NameServer 可以获取整个 Broker 集群的路由信息，从而进行消息的投递和消费</span>。</p><h3 id="3-4-1-路由注册"><a href="#3-4-1-路由注册" class="headerlink" title="3.4.1. 路由注册"></a>3.4.1. 路由注册</h3><p>NameServer 通常也是以集群的方式部署，不过，NameServer 是<span style="background-color:#0f0">无状态的</span>，即 NameServer 集群中的各个节点间是无差异的，<span style="background-color:#f0f">各节点间相互不进行信息通讯</span>。那各节点中的数据是如何进行数据同步的呢？<font color="#ff0000">在 Broker 节点启动时，轮询 NameServer 列表，与<span style="background-color:#0f0">每个 NameServer 节点</span>建立长连接，发起注册请求。在 NameServer 内部维护着⼀个 Broker 列表，用来动态存储 Broker 的信息。</font></p><blockquote><p>注意，这是与其它像 zk、Eureka、Nacos 等注册中心不同的地方。<br>这种 NameServer 的无状态方式，有什么优缺点：<br>优点：NameServer 集群搭建简单，扩容简单。<br>缺点：对于 Broker，<span style="background-color:#ff0">必须明确指出所有 NameServer 地址</span>。否则未指出的将不会去注册。也正因为如此，NameServer 并不能随便扩容。因为，若 Broker 不重新配置，新增的 NameServer 对于 Broker 来说是不可见的，其不会向这个 NameServer 进行注册。</p></blockquote><p>Broker 节点为了证明自己是活着的，为了维护与 NameServer 间的长连接，会将最新的信息以心跳包的方式上报给 NameServer，<span style="background-color:#0f0">每 30 秒发送一次心跳</span>。<span style="background-color:#f0f">心跳包中包含 BrokerId、Broker 地址 (IP+Port)、 Broker 名称、Broker 所属集群名称等等</span>。NameServer 在接收到心跳包后，会更新心跳时间戳，记录这个 Broker 的最新存活时间。</p><h3 id="3-4-2-路由剔除"><a href="#3-4-2-路由剔除" class="headerlink" title="3.4.2. 路由剔除"></a>3.4.2. 路由剔除</h3><p>NameServer 中有⼀个定时任务，<span style="background-color:#0f0">每隔 10 秒</span>就会扫描⼀次 Broker 表，查看每一个 Broker 的最新心跳时间戳距离当前时间<span style="background-color:#ff0">是否超过 120 秒</span>，如果超过，则会判定 Broker 失效，然后将其从 Broker 列表中剔除。<br>扩展：对于 RocketMQ 日常运维工作，例如 Broker 升级，需要停掉 Broker 的工作。OP 需要怎么做？OP 需要将 Broker 的读写权限禁掉。一旦 client(Consumer 或 Producer) 向 broker 发送请求，都会收到 broker 的 NO_PERMISSION 响应，然后 client 会进行对其它 Broker 的重试。当 OP 观察到这个 Broker 没有流量后，再关闭它，实现 Broker 从 NameServer 的移除。</p><h3 id="3-4-3-路由发现"><a href="#3-4-3-路由发现" class="headerlink" title="3.4.3. 路由发现"></a>3.4.3. 路由发现</h3><p>RocketMQ 的<span style="background-color:#f0f">路由发现采用的是 Pull 模型</span>。当 Topic 路由信息出现变化时，NameServer 不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认<span style="background-color:#0f0">客户端每 30 秒会拉取一次</span>最新的路由。</p><blockquote><p>扩展：<br>1）Push 模型：推送模型。其实时性较好，是一个“发布 - 订阅”模型，需要维护一个长连接。而长连接的维护是需要资源成本的。该模型适合于的场景： 实时性要求较高 Client 数量不多，Server 数据变化较频繁<br>2）Pull 模型：拉取模型。存在的问题是，实时性较差。<br>3）Long Polling 模型：长轮询模型。其是对 Push 与 Pull 模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。</p></blockquote><p>对比 Nacos：<a href="/2023/03/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-6%E3%80%81Nacos/" title="服务注册与发现-6、Nacos">服务注册与发现-6、Nacos</a></p><h3 id="3-4-4-客户端-NameServer-选择策略"><a href="#3-4-4-客户端-NameServer-选择策略" class="headerlink" title="3.4.4. 客户端 NameServer 选择策略"></a>3.4.4. 客户端 NameServer 选择策略</h3><blockquote><p>这里的客户端指的是 Producer 与 Consumer</p></blockquote><p>客户端在配置时必须要写上 NameServer 集群的地址，那么客户端到底连接的是哪个 NameServer 节点呢？客户端<span style="background-color:#0f0">首先会生产一个随机数，然后再与 NameServer 节点数量取模</span>，此时得到的就是所要连接的节点索引，然后就会进行连接。<span style="background-color:#0f0">如果连接失败，则会采用 round-robin 策略，逐个尝试着去连接其它节点</span>。<br>首先采用的是随机策略进行的选择，失败后采用的是轮询策略。</p><blockquote><p>扩展：Zookeeper Client 是如何选择 Zookeeper Server 的？ 简单来说就是，经过两次 Shuffle，然后选择第一台 Zookeeper Server。详细说就是，将配置文件中的 zk server 地址进行第一次 Shuffle，然后随机选择一个。这个选择出的一般都是一个 hostname。然后获取到该 hostname 对应的所有 ip，再对这些 ip 进行第二次 Shuffle，从 Shuffle 过的结果中取第一个 server 地址进行连接。</p></blockquote><h1 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h1><h2 id="4-1-具体流程"><a href="#4-1-具体流程" class="headerlink" title="4.1. 具体流程"></a>4.1. 具体流程</h2><p>1）启动 NameServer，NameServer 启动后开始监听端口，等待 Broker、Producer、Consumer 连接。<br>2）启动 Broker 时，Broker 会<span style="background-color:#f0f">与所有的 NameServer 建立并保持长连接</span>，然后每 &#x3D;&#x3D;30 秒&#x3D;&#x3D;向 NameServer 定时发送心跳包。<br>3）发送消息前，可以先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，当然，在创建 Topic 时也会将 Topic 与 Broker 的关系写入到 NameServer 中。不过，这步是可选的，也可以在发送消息时自动创建 Topic。<br>4）Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取路由信息，即当前发送的 Topic 消息的 Queue 与 Broker 的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个 Queue，与队列所在的 Broker 建立长连接从而向 Broker 发消息。当然，在获取到路由信息后，Producer 会首先将路由信息缓存到本地，再&#x3D;&#x3D;每 30 秒从 NameServer 更新一次路由信息&#x3D;&#x3D;。<br>5）Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取其所订阅 Topic 的路由信息，然后根据算法策略从路由信息中获取到其所要消费的 Queue，然后直接跟 Broker 建立长连接，开始消费其中的消息。Consumer 在获取到路由信息后，同样也会每 30 秒从 NameServer 更新一次路由信息。<span style="background-color:#ff0">不过不同于 Producer 的是，Consumer 还会向 Broker 发送心跳，以确保 Broker 的存活状态。</span></p><h2 id="4-2-Topic-的创建模式"><a href="#4-2-Topic-的创建模式" class="headerlink" title="4.2. Topic 的创建模式"></a>4.2. Topic 的创建模式</h2><p>手动创建 Topic 时，有两种模式：<br><strong>集群模式</strong>：该模式下创建的 Topic 在该集群中，所有 Broker 中的 Queue 数量是相同的。<br><strong>Broker 模式</strong>：该模式下创建的 Topic 在该集群中，每个 Broker 中的 Queue 数量可以不同。</p><blockquote><p>自动创建 Topic 时，默认采用的是 Broker 模式，会为每个 Broker 默认创建 4 个 Queue。</p></blockquote><h2 id="4-3-读-x2F-写队列"><a href="#4-3-读-x2F-写队列" class="headerlink" title="4.3. 读&#x2F;写队列"></a>4.3. 读&#x2F;写队列</h2><p><span style="background-color:#0f0">按数量大的创建 queue</span></p><p>从物理上来讲，读&#x2F;写队列是同一个队列。所以，不存在读&#x2F;写队列数据同步问题。读&#x2F;写队列是逻辑上进行区分的概念。一般情况下，读&#x2F;写队列数量是相同的。<br>例如，创建 Topic 时设置的写队列数量为 8，读队列数量为 4，此时系统会创建 8 个 Queue，分别是 0 1 2 3 4 5 6 7。Producer 会将消息写入到这 8 个队列，但 Consumer 只会消费 0 1 2 3 这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。<br>再如，创建 Topic 时设置的写队列数量为 4，读队列数量为 8，此时系统会创建 8 个 Queue，分别是 0 1 2 3 4 5 6 7。Producer 会将消息写入到 0 1 2 3 这 4 个队列，但 Consumer 只会消费 0 1 2 3 4 5 6 7 这 8 个队列中的消息，但是 4 5 6 7 中是没有消息的。此时假设 Consumer Group 中包含两个 Consuer，Consumer1 消 费 0 1 2 3，而 Consumer2 消费 4 5 6 7。但实际情况是，Consumer2 是没有消息可消费的。<br>也就是说，当读&#x2F;写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？<br>其这样设计的目的是为了，<span style="background-color:#0f0">方便 Topic 的 Queue 的缩容</span>。<br>例如，原来创建的 Topic 中包含 16 个 Queue，如何能够使其 Queue 缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费者消费的却是 16 个队列中的数据。<span style="background-color:#0f0">当发现<font color="#ff0000">后 8 个 Queue</font>中的消息消费完毕后</span>，就可以再将读队列数量动态设置为 8。整个缩容过程，没有丢失任何消息。<br>perm 用于设置对当前创建 Topic 的操作权限：2 表示只写，4 表示只读，6 表示读写。</p><h1 id="5-底层原理"><a href="#5-底层原理" class="headerlink" title="5. 底层原理"></a>5. 底层原理</h1><h2 id="5-1-数据复制与刷盘策略⭐️🔴"><a href="#5-1-数据复制与刷盘策略⭐️🔴" class="headerlink" title="5.1. 数据复制与刷盘策略⭐️🔴"></a>5.1. 数据复制与刷盘策略⭐️🔴</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104122805.png"></p><h3 id="5-1-1-复制策略"><a href="#5-1-1-复制策略" class="headerlink" title="5.1.1. 复制策略"></a>5.1.1. 复制策略</h3><pre><code>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：
</code></pre><p><strong>同步复制</strong>：消息写入 master 后，master 会等待 slave 同步数据成功后才向 producer 返回成功 ACK<br><strong>异步复制</strong>：消息写入 master 后，master 立即向 producer 返回成功 ACK，无需等待 slave 同步数据成功异步复制策略会降低系统的写入延迟，RT 变小，提高了系统的吞吐量</p><h3 id="5-1-2-刷盘策略"><a href="#5-1-2-刷盘策略" class="headerlink" title="5.1.2. 刷盘策略"></a>5.1.2. 刷盘策略</h3><pre><code>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。
</code></pre><p>分为同步刷盘与异步刷盘：</p><p><strong>同步刷盘</strong>：当消息持久化到 broker 的磁盘后才算是消息写入成功。<br><strong>异步刷盘</strong>：当消息写入到 broker 的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</p><blockquote><p>1）异步刷盘策略会降低系统的写入延迟，RT 变小，提高了系统的吞吐量<br>2）消息写入到 Broker 的内存，一般是写入到了 PageCache<br>3）对于异步刷盘策略，消息会写入到 PageCache 后立即返回成功 ACK。但并不会立即做落盘操作，而是当 PageCache 到达一定量时会自动进行落盘。</p></blockquote><h2 id="5-2-Broker-集群模式"><a href="#5-2-Broker-集群模式" class="headerlink" title="5.2. Broker 集群模式"></a>5.2. Broker 集群模式</h2><p>根据 Broker 集群中各个节点间关系的不同，Broker 集群可以分为以下几类：</p><h3 id="5-2-1-单-Master"><a href="#5-2-1-单-Master" class="headerlink" title="5.2.1. 单 Master"></a>5.2.1. 单 Master</h3><p>只有一个 broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p><h3 id="5-2-2-多-Master"><a href="#5-2-2-多-Master" class="headerlink" title="5.2.2. 多 Master"></a>5.2.2. 多 Master</h3><p>broker 集群仅由多个 master 构成，不存在 Slave。同一 Topic 的各个 Queue 会平均分布在各个 master 节点上。<br>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；<br>缺点：<span style="background-color:#f0f">单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</span></p><blockquote><p>以上优点的前提是，这些 Master 都配置了 RAID 磁盘阵列。如果没有配置，一旦出现某 Master 宕机，则会发生大量消息丢失的情况。</p></blockquote><h3 id="5-2-3-多-Master-多-Slave-模式-异步复制"><a href="#5-2-3-多-Master-多-Slave-模式-异步复制" class="headerlink" title="5.2.3. 多 Master 多 Slave 模式 - 异步复制"></a>5.2.3. 多 Master 多 Slave 模式 - 异步复制</h3><p>broker 集群由多个 master 构成，每个 master 又配置了多个 slave（在配置了 RAID 磁盘阵列的情况下，一个 master 一般配置一个 slave 即可）。master 与 slave 的关系是主备关系，即 master 负责处理消息的读写请求，而 slave 仅负责消息的备份与 master 宕机后的角色切换。<br>异步复制即前面所讲的复制策略中的异步复制策略，即消息写入 master 成功后，master 立即向 producer 返回成功 ACK，无需等待 slave 同步数据成功。<br>该模式的最大特点之一是，当 master 宕机后 slave 能够自动切换为 master。<span style="background-color:#f0f">不过由于 slave 从 master 的同步具有短暂的延迟（毫秒级），所以当 master 宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</span></p><blockquote><p>Slave 从 Master 同步的延迟越短，其可能丢失的消息就越少。对于 Master 的 RAID 磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但 RAID 阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。</p></blockquote><h3 id="5-2-4-多-Master-多-Slave-模式-同步双写"><a href="#5-2-4-多-Master-多-Slave-模式-同步双写" class="headerlink" title="5.2.4. 多 Master 多 Slave 模式 - 同步双写"></a>5.2.4. 多 Master 多 Slave 模式 - 同步双写</h3><p>该模式是多 Master 多 Slave 模式的同步复制实现。所谓同步双写，指的是消息写入 master 成功后，master 会等待 slave 同步数据成功后才向 producer 返回成功 ACK，即 master 与 slave 都要写入成功后才会返回成功 ACK，也即双写。<br>该模式与异步复制模式相比，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的 RT 略高，从而导致性能要略低（大约低 10%）。<br>该模式存在一个大的问题：对于目前的版本，Master 宕机后，Slave 不会自动切换到 Master。</p><h2 id="5-3-消息的生产"><a href="#5-3-消息的生产" class="headerlink" title="5.3. 消息的生产"></a>5.3. 消息的生产</h2><h3 id="5-3-1-消息的生产过程"><a href="#5-3-1-消息的生产过程" class="headerlink" title="5.3.1. 消息的生产过程"></a>5.3.1. 消息的生产过程</h3><ul><li>Producer 发送消息之前，会先向 NameServer 发出获取消息 Topic 的路由信息的请求</li><li>NameServer 返回该 Topic 的路由表及 Broker 列表</li><li>Producer 根据代码中指定的 Queue 选择策略，从 Queue 列表中选出一个队列，用于后续存储消息</li><li>Producer 对消息做一些特殊处理，例如，消息本身超过 4M，则会对其进行压缩</li><li>Producer 向选择出的 Queue 所在的 Broker 发出 RPC 请求，将消息发送到选择出的 Queue</li></ul><h3 id="5-3-2-Producer-的负载均衡"><a href="#5-3-2-Producer-的负载均衡" class="headerlink" title="5.3.2. Producer 的负载均衡"></a>5.3.2. Producer 的负载均衡</h3><p><span style="display:none">%%<br>▶4.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230417-1500%%</span>❕ ^sjwepe</p><p>Producer 端，每个实例在发消息的时候，默认会轮询所有的 message queue 发送，以达到让消息平均落在不同的 queue 上。而由于 queue 可以散落在不同的 broker，所以消息就发送到不同的 broker 下，如下图：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230417145613.png"></p><p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p><h3 id="5-3-3-Queue-选择算法"><a href="#5-3-3-Queue-选择算法" class="headerlink" title="5.3.3. Queue 选择算法"></a>5.3.3. Queue 选择算法</h3><h4 id="5-3-3-1-轮询算法-默认"><a href="#5-3-3-1-轮询算法-默认" class="headerlink" title="5.3.3.1. 轮询算法 - 默认"></a>5.3.3.1. 轮询算法 - 默认</h4><p>默认选择算法。该算法保证了每个 Queue 中可以均匀的获取到消息。<br><span style="background-color:#ff0">该算法存在一个问题：由于某些原因，在某些 Broker 上的 Queue 可能投递延迟较严重。从而导致 Producer 的缓存队列中出现较大的消息积压，影响消息的投递性能。</span></p><h4 id="5-3-3-2-最小投递延迟算法"><a href="#5-3-3-2-最小投递延迟算法" class="headerlink" title="5.3.3.2. 最小投递延迟算法"></a>5.3.3.2. 最小投递延迟算法</h4><p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的 Queue。<br>如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。<br><span style="background-color:#ff0">该算法也存在一个问题：消息在 Queue 上的分配不均匀。投递延迟小的 Queue 其可能会存在大量的消息。而对该 Queue 的消费者压力会增大，降低消息的消费能力，可能会导致 MQ 中消息的堆积。</span></p><h2 id="5-4-消息的存储"><a href="#5-4-消息的存储" class="headerlink" title="5.4. 消息的存储"></a>5.4. 消息的存储</h2><p>RocketMQ 消息的存储是由 ConsumeQueue 和 CommitLog 配合完成的，消息真正的物理存储文件是 CommitLog，<span style="background-color:#f0f">ConsumeQueue 是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址</span>。<span style="background-color:#0f0">每个 Topic 下的每个 Message Queue 都有一个对应的 ConsumeQueue 文件。</span></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV173411H7JR/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV173411H7JR/?spm_id_from=333.788&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405163417.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405163712.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405164151.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405164228.png" alt="image.png"></p><p>RocketMQ 中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的 store 目录中。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104130435.png"><br>abort：该文件在 Broker 启动后会自动创建，正常关闭 Broker，该文件会自动消失。若在没有启动<br>Broker 的情况下，发现这个文件是存在的，则说明之前 Broker 的关闭是非正常关闭。<br>checkpoint：其中存储着 commitlog、consumequeue、index 文件的最后刷盘时间戳<br><span style="background-color:#0f0">commitlog：其中存放着 commitlog 文件，而消息是写在 commitlog 文件中的</span><br>config：存放着 Broker 运行期间的一些配置数据<br>consumequeue：其中存放着 consumequeue 文件，队列就存放在这个目录中<br>index：其中存放着消息索引文件 indexFile<br>lock：运行期间使用到的全局资源锁</p><h3 id="5-4-1-commitlog"><a href="#5-4-1-commitlog" class="headerlink" title="5.4.1. commitlog"></a>5.4.1. commitlog</h3><p>说明：在很多资料中 commitlog 目录中的文件简单就称为 commitlog 文件。但在源码中，该文件被命名为 mappedFile。</p><h4 id="5-4-1-1-目录与文件"><a href="#5-4-1-1-目录与文件" class="headerlink" title="5.4.1.1. 目录与文件"></a>5.4.1.1. 目录与文件</h4><p>commitlog 目录中存放着很多的 mappedFile 文件，<span style="background-color:#f0f">当前 Broker 中的所有消息都是落盘到这些 mappedFile 文件中的</span>。mappedFile 文件大小为 1G（小于等于 1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。<br>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量 commitlog offset 为 0 当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G &#x3D; 1073741824 字节），则第二个文件名就是 00000000001073741824。 以此类推，第 n 个文件名应该是前 n-1 个文件大小之和。 一个 Broker 中所有 mappedFile 文件的 commitlog offset 是连续的<br>需要注意的是，<span style="background-color:#0f0">一个 Broker 中仅包含一个 commitlog 目录，所有的 mappedFile 文件都是存放在该目录中的。即无论当前 Broker 中存放着多少 Topic 的消息，这些消息都是被顺序写入到了 mappedFile 文件中的</span>。也就是说，<span style="background-color:#ff0">这些消息在 Broker 中存放时并没有被按照 Topic 进行分类存放。</span><span style="background-color:#f0f">mappedFile 文件是顺序读写的文件，所有其访问效率很高</span> 无论是 SSD 磁盘还是 SATA 磁盘，通常情况下，顺序存取效率都会高于随机存取。</p><h4 id="5-4-1-2-消息单元"><a href="#5-4-1-2-消息单元" class="headerlink" title="5.4.1.2. 消息单元"></a>5.4.1.2. 消息单元</h4><h3 id="5-4-2-consumequeue"><a href="#5-4-2-consumequeue" class="headerlink" title="5.4.2. consumequeue"></a>5.4.2. consumequeue</h3><h4 id="5-4-2-1-目录与文件"><a href="#5-4-2-1-目录与文件" class="headerlink" title="5.4.2.1. 目录与文件"></a>5.4.2.1. 目录与文件</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104132355.png"></p><p>为了提高效率，会为<span style="background-color:#f0f">每个 Topic</span> 在~&#x2F;store&#x2F;consumequeue 中创建一个目录，目录名为 Topic 名称。在该 Topic 目录下，<span style="background-color:#f0f">会再为每个该 Topic 的 Queue 建立一个目录</span>，目录名为 queueId。每个目录中存放着若干 consumequeue 文件，<span style="background-color:#f0f">consumequeue 文件是 commitlog 的索引文件</span>，可以根据 consumequeue 定位到具体的消息。<br>对比：Kafka 每个 topic 一个文件</p><h4 id="5-4-2-2-索引条目"><a href="#5-4-2-2-索引条目" class="headerlink" title="5.4.2.2. 索引条目"></a>5.4.2.2. 索引条目</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104132419.png"></p><p>每个 consumequeue 文件<span style="background-color:#f0f">可以包含 30w 个索引条目</span>，每个索引条目包含了三个消息重要属性：<br><span style="background-color:#0f0">消息在 mappedFile 文件中的偏移量 CommitLog Offset</span><br><span style="background-color:#0f0">消息长度</span><br><span style="background-color:#0f0">消息 Tag 的 hashcode 值</span><br>这三个属性占 20 个字节，所以每个文件的大小是固定的 30w * 20 字节。<br><span style="background-color:#ff0">一个 consumequeue 文件中所有消息的 Topic 一定是相同的</span>。但每条消息的 Tag 可能是不同的。</p><h3 id="5-4-3-对文件的读写"><a href="#5-4-3-对文件的读写" class="headerlink" title="5.4.3. 对文件的读写"></a>5.4.3. 对文件的读写</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104132607.png"></p><h4 id="5-4-3-1-消息写入"><a href="#5-4-3-1-消息写入" class="headerlink" title="5.4.3.1. 消息写入"></a>5.4.3.1. 消息写入</h4><p>一条消息进入到 Broker 后经历了以下几个过程才最终被持久化。</p><ul><li>Broker 根据 queueId，获取到该消息对应索引条目要在 consumequeue 目录中的写入偏移量，即 QueueOffset</li><li>将 queueId、queueOffset 等数据，与消息一起封装为消息单元</li><li>将消息单元写入到 commitlog</li><li>同时，形成消息索引条目</li><li>将消息索引条目分发到相应的 consumequeue</li></ul><h4 id="5-4-3-2-消息拉取"><a href="#5-4-3-2-消息拉取" class="headerlink" title="5.4.3.2. 消息拉取"></a>5.4.3.2. 消息拉取</h4><p>当 Consumer 来拉取消息时会经历以下几个步骤：</p><ul><li>Consumer 获取到其要消费消息所在 Queue 的消费偏移量 offset，计算出其要消费消息的<br>消息 offset</li></ul><blockquote><p><span style="background-color:#0f0">消费 offset 即消费进度</span>，consumer 对某个 Queue 的消费 offset，即消费到了该 Queue 的第几 条消息 <span style="background-color:#0f0">消息 offset &#x3D; 消费 offset + 1</span></p></blockquote><ul><li>Consumer 向 Broker 发送拉取请求，其中会包含其要拉取消息的 Queue、消息 offset 及消息 Tag。</li><li>Broker 计算在该 consumequeue 中的 queueOffset。 <span style="background-color:#ff0">queueOffset &#x3D; 消息 offset * 20 字节</span></li><li>从该 queueOffset 处开始向后查找第一个指定 Tag 的索引条目。</li><li>解析该索引条目的前 8 个字节，即可定位到该消息在 commitlog 中的 commitlog offset</li><li>从对应 commitlog offset 中读取消息单元，并发送给 Consumer</li></ul><h4 id="5-4-3-3-性能提示⭐️🔴⭐️🔴"><a href="#5-4-3-3-性能提示⭐️🔴⭐️🔴" class="headerlink" title="5.4.3.3. 性能提示⭐️🔴⭐️🔴"></a>5.4.3.3. 性能提示⭐️🔴⭐️🔴</h4><p>RocketMQ 中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实 RocketMQ 的性能在目前的 MQ 产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。<br>首先，RocketMQ 对文件的读写操作是通过<span style="background-color:#f0f">mmap 零拷贝</span>进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。<br>其次，<span style="background-color:#f0f">consumequeue 中的数据是顺序存放的</span>，还引入了 PageCache 的预读取机制，使得对<br>consumequeue 文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。</p><blockquote><p>PageCache 机制，页缓存机制，是 OS 对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行顺序读写的速度几乎接近于内存读写速度，主要原因是由于 OS 使用 PageCache 机制对读写访问操作进行性能优化，将一部分的内存用作 PageCache。<br>写操作：OS 会先将数据写入到 PageCache 中，随后会以异步方式由 pdæ ush（page dirty æ ush) 内核线程将 Cache 中的数据刷盘到物理磁盘<br>读操作：若用户要读取数据，其首先会从 PageCache 中读取，若没有命中，则 OS 在从物理磁 盘上加载该数据到 PageCache 的同时，也会顺序对其相邻数据块中的数据进行预读取。</p></blockquote><p>RocketMQ 中可能会影响性能的是对 commitlog 文件的读取。因为对 commitlog 文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统 IO 调度算法，比如设置调度算法为 Deadline（采用 SSD 固态硬盘的话），随机读的性能也会有所提升。</p><h2 id="5-5-消息的消费"><a href="#5-5-消息的消费" class="headerlink" title="5.5. 消息的消费"></a>5.5. 消息的消费</h2><a href="/2023/01/03/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-3%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9/" title="分布式专题-MQ-RocketMQ-3、消息的消费">分布式专题-MQ-RocketMQ-3、消息的消费</a><h2 id="5-6-幂等性"><a href="#5-6-幂等性" class="headerlink" title="5.6. 幂等性"></a>5.6. 幂等性</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L4411y7mn?t=155.5&amp;p=100">https://www.bilibili.com/video/BV1L4411y7mn?t=155.5&amp;p=100</a></p><h1 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6. 面试题"></a>6. 面试题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">001</span>-MQ/MQ.docx<br></code></pre></td></tr></table></figure><h2 id="6-1-RocketMQ-如何保证消息有序性"><a href="#6-1-RocketMQ-如何保证消息有序性" class="headerlink" title="6.1. RocketMQ 如何保证消息有序性"></a>6.1. RocketMQ 如何保证消息有序性</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HL4y1x7j2/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1HL4y1x7j2/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><a href="/2023/01/03/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-3%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9/" title="分布式专题-MQ-RocketMQ-3、消息的消费">分布式专题-MQ-RocketMQ-3、消息的消费</a><h2 id="6-2-RocketMQ-和-Kafka-的区别和相同点"><a href="#6-2-RocketMQ-和-Kafka-的区别和相同点" class="headerlink" title="6.2. RocketMQ 和 Kafka 的区别和相同点"></a>6.2. RocketMQ 和 Kafka 的区别和相同点</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AT411G7Hd/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1AT411G7Hd/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202739.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202753.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202810.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202830.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202854.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202907.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202918.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202929.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202940.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230402202951.png" alt="image.png"></p><p>失败重试、延时定时消息、分布式事务、消息查询</p><h2 id="6-3-RocketMQ-如何保证高可用⭐️🔴"><a href="#6-3-RocketMQ-如何保证高可用⭐️🔴" class="headerlink" title="6.3. RocketMQ 如何保证高可用⭐️🔴"></a>6.3. RocketMQ 如何保证高可用⭐️🔴</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230417-0753%%</span>❕ ^06jcfj</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YT411z7GV?p=36&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1YT411z7GV?p=36&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230417082518.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404072746.png" alt="image.png"></p><h3 id="6-3-1-架构层面"><a href="#6-3-1-架构层面" class="headerlink" title="6.3.1. 架构层面"></a>6.3.1. 架构层面</h3><p>避免用单节点或者简单的一主一从架构，可以采取多主从的架构，并且主从之间采用同步复制的方式进行<span style="background-color:#f0f">数据双写</span>。</p><h3 id="6-3-2-刷盘策略"><a href="#6-3-2-刷盘策略" class="headerlink" title="6.3.2. 刷盘策略"></a>6.3.2. 刷盘策略</h3><p>RocketMQ 默认的异步刷盘，可以<span style="background-color:#f0f">改成同步刷盘</span> SYNC_FLUSH。</p><h3 id="6-3-3-生产消息的高可用"><a href="#6-3-3-生产消息的高可用" class="headerlink" title="6.3.3. 生产消息的高可用"></a>6.3.3. 生产消息的高可用</h3><p>当消息发送失败了，在消息重试的时候，会尽量规避上一次发送的 Broker，选择还没推送过该消息的 Broker，以增大消息发送的成功率。</p><h3 id="6-3-4-消费消息的高可用"><a href="#6-3-4-消费消息的高可用" class="headerlink" title="6.3.4. 消费消息的高可用"></a>6.3.4. 消费消息的高可用</h3><p>消费者获取到消息之后，可以等到整个业务处理完成，再进行 CONSUME_SUCCESS 状态确认，如果业务处理过程中发生了异常那么就会触发 broker 的重试机制。</p><p>对比 Rabbitmq：<a href="/2023/03/08/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RabbitMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="分布式专题-MQ-RabbitMQ-1、基本原理">分布式专题-MQ-RabbitMQ-1、基本原理</a></p><h2 id="6-4-RocketMQ-的存储机制"><a href="#6-4-RocketMQ-的存储机制" class="headerlink" title="6.4. RocketMQ 的存储机制"></a>6.4. RocketMQ 的存储机制</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230403214018.png" alt="image.png"></p><h3 id="6-4-1-CommitLog"><a href="#6-4-1-CommitLog" class="headerlink" title="6.4.1. CommitLog"></a>6.4.1. CommitLog</h3><p>消息生产者发送消息到 broker，都是会<span style="background-color:#f0f">按照顺序存储在 CommitLog 文件中</span>，每个 commitLog 文件的大小为 1G。<span style="background-color:#f0f">同时有一个异步线程监听 CommitLog 文件</span>，有内容写入就会生成索引文件写入 ConsumeQueue 中。<br><strong>CommitLog</strong> - 存储所有的消息元数据，包括 Topic、QueueId 以及 message<br><strong>CosumerQueue</strong> - 消费逻辑队列：监听存储消息在 CommitLog 的 offset<br><strong>IndexFile</strong> - 索引文件：存储消息的 key 和时间戳等信息，使得 RocketMq 可以采用 key 和时间区间来查询消息 <br>也就是说，<span style="background-color:#f0f">rocketMq 将消息均存储在 CommitLog 中，并分别提供了 CosumerQueue 和 IndexFile 两个索引，来快速检索消息</span>。</p><h3 id="6-4-2-ConsumeQueue"><a href="#6-4-2-ConsumeQueue" class="headerlink" title="6.4.2. ConsumeQueue"></a>6.4.2. ConsumeQueue</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230403214223.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230104132419.png"></p><h3 id="6-4-3-IndexFile"><a href="#6-4-3-IndexFile" class="headerlink" title="6.4.3. IndexFile"></a>6.4.3. IndexFile</h3><p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/181270">https://www.modb.pro/db/181270</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230417210422.png" alt="image.png"></p><h3 id="6-4-4-ReputMessageServiceThreadLoop"><a href="#6-4-4-ReputMessageServiceThreadLoop" class="headerlink" title="6.4.4. ReputMessageServiceThreadLoop"></a>6.4.4. ReputMessageServiceThreadLoop</h3><p>每 1ms 扫描一次 <code>CommitLog</code> 文件，生成新插入内容的索引，写入到 <code>ConsumeQueue</code> 中</p><h2 id="6-5-为什么-Rocketmq-性能高⭐️🔴⭐️🔴"><a href="#6-5-为什么-Rocketmq-性能高⭐️🔴⭐️🔴" class="headerlink" title="6.5. 为什么 Rocketmq 性能高⭐️🔴⭐️🔴"></a>6.5. 为什么 Rocketmq 性能高⭐️🔴⭐️🔴</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230403225513.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404145132.png" alt="image.png"></p><h3 id="6-5-1-顺序写"><a href="#6-5-1-顺序写" class="headerlink" title="6.5.1. 顺序写"></a>6.5.1. 顺序写</h3><p>顺序写比随机写的性能会高很多，不会有大量寻址的过程</p><h3 id="6-5-2-异步刷盘"><a href="#6-5-2-异步刷盘" class="headerlink" title="6.5.2. 异步刷盘"></a>6.5.2. 异步刷盘</h3><p>相比较于同步刷盘，异步刷盘的性能会高很多</p><h3 id="6-5-3-零拷贝"><a href="#6-5-3-零拷贝" class="headerlink" title="6.5.3. 零拷贝"></a>6.5.3. 零拷贝</h3><p>使用 mmap 的方式进行零拷贝，提高了数据传输的效率</p><h3 id="6-5-4-CompletableFuture-提升同步双写性能"><a href="#6-5-4-CompletableFuture-提升同步双写性能" class="headerlink" title="6.5.4. CompletableFuture 提升同步双写性能"></a>6.5.4. CompletableFuture 提升同步双写性能</h3><p>FutureTask<br><span style="display:none"></span></p><ul><li><input disabled type="checkbox"> 🚩 - CompleteFutureTask - 🏡 2023-04-04 14:45</li></ul><p>#todo</p><h3 id="6-5-5-Commitlog-写入时锁的配置"><a href="#6-5-5-Commitlog-写入时锁的配置" class="headerlink" title="6.5.5. Commitlog 写入时锁的配置"></a>6.5.5. Commitlog 写入时锁的配置</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404152958.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404153519.png" alt="image.png"></p><p><span style="background-color:#f0f">默认是异步刷盘，所以默认使用的是自旋锁</span></p><h3 id="6-5-6-读写分离之对外内存机制"><a href="#6-5-6-读写分离之对外内存机制" class="headerlink" title="6.5.6. 读写分离之对外内存机制"></a>6.5.6. 读写分离之对外内存机制</h3><h2 id="6-6-让你来设计一个消息队列，你会怎么设计"><a href="#6-6-让你来设计一个消息队列，你会怎么设计" class="headerlink" title="6.6. 让你来设计一个消息队列，你会怎么设计"></a>6.6. 让你来设计一个消息队列，你会怎么设计</h2><h3 id="6-6-1-数据存储角度"><a href="#6-6-1-数据存储角度" class="headerlink" title="6.6.1. 数据存储角度"></a>6.6.1. 数据存储角度</h3><p>理论上，从速度来看，分布式文件系统&gt;分布式 KV（持久化）&gt;数据库，而可靠性却截然相反，如果追求性能可以基于文件系统的顺序写。</p><h3 id="6-6-2-高可用角度"><a href="#6-6-2-高可用角度" class="headerlink" title="6.6.2. 高可用角度"></a>6.6.2. 高可用角度</h3><p>分区 + 复制 + 选举的思想</p><h3 id="6-6-3-网络框架角度"><a href="#6-6-3-网络框架角度" class="headerlink" title="6.6.3. 网络框架角度"></a>6.6.3. 网络框架角度</h3><p>选用高效的 Netty 框架，producer 同步异步发送消息，consumer 同步异步接收消息。同步能够保证结果，异步能够保证性能。</p><h2 id="6-7-有几百万消息持续积压几小时，怎么解决⭐️🔴"><a href="#6-7-有几百万消息持续积压几小时，怎么解决⭐️🔴" class="headerlink" title="6.7. 有几百万消息持续积压几小时，怎么解决⭐️🔴"></a>6.7. 有几百万消息持续积压几小时，怎么解决⭐️🔴</h2><p>发生了线上故障，几千万条数据在 MQ 里积压很久。是修复 consumer 的问题，让他恢复消费速度，然后等待几个小时消费完毕？这是个解决方案。不过有时候我们还会进行临时紧急扩容。<br>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟是 18 万条。1000 多万条，所以如果积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。<br>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：<br>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。<br><span style="background-color:#f0f">新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍或者 20 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</span><br>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。<br>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，再恢复原先部署架构，重新用原先的 consumer 机器来消费消息。</p><h2 id="6-8-什么是路由注册？RocketMQ-如何进行路由注册？"><a href="#6-8-什么是路由注册？RocketMQ-如何进行路由注册？" class="headerlink" title="6.8. 什么是路由注册？RocketMQ 如何进行路由注册？"></a>6.8. <strong>什么是路由注册？RocketMQ 如何进行路由注册？</strong></h2><p>RocketMQ 的路由注册是通过 Broker 向 NameServer 发送心跳包实现的，首先 Broker <span style="background-color:#f0f">每隔 30s</span> 向 NameServer 发送心跳语句，NameServer <span style="background-color:#f0f">每隔 10 秒</span>扫描 <code>BrokerLiveTable</code>，检查上次心跳时间与当前时间时差是否<span style="background-color:#f0f">超过 120 秒</span>，超过则路由踢除。<br>RocketMQ 的<span style="background-color:#f0f">路由发现采用的是 Pull 模型</span>。当 Topic 路由信息出现变化时，NameServer 不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认<span style="background-color:#0f0">客户端每 30 秒会拉取一次</span>最新的路由。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404183553.png" alt="image.png"></p><p>对比 Nacos：<a href="/2023/03/11/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-6%E3%80%81Nacos/" title="服务注册与发现-6、Nacos">服务注册与发现-6、Nacos</a></p><h2 id="6-9-RocketMQ-的总体架构，以及每个组件的功能？"><a href="#6-9-RocketMQ-的总体架构，以及每个组件的功能？" class="headerlink" title="6.9. RocketMQ 的总体架构，以及每个组件的功能？"></a>6.9. <strong>RocketMQ 的总体架构，以及每个组件的功能？</strong></h2><p>RocketMQ 一共由四个部分组成：NameServer、Broker、Producer、Consumer，它们分别对应着发现、存、发、收四个功能。这四部分的功能很像邮政系统，Producer 相当于负责发送信件的发件人，Consumer 相当于负责接收信件的收件人，Broker 相当于负责暂存信件传输的邮局，NameServer 相当于负责协调各个地方邮局的管理机构。一般情况下，为了保证高可用，每一部分都是以集群形式部署的。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404193227.png" alt="image.png"></p><h2 id="6-10-讲一讲-RocketMQ-中的分布式事务及实现"><a href="#6-10-讲一讲-RocketMQ-中的分布式事务及实现" class="headerlink" title="6.10. 讲一讲 RocketMQ 中的分布式事务及实现"></a>6.10. 讲一讲 RocketMQ 中的分布式事务及实现</h2><a href="/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="事务-2、分布式事务">事务-2、分布式事务</a><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230404193818.png" alt="image.png"></p><h2 id="6-11-丢数情况"><a href="#6-11-丢数情况" class="headerlink" title="6.11. 丢数情况"></a>6.11. 丢数情况</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405144327.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405144556.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405144633.png" alt="image.png"></p><h2 id="6-12-讲一讲-RocketMQ-中事务回查机制的实现"><a href="#6-12-讲一讲-RocketMQ-中事务回查机制的实现" class="headerlink" title="6.12. 讲一讲 RocketMQ 中事务回查机制的实现"></a>6.12. 讲一讲 RocketMQ 中事务回查机制的实现</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230405180200.png" alt="image.png"></p><h2 id="6-13-订阅关系不一致问题"><a href="#6-13-订阅关系不一致问题" class="headerlink" title="6.13. 订阅关系不一致问题"></a>6.13. 订阅关系不一致问题</h2><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230417-0901%%</span>❕ ^nsewfi</p><p>RocketMQ 同一个消费组内的消费者订阅不同 tag，会有问题吗？<br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/214714">https://www.modb.pro/db/214714</a><br>会出现丢消息的问题</p><h3 id="6-13-1-不一致情况分-3-种"><a href="#6-13-1-不一致情况分-3-种" class="headerlink" title="6.13.1. 不一致情况分 3 种"></a>6.13.1. 不一致情况分 3 种</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230417085929.png" alt="image.png"></p><ul><li>消费组 1 的 Consumer1 和 Consumer2 都订阅了 Topic1，但是订阅的 Tag 不一致。</li><li>消费组 2 的 Consumer1 和 Consumer2 订阅的 Topic 不一致。</li><li>消费组 3 的 Consumer1 和 Consumer2 订阅的 Topic 和 Tag 都一致，但是订阅 Tag 的顺序不一致。</li></ul><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/RocketMQ%20%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E5%AE%8C%EF%BC%89/02%20RocketMQ%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%89%AB%E7%9B%B2%E7%AF%87.md****">技术文章摘抄</a></p><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230403-1840%%</span>❕ ^axhrcj</p><h2 id="8-1-尚硅谷"><a href="#8-1-尚硅谷" class="headerlink" title="8.1. 尚硅谷"></a>8.1. 尚硅谷</h2><h3 id="8-1-1-视频"><a href="#8-1-1-视频" class="headerlink" title="8.1.1. 视频"></a>8.1.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cf4y157sz/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1cf4y157sz/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-1-2-资料"><a href="#8-1-2-资料" class="headerlink" title="8.1.2. 资料"></a>8.1.2. 资料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">001</span>-MQ/尚硅谷分布式消息系统RocketMQ<br></code></pre></td></tr></table></figure><h2 id="8-2-黑马程序员"><a href="#8-2-黑马程序员" class="headerlink" title="8.2. 黑马程序员"></a>8.2. 黑马程序员</h2><h3 id="8-2-1-视频"><a href="#8-2-1-视频" class="headerlink" title="8.2.1. 视频"></a>8.2.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L4411y7mn/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1L4411y7mn/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-2-2-资料"><a href="#8-2-2-资料" class="headerlink" title="8.2.2. 资料"></a>8.2.2. 资料</h3><p><a target="_blank" rel="noopener" href="https://github.com/DillonDong/notes/tree/master/RocketMQ">https://github.com/DillonDong/notes/tree/master/RocketMQ</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">005</span>-分布式专题/资料-全面解剖RocketMQ和项目实战<br></code></pre></td></tr></table></figure><h2 id="8-3-马士兵-带面试题"><a href="#8-3-马士兵-带面试题" class="headerlink" title="8.3. 马士兵 - 带面试题"></a>8.3. 马士兵 - 带面试题</h2><h3 id="8-3-1-视频-1"><a href="#8-3-1-视频-1" class="headerlink" title="8.3.1. 视频 1"></a>8.3.1. 视频 1</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YT411z7GV?p=37&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1YT411z7GV?p=37&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-3-2-资料-1"><a href="#8-3-2-资料-1" class="headerlink" title="8.3.2. 资料 1"></a>8.3.2. 资料 1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">001</span>-MQ/马士兵-MQ.docx<br></code></pre></td></tr></table></figure><h3 id="8-3-3-视频-2"><a href="#8-3-3-视频-2" class="headerlink" title="8.3.3. 视频 2"></a>8.3.3. 视频 2</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kB4y1D7Q2?p=23&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1kB4y1D7Q2?p=23&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-3-4-资料-2"><a href="#8-3-4-资料-2" class="headerlink" title="8.3.4. 资料 2"></a>8.3.4. 资料 2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">001</span>-MQ/马士兵-RocketMQ-笔记.docx<br></code></pre></td></tr></table></figure><h2 id="8-4-网络笔记"><a href="#8-4-网络笔记" class="headerlink" title="8.4. 网络笔记"></a>8.4. 网络笔记</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/starcrm/p/13063833.html">https://www.cnblogs.com/starcrm/p/13063833.html</a><br><a target="_blank" rel="noopener" href="https://www.codenong.com/cs109783051/">https://www.codenong.com/cs109783051/</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">https://taylorluo.github.io/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a><a class="post-meta__tags" href="/tags/MQ/">MQ</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/912" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/31/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-MySQL-1、基本原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式专题-2、分布式事务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/03/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-2%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B8%85%E7%90%86/" title="框架源码专题-RocketMQ-2、消息的清理"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-04</div><div class="title">框架源码专题-RocketMQ-2、消息的清理</div></div></a></div><div><a href="/2023/03/08/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RabbitMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="框架源码专题-RabbitMQ-1、基本原理"><img class="cover" src="https://picsum.photos/1920/972" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">框架源码专题-RabbitMQ-1、基本原理</div></div></a></div><div><a href="/2023/01/03/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-3%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9/" title="框架源码专题-RocketMQ-3、消息ACK机制及消费进度管理"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-04</div><div class="title">框架源码专题-RocketMQ-3、消息ACK机制及消费进度管理</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8E%86%E5%8F%B2"><span class="toc-text">1. 历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B6%88%E6%81%AF%EF%BC%88Message%EF%BC%89"><span class="toc-text">2.1. 消息（Message）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%B8%BB%E9%A2%98%EF%BC%88Topic%EF%BC%89-%E6%B6%88%E8%B4%B9%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-text">2.2. 主题（Topic）- 消费者 - 消费者组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89-%E5%90%8C%E6%B6%88%E8%B4%B9%E7%BB%84%E5%8F%AA%E8%83%BD-1-%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.3. 队列（Queue）- 同消费组只能 1 个消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%B6%88%E6%81%AF%E6%A0%87%E8%AF%86%EF%BC%88MessageId-x2F-Key%EF%BC%89"><span class="toc-text">2.4. 消息标识（MessageId&#x2F;Key）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-text">3. 系统组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Producer"><span class="toc-text">3.1. Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Consumer"><span class="toc-text">3.2. Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Broker"><span class="toc-text">3.3. Broker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.3.1. 功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%A8%A1%E5%9D%97%E6%9E%84%E6%88%90"><span class="toc-text">3.3.2. 模块构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-text">3.3.3. 集群部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-NameServer"><span class="toc-text">3.4. NameServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C"><span class="toc-text">3.4.1. 路由注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E8%B7%AF%E7%94%B1%E5%89%94%E9%99%A4"><span class="toc-text">3.4.2. 路由剔除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E8%B7%AF%E7%94%B1%E5%8F%91%E7%8E%B0"><span class="toc-text">3.4.3. 路由发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E5%AE%A2%E6%88%B7%E7%AB%AF-NameServer-%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-text">3.4.4. 客户端 NameServer 选择策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">4. 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1. 具体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Topic-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.2. Topic 的创建模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%AF%BB-x2F-%E5%86%99%E9%98%9F%E5%88%97"><span class="toc-text">4.3. 读&#x2F;写队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">5. 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.1. 数据复制与刷盘策略⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">5.1.1. 复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-text">5.1.2. 刷盘策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Broker-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2. Broker 集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%8D%95-Master"><span class="toc-text">5.2.1. 单 Master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E5%A4%9A-Master"><span class="toc-text">5.2.2. 多 Master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%A4%9A-Master-%E5%A4%9A-Slave-%E6%A8%A1%E5%BC%8F-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-text">5.2.3. 多 Master 多 Slave 模式 - 异步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%A4%9A-Master-%E5%A4%9A-Slave-%E6%A8%A1%E5%BC%8F-%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99"><span class="toc-text">5.2.4. 多 Master 多 Slave 模式 - 同步双写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7"><span class="toc-text">5.3. 消息的生产</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-text">5.3.1. 消息的生产过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-Producer-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">5.3.2. Producer 的负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-Queue-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-text">5.3.3. Queue 选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-1-%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95-%E9%BB%98%E8%AE%A4"><span class="toc-text">5.3.3.1. 轮询算法 - 默认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-2-%E6%9C%80%E5%B0%8F%E6%8A%95%E9%80%92%E5%BB%B6%E8%BF%9F%E7%AE%97%E6%B3%95"><span class="toc-text">5.3.3.2. 最小投递延迟算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">5.4. 消息的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-commitlog"><span class="toc-text">5.4.1. commitlog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-1-%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-text">5.4.1.1. 目录与文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-2-%E6%B6%88%E6%81%AF%E5%8D%95%E5%85%83"><span class="toc-text">5.4.1.2. 消息单元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-consumequeue"><span class="toc-text">5.4.2. consumequeue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-1-%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-text">5.4.2.1. 目录与文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-2-%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE"><span class="toc-text">5.4.2.2. 索引条目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">5.4.3. 对文件的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-1-%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5"><span class="toc-text">5.4.3.1. 消息写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-2-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-text">5.4.3.2. 消息拉取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-3-%E6%80%A7%E8%83%BD%E6%8F%90%E7%A4%BA%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.4.3.3. 性能提示⭐️🔴⭐️🔴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9"><span class="toc-text">5.5. 消息的消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-text">5.6. 幂等性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">6. 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-RocketMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">6.1. RocketMQ 如何保证消息有序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-RocketMQ-%E5%92%8C-Kafka-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">6.2. RocketMQ 和 Kafka 的区别和相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-RocketMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.3. RocketMQ 如何保证高可用⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E6%9E%B6%E6%9E%84%E5%B1%82%E9%9D%A2"><span class="toc-text">6.3.1. 架构层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-text">6.3.2. 刷盘策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">6.3.3. 生产消息的高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">6.3.4. 消费消息的高可用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-RocketMQ-%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">6.4. RocketMQ 的存储机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-CommitLog"><span class="toc-text">6.4.1. CommitLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-ConsumeQueue"><span class="toc-text">6.4.2. ConsumeQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-IndexFile"><span class="toc-text">6.4.3. IndexFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-ReputMessageServiceThreadLoop"><span class="toc-text">6.4.4. ReputMessageServiceThreadLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E4%B8%BA%E4%BB%80%E4%B9%88-Rocketmq-%E6%80%A7%E8%83%BD%E9%AB%98%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.5. 为什么 Rocketmq 性能高⭐️🔴⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E9%A1%BA%E5%BA%8F%E5%86%99"><span class="toc-text">6.5.1. 顺序写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-text">6.5.2. 异步刷盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">6.5.3. 零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-CompletableFuture-%E6%8F%90%E5%8D%87%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99%E6%80%A7%E8%83%BD"><span class="toc-text">6.5.4. CompletableFuture 提升同步双写性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-5-Commitlog-%E5%86%99%E5%85%A5%E6%97%B6%E9%94%81%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">6.5.5. Commitlog 写入时锁的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-6-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B9%8B%E5%AF%B9%E5%A4%96%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">6.5.6. 读写分离之对外内存机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.6. 让你来设计一个消息队列，你会怎么设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%A7%92%E5%BA%A6"><span class="toc-text">6.6.1. 数据存储角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%92%E5%BA%A6"><span class="toc-text">6.6.2. 高可用角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E8%A7%92%E5%BA%A6"><span class="toc-text">6.6.3. 网络框架角度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E6%9C%89%E5%87%A0%E7%99%BE%E4%B8%87%E6%B6%88%E6%81%AF%E6%8C%81%E7%BB%AD%E7%A7%AF%E5%8E%8B%E5%87%A0%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.7. 有几百万消息持续积压几小时，怎么解决⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C%EF%BC%9FRocketMQ-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C%EF%BC%9F"><span class="toc-text">6.8. 什么是路由注册？RocketMQ 如何进行路由注册？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-RocketMQ-%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">6.9. RocketMQ 的总体架构，以及每个组件的功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-%E8%AE%B2%E4%B8%80%E8%AE%B2-RocketMQ-%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.10. 讲一讲 RocketMQ 中的分布式事务及实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-%E4%B8%A2%E6%95%B0%E6%83%85%E5%86%B5"><span class="toc-text">6.11. 丢数情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-%E8%AE%B2%E4%B8%80%E8%AE%B2-RocketMQ-%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%9F%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.12. 讲一讲 RocketMQ 中事务回查机制的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13-%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="toc-text">6.13. 订阅关系不一致问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-13-1-%E4%B8%8D%E4%B8%80%E8%87%B4%E6%83%85%E5%86%B5%E5%88%86-3-%E7%A7%8D"><span class="toc-text">6.13.1. 不一致情况分 3 种</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">7. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">8. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%B0%9A%E7%A1%85%E8%B0%B7"><span class="toc-text">8.1. 尚硅谷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E8%A7%86%E9%A2%91"><span class="toc-text">8.1.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E8%B5%84%E6%96%99"><span class="toc-text">8.1.2. 资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="toc-text">8.2. 黑马程序员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E8%A7%86%E9%A2%91"><span class="toc-text">8.2.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E8%B5%84%E6%96%99"><span class="toc-text">8.2.2. 资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E9%A9%AC%E5%A3%AB%E5%85%B5-%E5%B8%A6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">8.3. 马士兵 - 带面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E8%A7%86%E9%A2%91-1"><span class="toc-text">8.3.1. 视频 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E8%B5%84%E6%96%99-1"><span class="toc-text">8.3.2. 资料 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E8%A7%86%E9%A2%91-2"><span class="toc-text">8.3.3. 视频 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-%E8%B5%84%E6%96%99-2"><span class="toc-text">8.3.4. 资料 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0"><span class="toc-text">8.4. 网络笔记</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/912')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>