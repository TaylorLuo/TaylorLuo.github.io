<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>分布式专题-2、分布式事务 | Taylor</title><meta name="keywords" content="分布式事务"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 是什么 分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。 2. 产生的场景典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服"><meta property="og:type" content="article"><meta property="og:title" content="分布式专题-2、分布式事务"><meta property="og:url" content="https://taylorluo.github.io/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 是什么 分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。 2. 产生的场景典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://unpkg.com/justlovesmile-img/cover3.jpg"><meta property="article:published_time" content="2022-12-29T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.689Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="分布式事务"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://unpkg.com/justlovesmile-img/cover3.jpg"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"分布式专题-2、分布式事务",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://unpkg.com/justlovesmile-img/cover3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式专题-2、分布式事务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-29T16:00:00.000Z" title="发表于 2022-12-30 00:00:00">2022-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.689Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="分布式专题-2、分布式事务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221230211206.png"></p><p>分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。</p><h1 id="2-产生的场景"><a href="#2-产生的场景" class="headerlink" title="2. 产生的场景"></a>2. 产生的场景</h1><p>典型的场景就是微服务架构 <span style="background-color:#0f0">微服务之间通过远程调用完成事务操作</span>。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨 JVM 进程产生分布式事务。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221230211316.png"></p><p><span style="background-color:#0f0">单体系统访问多个数据库实例</span> 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个 MySQL 实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信 息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨 数据库实例产生分布式事务。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221230211415.png"></p><p><span style="background-color:#0f0">多服务访问同一个数据库实例</span> 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原 因就是跨 JVM 进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221230211437.png"></p><h1 id="3-基础理论"><a href="#3-基础理论" class="headerlink" title="3. 基础理论"></a>3. 基础理论</h1><h2 id="3-1-CAP-理论"><a href="#3-1-CAP-理论" class="headerlink" title="3.1. CAP 理论"></a>3.1. CAP 理论</h2><p>CAP 是 Consistency、Availability、Partition tolerance 三个词语的缩写，分别表示一致性、可用性、分区容忍性。</p><h3 id="3-1-1-CAP-组合方式"><a href="#3-1-1-CAP-组合方式" class="headerlink" title="3.1.1. CAP 组合方式"></a>3.1.1. CAP 组合方式</h3><p>1）AP： 放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。 例如： 上边的商品管理，完全可以实现 AP，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的即可。 通常实现 AP 都会保证最终一致性，后面讲的 BASE 理论就是根据 AP 来扩展的，一些业务场景 比如：订单退款，今 日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。</p><p>2）CP： 放弃可用性，追求一致性和分区容错性，我们的 zookeeper 其实就是追求的强一致，又比如跨行转账，一次转账请 求要等待双方银行系统都完成整个事务才算完成。</p><p>3）CA： 放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统 将不是一个标准的分布式系统，我们最常用的关系型数据就满足了 CA。</p><h3 id="3-1-2-总结"><a href="#3-1-2-总结" class="headerlink" title="3.1.2. 总结"></a>3.1.2. 总结</h3><p>通过上面我们已经学习了 CAP 理论的相关知识，CAP 是一个已经被证实的理论：一个分布式系统最多只能同时满足 一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。它可以作 为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的 集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9（99.99..%），并要达到良 好的响应性能来提高用户体验，因此一般都会做出如下选择：保证 P 和 A，舍弃 C 强一致，保证最终一致性。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230316224037.png" alt="image.png"></p><h2 id="3-2-BASE-理论"><a href="#3-2-BASE-理论" class="headerlink" title="3.2. BASE 理论"></a>3.2. BASE 理论</h2><h3 id="3-2-1-强一致性和最终一致性"><a href="#3-2-1-强一致性和最终一致性" class="headerlink" title="3.2.1. 强一致性和最终一致性"></a>3.2.1. 强一致性和最终一致性</h3><p>CAP 理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，<span style="background-color:#0f0">其中 AP 在实际应用中较多，AP 即舍弃一致性，保证可用性和分区容忍性</span>，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和 CAP 中的一致性不同，CAP 中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是<span style="background-color:#0f0">允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致</span>，它强调的是最终数据的一致性。</p><h3 id="3-2-2-Base-理论"><a href="#3-2-2-Base-理论" class="headerlink" title="3.2.2. Base 理论"></a>3.2.2. Base 理论</h3><p>BASE 是 <strong>Basically Available</strong>(基本可用)、<strong>Soft state</strong>(软状态) 和 <strong>Eventually consistent</strong> (最终一致性) 三个短语的缩写。<span style="background-color:#0f0">BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足 BASE 理论的事务，我们称之为“柔性事务”</span>。</p><p><strong>基本可用</strong>: 分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。 如，电商网站交易付款出现问题了，商品依然可以正常浏览。<br><strong>软状态</strong>: 由于不要求强一致性，所以 BASE 允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的 “ 支付中 “、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。<br><strong>最终一致</strong>: 最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的 “ 支付中 “ 状态，最终会变为“支付成功”或者 “ 支付失败 “，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</p><h1 id="4-分布式事务解决方案"><a href="#4-分布式事务解决方案" class="headerlink" title="4. 分布式事务解决方案"></a>4. 分布式事务解决方案</h1><p><span style="display:none">%%<br>▶20.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230228-2210%%</span> ^7zc3an</p><h2 id="4-1-2PC"><a href="#4-1-2PC" class="headerlink" title="4.1. 2PC"></a>4.1. 2PC</h2><h3 id="4-1-1-什么是-2PC"><a href="#4-1-1-什么是-2PC" class="headerlink" title="4.1.1. 什么是 2PC"></a>4.1.1. 什么是 2PC</h3><p>2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。</p><p>在计算机中部分关系数据库如 Oracle、MySQL 支持两阶段提交协议，如下图：</p><ol><li><p>准备阶段（Prepare phase）：事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo&#x2F;Redo 日志，此时事务没有提交。 （Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）</p></li><li><p>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚 (Rollback) 消息；否则，发送提交 (Commit) 消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。<span style="background-color:red">注意: 必须在最后阶段释放锁资源</span>。下图展示了 2PC 的两个阶段，分成功和失败两个情况说明：</p><p>成功情况：</p></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231120954.png"></p><p>失败情况：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231121044.png"></p><h3 id="4-1-2-2PC-实现方案"><a href="#4-1-2-2PC-实现方案" class="headerlink" title="4.1.2. 2PC 实现方案"></a>4.1.2. 2PC 实现方案</h3><h4 id="4-1-2-1-XA-方案"><a href="#4-1-2-1-XA-方案" class="headerlink" title="4.1.2.1. XA 方案"></a>4.1.2.1. XA 方案</h4><p>2PC 的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议。为了让大家更明确 XA 方案的内容程，下面新用户注册送积分为例来说明：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231122224.png"></p><h5 id="4-1-2-1-1-DTP-模型角色"><a href="#4-1-2-1-1-DTP-模型角色" class="headerlink" title="4.1.2.1.1. DTP 模型角色"></a>4.1.2.1.1. DTP 模型角色</h5><p>**AP(Application Program)**：即应用程序，可以理解为使用 DTP 分布式事务的程序。<br>**RM(Resource Manager)**：即资源管理器，可以理解为事务的参与者，<span style="background-color:#0f0">一般情况下是指一个数据库实例</span>，通过资源管理器对该数据库进行控制，<span style="background-color:#0f0">资源管理器控制着分支事务</span>。<br>**TM(Transaction Manager)**：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个 RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</p><p>DTP 模型定义 TM 和 RM 之间通讯的接口规范叫 XA，<span style="background-color:#0f0">简单理解为数据库提供的 2PC 接口协议</span>，基于数据库的 XA 协议来实现 2PC 又称为 XA 方案。</p><p>以上三个角色之间的交互方式如下：</p><p>1）TM 向 AP 提供应用程序编程接口，<strong>AP 通过 TM 提交及回滚事务</strong>。<br>2）TM 交易中间件 <strong>通过 XA 接口来通知 RM 数据库</strong> 事务的开始、结束以及提交、回滚等。</p><p>总结： 整个 2PC 的事务流程涉及到三个角色 AP、RM、TM。AP 指的是使用 2PC 分布式事务的应用程序；RM 指的是资源管理器，它控制着分支事务；TM 指的是事务管理器，它控制着整个全局事务。</p><h5 id="4-1-2-1-2-执行流程如下"><a href="#4-1-2-1-2-执行流程如下" class="headerlink" title="4.1.2.1.2. 执行流程如下"></a>4.1.2.1.2. 执行流程如下</h5><p>1、 应用程序（AP）持有用户库和积分库两个数据源。<br>2、应用程序（AP）通过 TM 通知用户库 RM 新增用户，同时通知积分库 RM 为该用户新增积分，RM 此时并未提交事务，此时<span style="background-color:#f0f">用户和积分资源锁定</span>。<br>3、TM 收到执行回复，只要有一方失败则分别向其他 RM 发起回滚事务，回滚完毕，资源锁释放。<br>4、TM 收到执行回复，全部成功，此时向所有 RM 发起提交事务，提交完毕，资源锁释放。</p><h5 id="4-1-2-1-3-XA-方案的问题"><a href="#4-1-2-1-3-XA-方案的问题" class="headerlink" title="4.1.2.1.3. XA 方案的问题"></a>4.1.2.1.3. XA 方案的问题</h5><p><span style="background-color:#ff0">1、需要本地数据库支持 XA 协议。</span><br><span style="background-color:#ff0">2、资源锁需要等到两个阶段结束才释放，性能较差。</span></p><h4 id="4-1-2-2-Seata-方案"><a href="#4-1-2-2-Seata-方案" class="headerlink" title="4.1.2.2. Seata 方案"></a>4.1.2.2. Seata 方案</h4><h5 id="4-1-2-2-1-什么是-Seata"><a href="#4-1-2-2-1-什么是-Seata" class="headerlink" title="4.1.2.2.1. 什么是 Seata"></a>4.1.2.2.1. 什么是 Seata</h5><p>Seata 是由阿里中间件团队发起的开源项目 Fescar，后更名为 Seata，它是一个是开源的分布式事务框架。 传统 2PC 的问题在 Seata 中得到了解决，<span style="background-color:#0f0">它通过对本地关系数据库的分支事务的协调来驱动完成全局事务</span>，工作在应用层的中间件。主要优点是<span style="background-color:#0f0">性能较好，且不长时间占用连接资源，它以高效并且对业务 0 侵入的方式解决微服务场景下面临的分布式事务问题</span>，它目前提供<span style="background-color:#ff0">AT 模式 (即 2PC) 及 TCC 模式</span>的分布式事务解决方案。</p><h5 id="4-1-2-2-2-Seata-原理"><a href="#4-1-2-2-2-Seata-原理" class="headerlink" title="4.1.2.2.2. Seata 原理"></a>4.1.2.2.2. Seata 原理</h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231133229.png"><br>**Transaction Coordinator (TC)**： 事务协调器，<span style="background-color:#f0f">它是独立的中间件，需要独立部署运行</span>，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，负责与 RM 通信协调各个分支事务的提交或回滚。<br>**Transaction Manager (TM)**： 事务管理器，<span style="background-color:#0f0">TM 需要嵌入应用程序中工作</span>，它负责开启一个全局事务，并<span style="background-color:#f0f">最终向 TC 发起全局提交或全局回滚的指令</span>。<br>**Resource Manager (RM)**： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。</p><h5 id="4-1-2-2-3-流程分析"><a href="#4-1-2-2-3-流程分析" class="headerlink" title="4.1.2.2.3. 流程分析"></a>4.1.2.2.3. 流程分析</h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231133840.png"></p><p>具体的执行流程如下：</p><ol><li>用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</li><li>用户服务的 RM 向 TC 注册 分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>用户服务执行分支事务，向用户表插入一条记录。</li><li>逻辑执行到<span style="background-color:#0f0">远程调用积分服务</span>时 (<strong>XID 在微服务调用链路的上下文中传播</strong>)。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。</li><li>积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。</li><li>至此用户服务分支事务执行完毕。</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ol><p>详细流程见：<a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98-6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/" title="面试专题-6、分布式组件">面试专题-6、分布式组件</a></p><h5 id="4-1-2-2-4-传统-2PC-的差别⭐️🔴"><a href="#4-1-2-2-4-传统-2PC-的差别⭐️🔴" class="headerlink" title="4.1.2.2.4. 传统 2PC 的差别⭐️🔴"></a>4.1.2.2.4. 传统 2PC 的差别⭐️🔴</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FJ411A7mV?p=9&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1FJ411A7mV?p=9&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><ol><li>架构层次方面，传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 <span style="background-color:#ff0">RM(TM) 是以 jar 包的形式作为中间件层部署在应用程序这一侧</span>的。❕<span style="display:none">%%<br>▶3.🏡⭐️◼️理解传统 2PC 与 seata AT 模式的区别 ?🔜MSTM📝 AT 模式中传统 2PC TM 的事务协调工作交给了 TC，TM 负责开启全局事务。以 jar 包的方式嵌入的应用中◼️⭐️-point-20230228-1639%%</span></li><li>两阶段提交方面，传统 2PC 无论第二阶段的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。<span style="background-color:#f0f">而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效</span></li></ol><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/044e95223a17">https://www.jianshu.com/p/044e95223a17</a></p><p><strong>XA 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身（通过提供支持 XA 的驱动程序来供应用使用）。而 Seata 的 RM 是以二方包的形式作为中间件层部署在应用程序这一侧的，不依赖与数据库本身对协议的支持，当然也不需要数据库支持 XA 协议</strong>。这点对于微服务化的架构来说是非常重要的：应用层不需要为本地事务和分布式事务两类不同场景来适配两套不同的数据库驱动。</p><p>另外，**XA 方案无论 Phase2 的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。而对于 Seata，将锁分为了本地锁和全局锁，本地锁由本地事务管理，在分支事务 Phase1 结束时就直接释放。而全局锁由 TC 管理，在决议 Phase2 全局提交时，全局锁马上可以释放。只有在决议全局回滚的情况下，全局锁才被持有至分支的 Phase2 结束。因此，Seata 对于资源的占用时间要少的多。</p><h5 id="4-1-2-2-5-使用要素"><a href="#4-1-2-2-5-使用要素" class="headerlink" title="4.1.2.2.5. 使用要素"></a>4.1.2.2.5. 使用要素</h5><ol><li>全局事务开始使用 @GlobalTransactional 标识 。</li><li>每个本地事务方案仍然使用@Transactional 标识。</li><li>每个数据都需要创建 undo_log 表，此表是 seata 保证本地事务一致性的关键。</li></ol><h2 id="4-2-TCC"><a href="#4-2-TCC" class="headerlink" title="4.2. TCC"></a>4.2. TCC</h2><h3 id="4-2-1-什么是-TCC-事务"><a href="#4-2-1-什么是-TCC-事务" class="headerlink" title="4.2.1. 什么是 TCC 事务"></a>4.2.1. 什么是 TCC 事务</h3><p>TCC 是 Try、Confirm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Confirm、撤销 Cancel。Try 操作做业务检查及资源预留，Confirm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。TM 首先发起所有的分支事务的 try 操作，任何一个分支事务的 try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 try 操作全部成功，TM 将会发起所有分支事务的 Confirm 操作，其中 Confirm&#x2F;Cancel 操作若执行失败，TM 会进行重试。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228152526.png" alt="image.png"></p><p><strong>TCC 分为三个阶段</strong>：</p><ol><li>Try 阶段是做业务检查 (一致性) 及资源预留 (隔离)，此阶段仅是一个初步操作，它和后续的 Confirm 一起才能真正构成一个完整的业务逻辑。</li><li>Confirm 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用 TCC 则认为 Confirm 阶段是不会出错的。即：只要 Try 成功，Confirm 一定成功。若 Confirm 阶段真的出错了，需引入重试机制或人工处理。</li><li>Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。</li></ol><p>TM 事务管理器可以实现为独立的服务，也可以让全局事务发起方充当 TM 的角色，TM 独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。</p><p>TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于 Confirm 和 cancel 失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。</p><h3 id="4-2-2-TCC-需要注意三种异常处理分别是空回滚、幂等、悬挂"><a href="#4-2-2-TCC-需要注意三种异常处理分别是空回滚、幂等、悬挂" class="headerlink" title="4.2.2. TCC 需要注意三种异常处理分别是空回滚、幂等、悬挂"></a>4.2.2. TCC 需要注意三种异常处理分别是空回滚、幂等、悬挂</h3><p><span style="display:none">%%<br>▶10.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1110%%</span>❕ ^4qeujw</p><h4 id="4-2-2-1-空回滚"><a href="#4-2-2-1-空回滚" class="headerlink" title="4.2.2.1. 空回滚"></a>4.2.2.1. 空回滚</h4><p><span style="background-color:#f0f">在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法</span>，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。<span style="background-color:#0f0">出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的 Cancel 方法，从而形成空回滚。</span>解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。前面已经说过 TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条。<span style="background-color:#0f0">再额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。</span>Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p><h4 id="4-2-2-2-幂等"><a href="#4-2-2-2-幂等" class="headerlink" title="4.2.2.2. 幂等"></a>4.2.2.2. 幂等</h4><p>通过前面介绍已经了解到，为了保证 TCC 二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、 Confirm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。<span style="background-color:#f0f">解决思路在上述“分支事务记录”中增加执行状态，每次执行前都查询该状态。</span></p><h4 id="4-2-2-3-悬挂"><a href="#4-2-2-3-悬挂" class="headerlink" title="4.2.2.3. 悬挂"></a>4.2.2.3. 悬挂</h4><p>悬挂就是对于一个分布式事务，其<span style="background-color:#f0f">二阶段 Cancel 接口比 Try 接口先执行</span>。 出现原因是在 RPC 调用分支事务 try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵， 通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。 解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支 事务记录”表中是否已经有二阶段事务记录，如果有则不执行 Try。</p><h3 id="4-2-3-小结"><a href="#4-2-3-小结" class="headerlink" title="4.2.3. 小结"></a>4.2.3. 小结</h3><p>如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，<span style="background-color:#0f0">2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现</span>。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p><p>而不足之处则在于<span style="background-color:#ff0">对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、confifirm、cancel 三个操作</span>。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p><h3 id="4-2-4-使用案例-Hmily"><a href="#4-2-4-使用案例-Hmily" class="headerlink" title="4.2.4. 使用案例 Hmily"></a>4.2.4. 使用案例 Hmily</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228200919.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228200953.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302070252.png" alt="image.png"></p><h2 id="4-3-可靠消息最终一致性"><a href="#4-3-可靠消息最终一致性" class="headerlink" title="4.3. 可靠消息最终一致性"></a>4.3. 可靠消息最终一致性</h2><h3 id="4-3-1-可靠消息最终一致性事务"><a href="#4-3-1-可靠消息最终一致性事务" class="headerlink" title="4.3.1. 可靠消息最终一致性事务"></a>4.3.1. 可靠消息最终一致性事务</h3><p>可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方 (消息消费者)<span style="background-color:#0f0">一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。</span></p><p>此方案是利用消息中间件完成，如下图：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231162219.png"></p><p>事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。</p><p>因此可靠消息最终一致性方案要解决以下几个问题：</p><ol><li><p>本地事务与消息发送的原子性问题<br>本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。<span style="background-color:red">本地事务与消息发送的原子性问题</span>是实现可靠消息最终一致性方案的关键问题。</p></li><li><p>事务参与方接收消息的可靠性<br>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。</p></li><li><p>消息重复消费的问题<br>由于网络 2 的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。 要解决消息重复消费的问题<span style="background-color:#ff0">就要实现事务参与方的方法幂等性</span>。</p></li></ol><h3 id="4-3-2-解决方案"><a href="#4-3-2-解决方案" class="headerlink" title="4.3.2. 解决方案"></a>4.3.2. 解决方案</h3><h4 id="4-3-2-1-本地消息表方案"><a href="#4-3-2-1-本地消息表方案" class="headerlink" title="4.3.2.1. 本地消息表方案"></a>4.3.2.1. 本地消息表方案</h4><p>本地消息表这个方案最初是 eBay 提出的，此方案的核心是<span style="background-color:#0f0">通过本地事务保证数据业务操作和消息的一致性</span>，具体过程：通过 <strong>定时任务</strong> 将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231163152.png"></p><h4 id="4-3-2-2-RocketMQ"><a href="#4-3-2-2-RocketMQ" class="headerlink" title="4.3.2.2. RocketMQ"></a>4.3.2.2. RocketMQ</h4><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230404-1936%%</span>❕ ^8uae29</p><h5 id="4-3-2-2-1-事务消息是什么"><a href="#4-3-2-2-1-事务消息是什么" class="headerlink" title="4.3.2.2.1. 事务消息是什么"></a>4.3.2.2.1. 事务消息是什么</h5><p>RocketMQ 事务消息设计则主要是为了<span style="background-color:#f0f">解决 Producer 端的消息发送与本地事务执行的原子性问题</span>，RocketMQ 的 设计中 <span style="background-color:red">broker 与 producer 端的双向通信能力</span>，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ 本身提供的存储机制为事务消息提供了持久化能力；RocketMQ 的<span style="background-color:#0f0">高可用机制以及可靠消息设计</span>则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。<br>在 RocketMQ 4.3 后实现了完整的事务消息，<span style="background-color:#0f0">实际上是对本地消息表的一个封装，将本地消息表移动到了 MQ 内部</span>，<span style="background-color:#0f0">解决 Producer 端的消息发送与本地事务执行的原子性问题</span>。</p><h5 id="4-3-2-2-2-执行流程"><a href="#4-3-2-2-2-执行流程" class="headerlink" title="4.3.2.2.2. 执行流程"></a>4.3.2.2.2. 执行流程</h5><p><span style="display:none">%%<br>▶9.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230228-1946%%</span> ^2z2afv<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231174316.png"></p><p>为方便理解我们还以注册送积分的例子来描述整个流程。 Producer 即 MQ 发送方，本例中是用户服务，负责新增用户。MQ 订阅方即消息消费方，本例中是积分服务，负责新增积分。</p><p>1、Producer 发送事务消息<br>Producer （MQ 发送方）发送事务消息至 MQ Server，MQ Server 将消息状态标记为<span style="background-color:#0f0">Prepared（预备状态）</span>，注意此时这条消息消费者（MQ 订阅方）是无法消费到的。<br>本例中，Producer 发送 ”增加积分消息“ 到 MQ Server。</p><p>2、MQ Server 回应消息发送成功<br>MQ Server 接收到 Producer 发送给的消息则回应发送成功表示 MQ 已接收到消息。</p><p>3、Producer 执行本地事务⭐️🔴<br><span style="display:none">%%<br>▶13.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1216%%</span>❕ ^x1o35a</p><pre><code>Producer 端执行业务代码逻辑，通过本地数据库事务控制。
本例中，Producer 执行添加用户操作。
</code></pre><p>RoacketMQ 提供 RocketMQLocalTransactionListener 接口。实现该方案时，<span style="background-color:#f0f">需要编写 RocketMQLocalTransactionListener 接口实现类，实现执行本地事务和事务回查两个方法。</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301103952.png" alt="image.png"></p><p>4、消息投递⭐️🔴<br>若 Producer 本地事务执行成功则自动向 MQServer 发送<span style="background-color:#0f0">commit 消息</span>，MQ Server 接收到 commit 消息后将”增加积分消息“ 状态标记为 <strong>可消费</strong>，此时 MQ 订阅方（积分服务）即正常消费消息；</p><p>若 Producer 本地事务执行失败则<span style="background-color:#f0f">自动向 MQServer 发送 rollback 消息</span>，MQ Server 接收到 rollback 消息后 将<span style="background-color:#ff0">删除”增加积分消息“</span> 。</p><p>MQ 订阅方（积分服务）消费消息，<span style="background-color:#f0f">消费成功则向 MQ 回应 ack，否则将重复接收消息。</span>这里 ack 默认自动回应，即程序执行正常则自动回应 ack。</p><p>5、事务回查⭐️🔴</p><p>如果执行 Producer 端本地事务过程中，执行端挂掉，或者超时，MQ Server 将会不停的<span style="background-color:#f0f">询问同组的其他 Producer</span>来获取事务执行状态，这个过程叫事务回查。MQ Server 会根据事务回查结果来决定是否投递消息。</p><p>以上主干流程已由 RocketMQ 实现，对用户侧来说，用户需要分别实现<span style="background-color:#0f0">本地事务执行以及本地事务回查方法</span>，因此只需关注本地事务的执行状态即可。</p><h5 id="4-3-2-2-3-小结"><a href="#4-3-2-2-3-小结" class="headerlink" title="4.3.2.2.3. 小结"></a>4.3.2.2.3. 小结</h5><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了 RocketMQ 作为消息中间件，RocketMQ 主要解决了两个功能：<br><span style="background-color:#ff0">1、本地事务与消息发送的原子性问题。</span><br><span style="background-color:#ff0">2、事务参与方接收消息的可靠性。</span></p><p>可靠消息最终一致性事务适合<span style="background-color:#f0f">执行周期长且实时性要求不高的场景</span>。引入消息机制后，<strong>同步的事务操作变为基于消息的异步执行操作</strong>, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p><h2 id="4-4-最大努力通知"><a href="#4-4-最大努力通知" class="headerlink" title="4.4. 最大努力通知"></a>4.4. 最大努力通知</h2><h3 id="4-4-1-是什么"><a href="#4-4-1-是什么" class="headerlink" title="4.4.1. 是什么"></a>4.4.1. 是什么</h3><p>目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。<br>具体包括：<br>1、有一定的消息重复通知机制。 因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。<br>2、消息校对机制。 如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</p><h3 id="4-4-2-解决方案"><a href="#4-4-2-解决方案" class="headerlink" title="4.4.2. 解决方案"></a>4.4.2. 解决方案</h3><p>通过对最大努力通知的理解，采用 MQ 的<span style="background-color:#0f0">ack 机制</span>就可以实现最大努力通知。</p><h4 id="4-4-2-1-方案-1-企业内部应用"><a href="#4-4-2-1-方案-1-企业内部应用" class="headerlink" title="4.4.2.1. 方案 1- 企业内部应用"></a>4.4.2.1. 方案 1- 企业内部应用</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231183254.png"></p><p>本方案是利用 MQ 的 ack 机制<span style="background-color:#f0f">由 MQ 向接收通知方发送通知</span>，流程如下：</p><p>1、发起通知方将通知发给 MQ。<br>使用普通消息机制将通知发给 MQ。<br>注意：如果消息没有发出去可由接收通知方主动请求发起通知方查询业务执行结果。（后边会讲）<br>2、接收通知方 <strong>监听 MQ</strong>。<br>3、接收通知方接收消息，业务处理完成回应 ack。<br>4、接收通知方 <strong>若没有回应 ack 则 MQ 会重复通知</strong>。<br>MQ 会按照间隔 1min、5min、10min、30min、1h、2h、5h、10h 的方式，逐步拉大通知间隔 （如果 MQ 采用 RocketMQ，在 broker 中可进行配置），直到达到通知要求的时间窗口上限。<br>5、接收通知方可通过消息校对接口来校对消息的一致性。</p><h4 id="4-4-2-2-方案-2-通知外部应用"><a href="#4-4-2-2-方案-2-通知外部应用" class="headerlink" title="4.4.2.2. 方案 2- 通知外部应用"></a>4.4.2.2. 方案 2- 通知外部应用</h4><p>本方案也是利用 MQ 的 ack 机制，与方案 1 不同的是<span style="background-color:#f0f">由应用程序向接收通知方发送通知</span>，如下图：<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221231183847.png"></p><p><strong>方案 1 和方案 2 的不同点</strong></p><p>1、方案 1 中接收通知方与 MQ 接口，即 <strong>接收通知方可以案监听 MQ</strong>，此方案<span style="background-color:#0f0">主要应用于同一个企业内部应用之间的通知</span>。</p><p>2、方案 2 中由通知程序与 MQ 接口，<span style="background-color:#ff0">通知程序监听 MQ</span>，收到 MQ 的消息后由通知程序通过互联网接口协议调用接收通知方。此方案<span style="background-color:#0f0">主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。</span></p><h3 id="4-4-3-最大努力通知与可靠消息一致性有什么不同"><a href="#4-4-3-最大努力通知与可靠消息一致性有什么不同" class="headerlink" title="4.4.3. 最大努力通知与可靠消息一致性有什么不同"></a>4.4.3. 最大努力通知与可靠消息一致性有什么不同</h3><p>1、解决方案思想不同</p><p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，<span style="background-color:#0f0">消息的可靠性关键由<font color="#ff0000">发起通知方</font>来保证</span>。</p><p>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，<span style="background-color:#0f0">通知的可靠性关键在<font color="#ff0000">接收通知方</font></span>。</p><p>2、两者的业务应用场景不同</p><p>可靠消息一致性关注的是<span style="background-color:#f0f">交易过程的事务一致，以异步的方式完成交易</span>。<br>最大努力通知关注的是<span style="background-color:#f0f">交易后的通知事务，即将交易结果可靠的通知出去</span>。</p><p>3、技术解决方向不同</p><p>可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。</p><p>最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>分布式事务对比分析: 在学习各种分布式事务的解决方案后，我们了解到各种方案的优缺点：<br>2PC 最大的诟病是一个阻塞协议。RM 在执行分支事务后需要等待 TM 的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度高，因此，这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，很难用于并发较高以及子事务生命周期较长 (long-running transactions) 的分布式服务中。<br>如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。&#x3D;&#x3D;典型的使用场景：满，登录送优惠券等&#x3D;&#x3D;。<br>可靠消息最终一致性事务适合<span style="background-color:#0f0">执行周期长且实时性要求不高的场景</span>。引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。&#x3D;&#x3D;典型的使用场景：注册送积分，登录送优惠券等&#x3D;&#x3D;。<br>最大努力通知是分布式事务中要求最低的一种。适用于一些最终一致性时间敏感度低的业务；允许发起通知方处理业务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都会不影响到接收通知方的后续处理；发起通知方需提供查询执行情况接口，用于接收通知方校对结果。&#x3D;&#x3D;典型的使用场景：银行通知、支付结果通知等&#x3D;&#x3D;。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302072650.png" alt="image.png"></p><p>总结： 在条件允许的情况下，我们尽可能选择本地事务单数据源，因为它减少了网络交互带来的性能损耗，且避免了数据弱一致性带来的种种问题。若某系统频繁且不合理的使用分布式事务，应首先从整体设计角度观察服务的拆分是否合理，是否高内聚低耦合？是否粒度太小？分布式事务一直是业界难题，因为网络的不确定性，而且我们习惯于拿分布式事务与单机事务 ACID 做对比。 无论是数据库层的 XA、还是应用层 TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。</p><h1 id="6-实战经验"><a href="#6-实战经验" class="headerlink" title="6. 实战经验"></a>6. 实战经验</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230405-0754%%</span>❕ ^ylefmx</p><h2 id="6-1-注册账号案例分析"><a href="#6-1-注册账号案例分析" class="headerlink" title="6.1. 注册账号案例分析"></a>6.1. 注册账号案例分析</h2><h3 id="6-1-1-业务流程"><a href="#6-1-1-业务流程" class="headerlink" title="6.1.1. 业务流程"></a>6.1.1. 业务流程</h3><p>采用用户、账号分离设计 (这样设计的好处是，当用户的业务信息发生变化时，不会影响的认证、授权等系统机制)，因此需要保证用户信息与账号信息的一致性。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230101132144.png"></p><h3 id="6-1-2-解决方案分析"><a href="#6-1-2-解决方案分析" class="headerlink" title="6.1.2. 解决方案分析"></a>6.1.2. 解决方案分析</h3><p>针对注册业务，如果用户与账号信息不一致，则会导致严重问题，因此该业务对一致性要求较为严格，即当用户服务和账号服务任意一方出现问题都需要回滚事务。</p><p>根据上述需求进行解决方案分析：</p><p><strong>1、采用可靠消息一致性方案</strong></p><p>可靠消息一致性要求只要消息发出，事务参与者接到消息就要将事务执行成功，<span style="background-color:#ff0">不存在回滚的要求</span>，所以不适用。</p><p><strong>2、采用最大努力通知方案</strong></p><p>最大努力通知表示发起通知方执行完本地事务后将结果通知给事务参与者，即使事务参与者执行业务处理失败，发起通知方<span style="background-color:#ff0">也不会回滚事务</span>，所以不适用。</p><p><strong>3、采用 Seata 实现 2PC</strong></p><p>在用户中心发起全局事务，统一账户服务为事务参与者，用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。</p><p>实现方法如下：</p><pre><code>1、用户中心添加用户信息，开启全局事务
2、统一账号服务添加账号信息，作为事务参与者
3、其中一方执行失败Seata对SQL进行逆操作删除用户信息和账号信息，实现回滚。
</code></pre><p><strong>4、采用 Hmily 实现 TCC</strong></p><p>TCC 也可以实现用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。</p><p>实现方法如下：</p><pre><code>1、用户中心
try：添加用户，状态为不可用
confifirm：更新用户状态为可用cancel：删除用户

2、统一账号服务
try：添加账号，状态为不可用
confifirm：更新账号状态为可用
cancel：删除账号
</code></pre><h2 id="6-2-存管开户"><a href="#6-2-存管开户" class="headerlink" title="6.2. 存管开户"></a>6.2. 存管开户</h2><h3 id="6-2-1-业务流程"><a href="#6-2-1-业务流程" class="headerlink" title="6.2.1. 业务流程"></a>6.2.1. 业务流程</h3><p>根据政策要求，P2P 业务必须让银行存管资金，用户的资金在银行存管系统的账户中，而不在 P2P 平台中，因此用户要在银行存管系统开户。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230101132601.png"><br>用户向用户中心提交开户资料，用户中心生成开户请求号并重定向至银行存管系统开户页面。用户设置存管密码并确认开户后，银行存管立即返回“请求已受理”。在某一时刻，银行存管系统处理完该开户请求后，将调用回调地址 通知处理结果，若通知失败，则按一定策略重试通知。同时，银行存管系统应提供开户结果查询的接口，供用户中心校对结果。</p><h3 id="6-2-2-解决方案分析"><a href="#6-2-2-解决方案分析" class="headerlink" title="6.2.2. 解决方案分析"></a>6.2.2. 解决方案分析</h3><p>P2P 平台的用户中心与银行存管系统之间属于跨系统交互，银行存管系统属于外部系统，用户中心无法干预银行存管系统，所以用户中心只能在收到银行存管系统的业务处理结果通知后积极处理，开户后的使用情况完全由用户中心来控制。 根据上述需求进行解决方案分析：</p><p><strong>1、采用 Seata 实现 2PC</strong></p><p>需要侵入银行存管系统的数据库，由于它是外部系统，所以不适用。</p><p><strong>2、采用 Hmily 实现 TCC</strong></p><p>TCC 侵入性更强，所以不适用。</p><p><strong>3、基于 MQ 的可靠消息一致性</strong></p><p>如果让银行存管系统监听 MQ 则不合适 ，因为它是外部系统。</p><p>如果银行存管系统将消息发给 MQ 用户中心监听 MQ 是可以的，但是由于相对银行存管系统来说用户中心属于外部系统，银行存管系统是不会让外部系统直接监听自己的 MQ 的，基于 MQ 的通信协议也不方便外部系统间的交互，</p><p>所以本方案不合适。</p><p><strong>4、最大努力通知方案</strong></p><p>银行存管系统内部使用 MQ，银行存管系统处理完业务后将处理结果发给 MQ，由银行存管的通知程序专门发送通知，并且采用互联网协议通知给第三方系统（用户中心）。</p><p>下图中发起通知即银行存管系统：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230101133303.png"></p><h2 id="6-3-满标审核"><a href="#6-3-满标审核" class="headerlink" title="6.3. 满标审核"></a>6.3. 满标审核</h2><h3 id="6-3-1-业务流程"><a href="#6-3-1-业务流程" class="headerlink" title="6.3.1. 业务流程"></a>6.3.1. 业务流程</h3><p>在借款人标的募集够所有的资金后，P2P 运营管理员审批该标的，触发放款，并开启还款流程。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230101133538.png"></p><h3 id="6-3-2-解决方案分析"><a href="#6-3-2-解决方案分析" class="headerlink" title="6.3.2. 解决方案分析"></a>6.3.2. 解决方案分析</h3><p>生成还款计划是一个执行时长较长的业务，不建议阻塞主业务流程，此业务对一致性要求较低。</p><p>根据上述需求进行解决方案分析：</p><p><strong>1、采用 Seata 实现 2PC</strong></p><p>Seata 在事务执行过程会进行数据库资源锁定，由于事务执行时长较长会将资源锁定较长时间，所以不适用。</p><p><strong>2、采用 Hmily 实现 TCC</strong></p><p>本需求对业务一致性要求较低，因为生成还款计划的时长较长，所以不要求交易中心修改标的状态为“还款中”就立即生成还款计划 ，所以本方案不适用。</p><p><strong>3、基于 MQ 的可靠消息一致性</strong></p><p>满标审批通过后由交易中心修改标的状态为“还款中”并且向还款服务发送消息，还款服务接收到消息开始生成还款计划，基本于 MQ 的可靠消息一致性方案适用此场景</p><p><strong>4、最大努力通知方案</strong></p><p>满标审批通过后由交易中心向还款服务发送通知要求生成还款计划，还款服务并且对外提供还款计划生成结果校对接口供其它服务查询，最大努力 通知方案也适用本场景 。</p><h1 id="7-参考与感谢"><a href="#7-参考与感谢" class="headerlink" title="7. 参考与感谢"></a>7. 参考与感谢</h1><h2 id="7-1-黑马"><a href="#7-1-黑马" class="headerlink" title="7.1. 黑马"></a>7.1. 黑马</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FJ411A7mV?p=7&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1FJ411A7mV?p=7&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;005-分布式专题&#x2F;黑马资料-分布式事务&#x2F;day2&#x2F;资料&#x2F;分布式事务专题-v1.1.pdf]]</p><p>事务，事务隔离级别，spring 事务配置，spring 事务的传播特性 - 阿里巴巴面试题，面试题系列（十）</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EE411p7dD?from=search&seid=11104488055930606136&spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1EE411p7dD?from=search&seid=11104488055930606136&spm_id_from&#x3D;333.337.0.0</a></p><h2 id="7-2-分布式事务"><a href="#7-2-分布式事务" class="headerlink" title="7.2. 分布式事务"></a>7.2. 分布式事务</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20201006104810317.png" alt="image-20201006104810317"></p><p>【黑马】分布式事务解决方案专题</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FJ411A7mV/?spm_id_from=autoNext">https://www.bilibili.com/video/BV1FJ411A7mV/?spm_id_from&#x3D;autoNext</a></p><p>Java 事务的类型有三种：JDBC 事务、JTA(Java Transaction API) 事务、容器事务，其中 JDBC 的事务操作用法比较简单，适合于处理同一个数据源的操作。JTA 事务相对复杂，可以用于处理跨多个数据库的事务，是分布式事务的一种解决方案。</p><p>这里还要简单说一下，虽然 JTA 事务是 Java 提供的可用于分布式事务的一套 API，但是不同的 J2EE 平台的实现都不一样，并且都不是很方便使用，所以，一般在项目中不太使用这种较为复杂的 API。现在业内比较常用的分布式事务解决方案主要有异步消息确保型、TCC、最大努力通知等。</p><p>[[..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;cubox&#x2F;006-ChromeCapture&#x2F;【十九】Spring Boot之分布式事务(JTA、Atomikos、Druid、Mybatis)_jy02268879的博客-CSDN博客]]</p><h2 id="7-3-尚硅谷-谷粒商城"><a href="#7-3-尚硅谷-谷粒商城" class="headerlink" title="7.3. 尚硅谷 - 谷粒商城"></a>7.3. 尚硅谷 - 谷粒商城</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1np4y1C7Yf?p=288&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1np4y1C7Yf?p=288&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="7-4-Seata-整合-Oracle"><a href="#7-4-Seata-整合-Oracle" class="headerlink" title="7.4. Seata 整合 Oracle"></a>7.4. Seata 整合 Oracle</h2><p>官网：<a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><p>下载：<a target="_blank" rel="noopener" href="https://github.com/seata/seata/tags">https://github.com/seata/seata/tags</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27699835/article/details/107663452">https://blog.csdn.net/qq_27699835&#x2F;article&#x2F;details&#x2F;107663452</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f5bdec291e63">https://www.jianshu.com/p/f5bdec291e63</a> <a target="_blank" rel="noopener" href="https://github.com/majiajue/seata_oracle">https://github.com/majiajue/seata_oracle</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">https://taylorluo.github.io/2022/12/29/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E4%BA%8B%E5%8A%A1-2%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/justlovesmile-img/cover3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/31/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-MQ-RocketMQ-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="https://picsum.photos/1920/912" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-RocketMQ-1、基本原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/26/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-4%E3%80%81%E6%B3%9B%E5%9E%8B/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover8.JPG" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础-基本原理-4、泛型</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1. 是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2. 产生的场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="toc-text">3. 基础理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-CAP-%E7%90%86%E8%AE%BA"><span class="toc-text">3.1. CAP 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-CAP-%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1.1. CAP 组合方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%80%BB%E7%BB%93"><span class="toc-text">3.1.2. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-BASE-%E7%90%86%E8%AE%BA"><span class="toc-text">3.2. BASE 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">3.2.1. 强一致性和最终一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-Base-%E7%90%86%E8%AE%BA"><span class="toc-text">3.2.2. Base 理论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4. 分布式事务解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-2PC"><span class="toc-text">4.1. 2PC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E4%BB%80%E4%B9%88%E6%98%AF-2PC"><span class="toc-text">4.1.1. 什么是 2PC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-2PC-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">4.1.2. 2PC 实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-1-XA-%E6%96%B9%E6%A1%88"><span class="toc-text">4.1.2.1. XA 方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-1-1-DTP-%E6%A8%A1%E5%9E%8B%E8%A7%92%E8%89%B2"><span class="toc-text">4.1.2.1.1. DTP 模型角色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-1-2-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B"><span class="toc-text">4.1.2.1.2. 执行流程如下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-1-3-XA-%E6%96%B9%E6%A1%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">4.1.2.1.3. XA 方案的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-2-Seata-%E6%96%B9%E6%A1%88"><span class="toc-text">4.1.2.2. Seata 方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-1-%E4%BB%80%E4%B9%88%E6%98%AF-Seata"><span class="toc-text">4.1.2.2.1. 什么是 Seata</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-2-Seata-%E5%8E%9F%E7%90%86"><span class="toc-text">4.1.2.2.2. Seata 原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-3-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">4.1.2.2.3. 流程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-4-%E4%BC%A0%E7%BB%9F-2PC-%E7%9A%84%E5%B7%AE%E5%88%AB%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.1.2.2.4. 传统 2PC 的差别⭐️🔴</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-5-%E4%BD%BF%E7%94%A8%E8%A6%81%E7%B4%A0"><span class="toc-text">4.1.2.2.5. 使用要素</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-TCC"><span class="toc-text">4.2. TCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E4%BB%80%E4%B9%88%E6%98%AF-TCC-%E4%BA%8B%E5%8A%A1"><span class="toc-text">4.2.1. 什么是 TCC 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-TCC-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E5%88%AB%E6%98%AF%E7%A9%BA%E5%9B%9E%E6%BB%9A%E3%80%81%E5%B9%82%E7%AD%89%E3%80%81%E6%82%AC%E6%8C%82"><span class="toc-text">4.2.2. TCC 需要注意三种异常处理分别是空回滚、幂等、悬挂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-1-%E7%A9%BA%E5%9B%9E%E6%BB%9A"><span class="toc-text">4.2.2.1. 空回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2-%E5%B9%82%E7%AD%89"><span class="toc-text">4.2.2.2. 幂等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-3-%E6%82%AC%E6%8C%82"><span class="toc-text">4.2.2.3. 悬挂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.2.3. 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-Hmily"><span class="toc-text">4.2.4. 使用案例 Hmily</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">4.3. 可靠消息最终一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-text">4.3.1. 可靠消息最终一致性事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4.3.2. 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-1-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E6%96%B9%E6%A1%88"><span class="toc-text">4.3.2.1. 本地消息表方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-2-RocketMQ"><span class="toc-text">4.3.2.2. RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2-1-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.3.2.2.1. 事务消息是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2-2-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">4.3.2.2.2. 执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.3.2.2.3. 小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-text">4.4. 最大努力通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.4.1. 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4.4.2. 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-1-%E6%96%B9%E6%A1%88-1-%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E5%BA%94%E7%94%A8"><span class="toc-text">4.4.2.1. 方案 1- 企业内部应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-2-%E6%96%B9%E6%A1%88-2-%E9%80%9A%E7%9F%A5%E5%A4%96%E9%83%A8%E5%BA%94%E7%94%A8"><span class="toc-text">4.4.2.2. 方案 2- 通知外部应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E4%B8%80%E8%87%B4%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">4.4.3. 最大努力通知与可靠消息一致性有什么不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5. 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">6. 实战经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">6.1. 注册账号案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">6.1.1. 业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">6.1.2. 解决方案分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%AD%98%E7%AE%A1%E5%BC%80%E6%88%B7"><span class="toc-text">6.2. 存管开户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">6.2.1. 业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">6.2.2. 解决方案分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%BB%A1%E6%A0%87%E5%AE%A1%E6%A0%B8"><span class="toc-text">6.3. 满标审核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">6.3.1. 业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-text">6.3.2. 解决方案分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">7. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E9%BB%91%E9%A9%AC"><span class="toc-text">7.1. 黑马</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">7.2. 分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E"><span class="toc-text">7.3. 尚硅谷 - 谷粒商城</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Seata-%E6%95%B4%E5%90%88-Oracle"><span class="toc-text">7.4. Seata 整合 Oracle</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://unpkg.com/justlovesmile-img/cover3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>