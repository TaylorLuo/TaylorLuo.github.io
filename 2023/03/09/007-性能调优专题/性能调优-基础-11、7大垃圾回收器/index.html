<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>性能调优专题-基础-11、7大垃圾回收器 | Taylor</title><meta name="keywords" content="timeline"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 默认回收器● 1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本● 2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·● Parallel GC 在 JDK6 之后成为 HotSpot 默认 G"><meta property="og:type" content="article"><meta property="og:title" content="性能调优专题-基础-11、7大垃圾回收器"><meta property="og:url" content="https://taylorluo.github.io/2023/03/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-11%E3%80%817%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 默认回收器● 1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本● 2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·● Parallel GC 在 JDK6 之后成为 HotSpot 默认 G"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/942"><meta property="article:published_time" content="2023-03-09T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.718Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="timeline"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/942"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/03/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-11%E3%80%817%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"性能调优专题-基础-11、7大垃圾回收器",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/942')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">性能调优专题-基础-11、7大垃圾回收器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-09T16:00:00.000Z" title="发表于 2023-03-10 00:00:00">2023-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.718Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="性能调优专题-基础-11、7大垃圾回收器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/03/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-11%E3%80%817%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307114308.png" alt="image.png"></p><h1 id="1-默认回收器"><a href="#1-默认回收器" class="headerlink" title="1. 默认回收器"></a>1. 默认回收器</h1><p>● 1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本<br>● 2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·<br>● Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。<br>● <span style="background-color:#0f0">2012 年，在 JDK1.7u4 版本中，G1 可用。</span><br>● <span style="background-color:#f0f">2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</span><br>● 2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。<br>● 2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）<br>● 2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·<br>● 2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。<br>● 2020 年 3 月，JDK14 发布。<span style="background-color:red">删除 CMS 垃圾回收器</span>。扩展 ZGC 在 macos 和 Windows 上的应用</p><h2 id="1-1-发展历史"><a href="#1-1-发展历史" class="headerlink" title="1.1. 发展历史"></a>1.1. 发展历史</h2><p>UseParallelGC: 并行垃圾收集器</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108173944.jpg" alt="image-20200410104929436"></p><h2 id="1-2-回收器分类"><a href="#1-2-回收器分类" class="headerlink" title="1.2. 回收器分类"></a>1.2. 回收器分类</h2><h3 id="1-2-1-按线程数分"><a href="#1-2-1-按线程数分" class="headerlink" title="1.2.1. 按线程数分"></a>1.2.1. 按线程数分</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307150020.png" alt="image.png"></p><p>串行回收指的是在同一时间段内<span style="background-color:#f0f">只允许有一个 CPU 用于执行垃圾回收操作</span>，此时工作线程被暂停，直至垃圾收集工作结束。比如早期的 Serial GC 和 Serial Old GC。</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中</li><li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。比如 ParNew、Parallel Scavenge GC、Parallel Old GC</p><h3 id="1-2-2-按工作模式分"><a href="#1-2-2-按工作模式分" class="headerlink" title="1.2.2. 按工作模式分"></a>1.2.2. 按工作模式分</h3><p>可以分为并发式垃圾回收器和独占式垃圾回收器。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307150311.png" alt="image.png"></p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul><h3 id="1-2-3-按碎片处理方式分"><a href="#1-2-3-按碎片处理方式分" class="headerlink" title="1.2.3. 按碎片处理方式分"></a>1.2.3. 按碎片处理方式分</h3><p>可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><h3 id="1-2-4-按工作内存区间分"><a href="#1-2-4-按工作内存区间分" class="headerlink" title="1.2.4. 按工作内存区间分"></a>1.2.4. 按工作内存区间分</h3><p>可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h3 id="1-2-5-按分代模型分"><a href="#1-2-5-按分代模型分" class="headerlink" title="1.2.5. 按分代模型分"></a>1.2.5. 按分代模型分</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230309191744.png" alt="image.png"></p><h2 id="1-3-查看方法"><a href="#1-3-查看方法" class="headerlink" title="1.3. 查看方法"></a>1.3. 查看方法</h2><p>java -XX：+PrintCommandLineFlags -version</p><h2 id="1-4-组合方式⭐️🔴"><a href="#1-4-组合方式⭐️🔴" class="headerlink" title="1.4. 组合方式⭐️🔴"></a>1.4. 组合方式⭐️🔴</h2><p><span style="display:none">%%<br>▶20.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1729%%</span>❕ ^m3ftuh</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av75859780?p=984">https://www.bilibili.com/video/av75859780?p=984</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108173954.jpg" alt="image-20200324205304809"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307114308.png" alt="image.png"></p><p><span style="display:none">%%<br>▶9.🏡⭐️◼️【JDK8 的默认垃圾回收器是 Parallel Scavenge GC + Parallel Old GC】◼️⭐️-point-20230307-1144%%</span>❕ ^w7k0dt</p><p><span style="background-color:#f0f">由于 CMS 在 JDK14 后被移除，所以可用组合只剩蓝色①和③了</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305163450.png" alt="image.png"></p><p>搭配疑问❓CMS 为何不能跟 Parallel Scavenge GC 进行搭配<br><span style="background-color:#f0f">是因为 Parallel Scavenge 没有使用 HotSpot 原本通用的 GC 框架，所以不能跟使用了通用 GC 框架的 CMS 搭配使用。</span></p><h1 id="2-Serial"><a href="#2-Serial" class="headerlink" title="2. Serial"></a>2. Serial</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305205633.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174105.jpg" alt="image-20200324211250674"></p><p>Serial 收集器采用<span style="background-color:#0f0">复制算法</span>、串行回收和 “stop-the-World” 机制的方式执行内存回收。<br>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和 “Stop the World” 机制，只不过内存回收算法使用的是<span style="background-color:#0f0">标记 - 压缩算法</span>。</p><ul><li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial 0ld 在 Server 模式下主要有两个用途：<br>① 与新生代的 Parallel scavenge 配合使用<br>② 作为老年代 CMS 收集器的后备垃圾收集方案</li></ul><h1 id="3-Parnew"><a href="#3-Parnew" class="headerlink" title="3. Parnew"></a>3. Parnew</h1><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，<span style="background-color:#f0f">New：只能处理的是新生代</span>。可以组合 CMS 和 SerialOld，CMS 在 JDK14 中已经删除，而 SerialOld 适合单核场景，所以 ParNew 基本边缘化了。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174114.jpg" alt="image-20200324211645935"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174123.jpg" alt="image-20200324212106542"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305205403.png" alt="image.png"></p><h1 id="4-Parallel-Scavenge-【高吞吐】"><a href="#4-Parallel-Scavenge-【高吞吐】" class="headerlink" title="4. Parallel Scavenge- 【高吞吐】"></a>4. Parallel Scavenge- 【高吞吐】</h1><p>高性能场景下，是串行收集器在新生代和老年代的并行化。所有新生代都是复制算法，PreallelScavenge 也不例外。老年代配合 ParallelOldGC，也可以配合 SerialOldGC，2 个都是标记整理算法。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305205331.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174141.jpg" alt="image-20200324213249966"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221208145803.png"></p><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和 “Stop the World” 机制。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><p>● 和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到<span style="background-color:#f0f">一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</span><br>● 自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</p><p>高吞吐量则可以<span style="background-color:#0f0">高效率地利用 CPU 时间，尽快完成程序的运算任务</span>，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些<span style="background-color:#0f0">执行批量处理、订单处理、工资支付、科学计算的应用程序</span>。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。<br>Parallel Old 收集器采用了标记 - 压缩算法，但同样也是基于并行回收和 “Stop-the-World” 机制。</p><h2 id="4-1-参数配置"><a href="#4-1-参数配置" class="headerlink" title="4.1. 参数配置"></a>4.1. 参数配置</h2><p><span style="display:none">%%<br>▶12.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230306-0712%%</span>❕ ^e8ztve</p><p>● -XX:+UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。<br>● -XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器。<br>○ 分别适用于新生代和老年代。默认 jdk8 是开启的。<br>○ 上面两个参数，默认开启一个，另一个也会被开启。（互相激活）<br>● <code>-XX:ParallelGCThreads</code> <span style="background-color:#f0f">设置年轻代并行收集器的线程数</span>。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>$ParallelGCThreads &#x3D; \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;&#x3D; 8) \ 3 + (5 * CPU＿Count &#x2F; 8) &amp; \text (CPU_Count &gt; 8) \end{cases}$</p><p><span style="background-color:#0f0">大于 8，比如 12 个，得出结果为 10 个</span> <span style="display:none">%%<br>▶8.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230308-0729%%</span>❕ ^qrcauu</p><p>● <code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。<br>○ 为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。<br>○ 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。<br>○ <span style="background-color:red">-XX:MaxGCPauseMillis 使用需谨慎。</span><br>● <code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（&#x3D;1&#x2F;（N+1））。用于衡量吞吐量的大小。<br>○ 取值范围（0, 100）。<span style="background-color:#f0f">默认值 99，也就是垃圾回收时间不超过 1%。</span><br>○ 与前一个 -XX:MaxGCPauseMillis 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。<br>● <code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有自适应调节策略<br>○ 在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。<br>○ 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</p><h1 id="5-CMS-【低延迟】"><a href="#5-CMS-【低延迟】" class="headerlink" title="5. CMS- 【低延迟】"></a>5. CMS- 【低延迟】</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221208153949.png"></p><h2 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1. 特点"></a>5.1. 特点</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款<span style="background-color:#f0f">真正意义上的并发收集器</span>，<span style="background-color:#f0f">它第一次实现了让垃圾收集线程与用户线程同时工作。</span></p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>● 目前很大一部分的 Java 应用集中在互联网站或者 B&#x2F;S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</p><p>CMS 的垃圾收集算法采用<span style="background-color:#f0f">标记 - 清除算法</span>，并且也会 “Stop-the-World”</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><h2 id="5-2-回收逻辑"><a href="#5-2-回收逻辑" class="headerlink" title="5.2. 回收逻辑"></a>5.2. 回收逻辑</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174200.jpg" alt="image-20200324221224514"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174209.jpg" alt="image-20200324221611386"></p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><p>● 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将<span style="background-color:#ff0">会因为“Stop-the-World”机制而出现短暂的暂停</span>，这个阶段的主要任务仅仅只是标记出 <span style="background-color:red">GCRoots 能直接关联到的对象</span>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，<span style="background-color:#ff0">所以这里的速度非常快</span>。<br>● 并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<span style="background-color:#f0f">不需要停顿用户线程</span>，可以与垃圾收集线程一起并发运行。<br>● 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此<span style="background-color:#0f0">为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</span>，<span style="background-color:#ff0">这个阶段的“Stop-the-World”停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</span><br>● 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p><h2 id="5-3-优缺点"><a href="#5-3-优缺点" class="headerlink" title="5.3. 优缺点"></a>5.3. 优缺点</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230306-0559%%</span>❕ ^d6te2p</p><h3 id="5-3-1-优点"><a href="#5-3-1-优点" class="headerlink" title="5.3.1. 优点"></a>5.3.1. 优点</h3><p>停顿短，<span style="background-color:#0f0">由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</span></p><p>尽管 CMS 收集器采用的是并发回收（非独占式），<span style="background-color:red">但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</span></p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，<span style="background-color:#f0f">还应该确保应用程序用户线程有足够的内存可用</span>。因此，CMS 收集器<span style="background-color:#0f0">不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</span> <span style="background-color:red">要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</span></p><h3 id="5-3-2-缺点"><a href="#5-3-2-缺点" class="headerlink" title="5.3.2. 缺点"></a>5.3.2. 缺点</h3><p><span style="display:none">%%<br>▶70.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230307-1623%%</span>❕</p><p>● <span style="background-color:#f0f">会产生内存碎片</span>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。<br>● CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，<span style="background-color:#f0f">总吞吐量会降低</span>。<br>● <span style="background-color:#f0f">CMS 收集器无法处理浮动垃圾</span>。可能出现“Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<span style="background-color:red">在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间</span>。❕<span style="display:none">%%<br>▶69.🏡⭐️◼️浮动垃圾 ?🔜MSTM📝 在并发阶段产生的垃圾，在重新标记阶段无法识别出来，只能等到下一次 GC 才能被清除◼️⭐️-point-20230307-1548%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174219.jpg" alt="image-20200324221406359"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174231.jpg" alt="image-20200324221443257"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221208153827.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221208160301.png"></p><h2 id="5-4-参数设置⭐️🔴"><a href="#5-4-参数设置⭐️🔴" class="headerlink" title="5.4. 参数设置⭐️🔴"></a>5.4. 参数设置⭐️🔴</h2><p><span style="display:none">%%<br>▶5.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230427-1826%%</span>❕ ^yfbdrc</p><p>● <code>-XX:+UseConcMarkSweepGC</code> 手动指定使用 CMS 收集器执行内存回收任务。<br>开启该参数后会自动将 -xx:+UseParNewGC 打开。即：<span style="background-color:#f0f">ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合</span>。<br>● <code>-XX:CMSInitiatingOccupancyFraction</code> <span style="background-color:#f0f">设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</span><br><span style="display:none">%%<br>▶7.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230311-1110%%</span>❕ ^eklrte<br>○ JDK5 及以前版本的默认值为 68，即<span style="background-color:red">当老年代的空间使用率</span>达到<span style="background-color:#f0f">68%</span>时，会执行一次 CMS 回收。JDK6 及以上版本默认值为<span style="background-color:#f0f">92%</span><br>○ <span style="background-color:#0f0">如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 FullGC 的执行次数。</span><br>● <code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。<br>● <code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。<br>● -XX:ParallelcMSThreads 设置 CMS 的线程数量。<br>○ CMS 默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h2 id="5-5-详细阶段"><a href="#5-5-详细阶段" class="headerlink" title="5.5. 详细阶段"></a>5.5. 详细阶段</h2><p>CMS 垃圾回收的 6 个重要阶段</p><p>initial-mark 初始标记（CMS 的第一个 STW 阶段），标记 GC Root 直接引用的对象，GC Root 直接引用的对象不多，所以很快。<br>concurrent-mark 并发标记阶段，由第一阶段标记过的对象出发，所有可达的对象都在本阶段标记。<br><strong>concurrent-preclean 并发预清理阶段</strong>，也是一个并发执行的阶段。在本阶段，会查找前一阶段执行过程中, 从新生代晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个 stop-the-world<br>重新标记阶段的工作量。<br><strong>concurrent-abortable-preclean 并发可中止的预清理阶段</strong>。这个阶段其实跟上一个阶段做的东西一样，也是为了减少下一个 STW 重新标记阶段的工作量。增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认 5 秒）或者 Eden 区使用占比达到期望比例（默认 50%）就结束本阶段。<br>remark 重标记阶段（CMS 的第二个 STW 阶段），暂停所有用户线程，从 GC Root 开始重新扫描整堆，标记存活的对象。需要注意的是，虽然 CMS 只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，因为很多 GC<br>Root 都在新生代，而这些 GC Root 指向的对象又在老年代，这称为“跨代引用”。<br>concurrent-sweep ，并发清理。原文链接： <a target="_blank" rel="noopener" href="https://blog.csdn.net/flysqrlboy/article/details/88679457">https://blog.csdn.net/flysqrlboy/article/details/88679457</a><br>-XX:CMSMaxAbortablePrecleanTime&#x3D;5000 ，默认值 5s，代表该阶段最大的持续时间（第四阶段）</p><h1 id="6-G1"><a href="#6-G1" class="headerlink" title="6. G1"></a>6. G1</h1><h2 id="6-1-特点"><a href="#6-1-特点" class="headerlink" title="6.1. 特点"></a>6.1. 特点</h2><h3 id="6-1-1-并行与并发"><a href="#6-1-1-并行与并发" class="headerlink" title="6.1.1. 并行与并发"></a>6.1.1. 并行与并发</h3><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><h3 id="6-1-2-也是分代型垃圾回收器"><a href="#6-1-2-也是分代型垃圾回收器" class="headerlink" title="6.1.2. 也是分代型垃圾回收器"></a>6.1.2. 也是分代型垃圾回收器</h3><ul><li>从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，<span style="background-color:#f0f">它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</span>。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307172542.png" alt="image.png"></p><h3 id="6-1-3-空间整合"><a href="#6-1-3-空间整合" class="headerlink" title="6.1.3. 空间整合"></a>6.1.3. 空间整合</h3><ul><li>CMS：“标记 - 清除”算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。</li></ul><p><span style="background-color:#f0f">Region 之间是复制算法，但整体上实际可看作是标记 - 压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</span></p><h3 id="6-1-4-可预测的停顿时间模型（软实时-soft-real-time）"><a href="#6-1-4-可预测的停顿时间模型（软实时-soft-real-time）" class="headerlink" title="6.1.4. 可预测的停顿时间模型（软实时 soft real-time）"></a>6.1.4. 可预测的停顿时间模型（软实时 soft real-time）</h3><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMS，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h2 id="6-2-CMS-对比"><a href="#6-2-CMS-对比" class="headerlink" title="6.2. CMS 对比"></a>6.2. CMS 对比</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174308.jpg" alt="image-20200402112557923"></p><h2 id="6-3-优点"><a href="#6-3-优点" class="headerlink" title="6.3. 优点"></a>6.3. 优点</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174316.jpg" alt="image-20200324223211928"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174324.jpg" alt="image-20200402111808637"></p><h2 id="6-4-缺点"><a href="#6-4-缺点" class="headerlink" title="6.4. 缺点"></a>6.4. 缺点</h2><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p><span style="background-color:#f0f">从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</span></p><h2 id="6-5-参数设置⭐️🔴"><a href="#6-5-参数设置⭐️🔴" class="headerlink" title="6.5. 参数设置⭐️🔴"></a>6.5. 参数设置⭐️🔴</h2><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。<span style="background-color:#f0f">默认是堆内存的 1&#x2F;2000。</span> ^pcgqi8</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。<span style="background-color:#f0f">默认值是 200ms（人的平均反应速度）</span></li><li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1&#x2F;4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 <span style="background-color:#f0f">Java 堆占用率阈值</span>。超过此值，就触发 GC。默认值是 **45%**。CMS 中占用率阈值是看<span style="background-color:#f0f">老年代的占用</span> JDK5 是 68%，JDK6 及以上为 92%。 ^6qnxn7</li></ul><h3 id="6-5-1-到底是整堆还是老年代⭐️🔴"><a href="#6-5-1-到底是整堆还是老年代⭐️🔴" class="headerlink" title="6.5.1. 到底是整堆还是老年代⭐️🔴"></a>6.5.1. 到底是整堆还是老年代⭐️🔴</h3><p><a target="_blank" rel="noopener" href="https://doudaxia.club/index.php/archives/212/">https://doudaxia.club/index.php/archives/212/</a></p><p>如果你使用的 JDK 版本在 8b12 之前，那么文章开头的第一种说法是正确的，即 XX:InitiatingHeapOccupancyPercent 是<span style="background-color:#f0f">整堆使用量</span>与堆总体容量的比值；<br>如果你使用的 JDK 版本在 8b12 之后（包括大版本 9、10、11….），那么文章开头第二种说法是正确的，即 XX:InitiatingHeapOccupancyPercent 是<span style="background-color:red">老年代大小</span>与堆总体容量的比值。</p><p>CMS 的老年代阈值 <code>-XX:CMSInitiatingOccupancyFraction</code> 没有争议，就是老年代的使用率超过该阈值就触发</p><h2 id="6-6-回收过程⭐️🔴"><a href="#6-6-回收过程⭐️🔴" class="headerlink" title="6.6. 回收过程⭐️🔴"></a>6.6. 回收过程⭐️🔴</h2><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230310085733.png" alt="image.png"></p><p><span style="background-color:#0f0">- 年轻代 GC（Young GC）</span><br><span style="background-color:#0f0">- 老年代并发标记过程（Concurrent Marking）</span><br><span style="background-color:#0f0">- 混合回收（Mixed GC）</span><br><span style="background-color:red">（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</span></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的 Eden 区用尽时开始年轻代回收过程；G1 的年轻代收集阶段是一个<span style="background-color:#f0f">并行的独占式收集器</span>。<span style="background-color:#0f0">在年轻代回收期，G1 GC 暂停所有应用程序线程，启动多线程执行年轻代回收。</span>然后从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当<span style="background-color:#f0f">堆内存</span>使用达到一定值（<span style="background-color:#0f0">默认 45%</span>）时，开始老年代<span style="background-color:#f0f">并发标记过程</span>。<span style="background-color:red">并且标记完成马上开始混合回收过程。</span></p><p>对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的<span style="background-color:#f0f">老年代回收器不需要整个老年代被回收</span>，一次只需要扫描&#x2F;回收一小部分老年代的 Region 就可以了。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="6-6-1-年轻代-GC-STW-所有-ES-区"><a href="#6-6-1-年轻代-GC-STW-所有-ES-区" class="headerlink" title="6.6.1. 年轻代 GC-STW-所有 ES 区"></a>6.6.1. 年轻代 GC-STW-所有 ES 区</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，<span style="background-color:#f0f">当 Eden 空间耗尽时</span>，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p><span style="background-color:#f0f">首先 G1 停止应用程序的执行（Stop-The-World）</span>，G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230310090813.png" alt="image.png"></p><h3 id="6-6-2-年轻代-GC-老年代并发标记"><a href="#6-6-2-年轻代-GC-老年代并发标记" class="headerlink" title="6.6.2. 年轻代 GC+ 老年代并发标记"></a>6.6.2. 年轻代 GC+ 老年代并发标记</h3><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li>根区域扫描（Root Region Scanning）：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 YoungGC 之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。<span style="background-color:red">这个阶段并不会实际上去做垃圾的收集</span></li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="6-6-3-混合回收"><a href="#6-6-3-混合回收" class="headerlink" title="6.6.3. 混合回收"></a>6.6.3. 混合回收</h3><p>当越来越多的对象晋升到老年代 old region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，<span style="background-color:#f0f">该算法并不是一个 Old GC，除了回收整个 Young Region</span>，还会<span style="background-color:red">回收一部分的 Old Region</span>。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><h2 id="6-7-补充逻辑"><a href="#6-7-补充逻辑" class="headerlink" title="6.7. 补充逻辑"></a>6.7. 补充逻辑</h2><h3 id="6-7-1-内存碎片"><a href="#6-7-1-内存碎片" class="headerlink" title="6.7.1. 内存碎片"></a>6.7.1. 内存碎片</h3><p><strong>内存碎片解决办法：小区域收集 + 形成连续的内存块</strong></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174344.jpg" alt="image-20200402112031488"></p><h3 id="6-7-2-记忆集和写屏障"><a href="#6-7-2-记忆集和写屏障" class="headerlink" title="6.7.2. 记忆集和写屏障"></a>6.7.2. 记忆集和写屏障</h3><p><span style="display:none">%%<br>▶32.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨♨️⭐️】◼️⭐️-point-20230310-1739%%</span>❕ ^y2fepk</p><a href="/2023/03/10/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-12%E3%80%81GC-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/" title="性能调优-基础-12、GC-三色标记算法">性能调优-基础-12、GC-三色标记算法</a><h2 id="6-8-开启方法"><a href="#6-8-开启方法" class="headerlink" title="6.8. 开启方法"></a>6.8. 开启方法</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174402.jpg" alt="image-20200324234009052"></p><h2 id="6-9-优化特性"><a href="#6-9-优化特性" class="headerlink" title="6.9. 优化特性"></a>6.9. 优化特性</h2><p><span style="display:none">%%<br>▶35.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230310-1749%%</span>❕ ^d8zp7j</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP?p=79">https://www.bilibili.com/video/BV1yE411Z7AP?p=79</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174412.jpg" alt="image-20200402132839496"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174420.jpg" alt="image-20200402133232905"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174429.jpg" alt="image-20200402133425862"></p><h2 id="6-10-G1-收集器的适用场景"><a href="#6-10-G1-收集器的适用场景" class="headerlink" title="6.10. G1 收集器的适用场景"></a>6.10. G1 收集器的适用场景</h2><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）<br>最主要的应用是<span style="background-color:#f0f">需要低 GC 延迟，并具有大堆的应用程序</span>提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p><p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p><ul><li>超过 50% 的 Java 堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul><p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h2 id="6-11-调优建议⭐️🔴"><a href="#6-11-调优建议⭐️🔴" class="headerlink" title="6.11. 调优建议⭐️🔴"></a>6.11. 调优建议⭐️🔴</h2><h3 id="6-11-1-年轻代大小"><a href="#6-11-1-年轻代大小" class="headerlink" title="6.11.1. 年轻代大小"></a>6.11.1. 年轻代大小</h3><p>● 避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小<br>● <span style="background-color:red">固定年轻代的大小会覆盖暂停时间目标</span></p><h3 id="6-11-2-暂停时间目标不要太过严苛"><a href="#6-11-2-暂停时间目标不要太过严苛" class="headerlink" title="6.11.2. 暂停时间目标不要太过严苛"></a>6.11.2. 暂停时间目标不要太过严苛</h3><p>● G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间<br>● <span style="background-color:red">评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</span></p><h3 id="6-11-3-G1-会不会进行-Full-GC"><a href="#6-11-3-G1-会不会进行-Full-GC" class="headerlink" title="6.11.3. G1 会不会进行 Full GC"></a>6.11.3. G1 会不会进行 Full GC</h3><p><span style="display:none">%%<br>▶36.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230310-1825%%</span>❕ ^oq6j20</p><p>会，当内存满了的时候就会进行 <code>Full GC</code>；<span style="background-color:#f0f">且 <code>JDK10</code> 之前的 <code>Full GC</code>，为单线程的</span>，所以使用 G1 需要避免 <code>Full GC</code> 的产生。</p><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？<span style="background-color:red">比如堆内存太小</span>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><h4 id="6-11-3-1-导致原因"><a href="#6-11-3-1-导致原因" class="headerlink" title="6.11.3.1. 导致原因"></a>6.11.3.1. 导致原因</h4><p>导致 G1 Full GC 的原因可能有两个：</p><p><span style="background-color:#f0f">● Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</span><br><span style="background-color:#f0f">● 并发处理过程完成之前空间耗尽。</span></p><h4 id="6-11-3-2-解决方案"><a href="#6-11-3-2-解决方案" class="headerlink" title="6.11.3.2. 解决方案"></a>6.11.3.2. 解决方案</h4><ul><li>加大内存；</li><li>提高 CPU 性能，加快 GC 回收速度，而对象增加速度赶不上回收速度，则 Full GC 可以避免；</li><li><span style="background-color:#f0f">降低老年代并发标记触发的阈值（默认堆使用率为 45%），让 Mixed GC 提早发生</span></li></ul><h3 id="6-11-4-其他案例"><a href="#6-11-4-其他案例" class="headerlink" title="6.11.4. 其他案例"></a>6.11.4. 其他案例</h3><p>首先，建议尽量升级到较新的 JDK 版本，从上面介绍的改进就可以看到，很多人们常常讨论的问题，其实升级 JDK 就可以解决了。</p><p>第二，掌握 GC 调优信息收集途径。掌握尽量全面、详细、准确的信息，是各种调优的基础，不仅仅是 GC 调优。我们来看看打开 GC 日志，这似乎是很简单的事情，可是你确定真的掌握了吗?</p><p>   除了常用的两个选项，</p><p><code> -XX:+PrintGCDetails</code>  -XX:+PrintGCDateStamps&#96;</p><p>还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项:</p><blockquote><p><code>-XX:+PrintAdaptiveSizePolicy</code> &#x2F;&#x2F; 打印 G1 Ergonomics 相关信息</p></blockquote><p>   我们知道 GC 内部一些行为是适应性的触发的，利用 PrintAdaptiveSizePolicy，我们就可以知道为什么 JVM 做出了一些可能我们不希望发生的动作。例如，G1 调优的一个基本建议就是避免进行大量的 Humongous 对象分配，如果 Ergonomics 信息说明发生了这一 点，那么就可以考虑要么增大堆的大小，要么直接将 region 大小提高。</p><p>如果是怀疑出现引用清理不及时的情况，则可以打开下面选项，掌握到底是哪里出现了堆积。</p><blockquote><p><code> -XX:+PrintReferenceGC</code></p></blockquote><p>另外，建议开启选项下面的选项进行并行引用处理。</p><blockquote><p><code>-XX:+ParallelRefProcEnabled</code></p></blockquote><p>   需要注意的一点是，JDK 9 中 JVM 和 GC 日志机构进行了重构，其实我前面提到的 PrintGCDetails 已经被标记为废弃，而 PrintGCDateStamps 已经被移除，指定它会导致 JVM 无法启动。可以使用下面的命令查询新的配置参数。</p><blockquote><p> <code>java -Xlog:help</code></p></blockquote><p> 最后，来看一些通用实践，理解了我前面介绍的内部结构和机制，很多结论就一目了然了，例如:</p><h4 id="6-11-4-1-Young-GC-非常耗时"><a href="#6-11-4-1-Young-GC-非常耗时" class="headerlink" title="6.11.4.1. Young GC 非常耗时"></a>6.11.4.1. Young GC 非常耗时</h4><p>这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。</p><blockquote><p><code>-XX:G1NewSizePercent</code></p></blockquote><p>降低其最大值同样对降低 Young GC 延迟有帮助。</p><blockquote><p><code>-XX:G1MaxNewSizePercent</code></p></blockquote><p>   如果我们直接为 G1 设置较小的延迟目标值，也会起到减小新生代的效果，虽然会影响吞吐量。</p><h4 id="6-11-4-2-Mixed-GC-延迟较长"><a href="#6-11-4-2-Mixed-GC-延迟较长" class="headerlink" title="6.11.4.2. Mixed GC 延迟较长"></a>6.11.4.2. Mixed GC 延迟较长</h4><p>还记得前面说的，部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。</p><p><code>G1OldCSetRegionThresholdPercent</code>：一次 Mixed GC 中能被选入 CSet 的最多 old generation region 数量。**- 减少个数**</p><p>我在上面已经介绍了 G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数提高 Mixed GC 的次数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region 减少，那么数量少了延迟就会相应减少。**- 增加次数**</p><blockquote><p> <code>-XX:G1MixedGCCountTarget</code></p></blockquote><h1 id="7-总结-回收器选择"><a href="#7-总结-回收器选择" class="headerlink" title="7. 总结 - 回收器选择"></a>7. 总结 - 回收器选择</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174440.jpg" alt="image-20200324222211602"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230108174447.jpg" alt="image-20200324222135032"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20221208185015.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307221529.png" alt="image.png"></p><h1 id="8-实战经验"><a href="#8-实战经验" class="headerlink" title="8. 实战经验"></a>8. 实战经验</h1><h1 id="9-参考与感谢"><a href="#9-参考与感谢" class="headerlink" title="9. 参考与感谢"></a>9. 参考与感谢</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/03/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-11%E3%80%817%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">https://taylorluo.github.io/2023/03/09/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-11%E3%80%817%E5%A4%A7%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timeline/">timeline</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/942" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/10/007-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%9F%BA%E7%A1%80-12%E3%80%81GC-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://picsum.photos/1920/1080" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">性能调优专题-基础-12、GC-三色标记算法</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"><img class="next-cover" src="https://picsum.photos/1920/1083" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">架构实战专题-基础-1、架构演进</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-1%E3%80%81%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="计算机基础-基本原理-1、相关名词"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">计算机基础-基本原理-1、相关名词</div></div></a></div><div><a href="/2023/03/27/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/JDK-1%E3%80%81SPI/" title="框架源码专题-JDK-1、SPI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover5.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">框架源码专题-JDK-1、SPI</div></div></a></div><div><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-9%E3%80%81SQL%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/" title="框架源码专题-MySQL-9、SQL应用优化"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">框架源码专题-MySQL-9、SQL应用优化</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/01/22/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-19%E3%80%81Queue/" title="并发编程专题-基础-19、Queue"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">并发编程专题-基础-19、Queue</div></div></a></div><div><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构实战专题-基础-1、架构演进"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">架构实战专题-基础-1、架构演进</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">1. 默认回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-text">1.1. 发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">1.2. 回收器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%8C%89%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%88%86"><span class="toc-text">1.2.1. 按线程数分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%8C%89%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86"><span class="toc-text">1.2.2. 按工作模式分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%8C%89%E7%A2%8E%E7%89%87%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%88%86"><span class="toc-text">1.2.3. 按碎片处理方式分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E6%8C%89%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%86"><span class="toc-text">1.2.4. 按工作内存区间分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E6%8C%89%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B%E5%88%86"><span class="toc-text">1.2.5. 按分代模型分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="toc-text">1.3. 查看方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">1.4. 组合方式⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Serial"><span class="toc-text">2. Serial</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Parnew"><span class="toc-text">3. Parnew</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Parallel-Scavenge-%E3%80%90%E9%AB%98%E5%90%9E%E5%90%90%E3%80%91"><span class="toc-text">4. Parallel Scavenge- 【高吞吐】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">4.1. 参数配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-CMS-%E3%80%90%E4%BD%8E%E5%BB%B6%E8%BF%9F%E3%80%91"><span class="toc-text">5. CMS- 【低延迟】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%89%B9%E7%82%B9"><span class="toc-text">5.1. 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%9B%9E%E6%94%B6%E9%80%BB%E8%BE%91"><span class="toc-text">5.2. 回收逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5.3. 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E4%BC%98%E7%82%B9"><span class="toc-text">5.3.1. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">5.3.2. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.4. 参数设置⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E8%AF%A6%E7%BB%86%E9%98%B6%E6%AE%B5"><span class="toc-text">5.5. 详细阶段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-G1"><span class="toc-text">6. G1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%89%B9%E7%82%B9"><span class="toc-text">6.1. 特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">6.1.1. 并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E4%B9%9F%E6%98%AF%E5%88%86%E4%BB%A3%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">6.1.2. 也是分代型垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E7%A9%BA%E9%97%B4%E6%95%B4%E5%90%88"><span class="toc-text">6.1.3. 空间整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BD%AF%E5%AE%9E%E6%97%B6-soft-real-time%EF%BC%89"><span class="toc-text">6.1.4. 可预测的停顿时间模型（软实时 soft real-time）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-CMS-%E5%AF%B9%E6%AF%94"><span class="toc-text">6.2. CMS 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%BC%98%E7%82%B9"><span class="toc-text">6.3. 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">6.4. 缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.5. 参数设置⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E5%88%B0%E5%BA%95%E6%98%AF%E6%95%B4%E5%A0%86%E8%BF%98%E6%98%AF%E8%80%81%E5%B9%B4%E4%BB%A3%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.5.1. 到底是整堆还是老年代⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.6. 回收过程⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E5%B9%B4%E8%BD%BB%E4%BB%A3-GC-STW-%E6%89%80%E6%9C%89-ES-%E5%8C%BA"><span class="toc-text">6.6.1. 年轻代 GC-STW-所有 ES 区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-%E5%B9%B4%E8%BD%BB%E4%BB%A3-GC-%E8%80%81%E5%B9%B4%E4%BB%A3%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-text">6.6.2. 年轻代 GC+ 老年代并发标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-text">6.6.3. 混合回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E8%A1%A5%E5%85%85%E9%80%BB%E8%BE%91"><span class="toc-text">6.7. 补充逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-text">6.7.1. 内存碎片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-%E8%AE%B0%E5%BF%86%E9%9B%86%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">6.7.2. 记忆集和写屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95"><span class="toc-text">6.8. 开启方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-%E4%BC%98%E5%8C%96%E7%89%B9%E6%80%A7"><span class="toc-text">6.9. 优化特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6.10. G1 收集器的适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.11. 调优建议⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-1-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%A4%A7%E5%B0%8F"><span class="toc-text">6.11.1. 年轻代大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-2-%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%E7%9B%AE%E6%A0%87%E4%B8%8D%E8%A6%81%E5%A4%AA%E8%BF%87%E4%B8%A5%E8%8B%9B"><span class="toc-text">6.11.2. 暂停时间目标不要太过严苛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-3-G1-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C-Full-GC"><span class="toc-text">6.11.3. G1 会不会进行 Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-3-1-%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%9B%A0"><span class="toc-text">6.11.3.1. 导致原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">6.11.3.2. 解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-4-%E5%85%B6%E4%BB%96%E6%A1%88%E4%BE%8B"><span class="toc-text">6.11.4. 其他案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-4-1-Young-GC-%E9%9D%9E%E5%B8%B8%E8%80%97%E6%97%B6"><span class="toc-text">6.11.4.1. Young GC 非常耗时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-4-2-Mixed-GC-%E5%BB%B6%E8%BF%9F%E8%BE%83%E9%95%BF"><span class="toc-text">6.11.4.2. Mixed GC 延迟较长</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93-%E5%9B%9E%E6%94%B6%E5%99%A8%E9%80%89%E6%8B%A9"><span class="toc-text">7. 总结 - 回收器选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">8. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">9. 参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/942')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>