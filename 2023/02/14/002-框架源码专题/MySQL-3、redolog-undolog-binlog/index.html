<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>框架源码专题-MySQL-3、redolog undolog binlog | Taylor</title><meta name="keywords" content="MySQL,日志文件"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 日志流程图 逻辑日志： 可以简单理解为记录的就是 sql 语句。 物理日志：mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。 只有 Redolog 是物理日志，Binlog 和 Undolog 都是逻辑日志。   2. Binlog逻辑日志 2.1. 记录内容 - DDL 和 DMLbinlog 用于记录数据库执行的写入性操作 (DDL 和 DML)信息，以二进制的形"><meta property="og:type" content="article"><meta property="og:title" content="框架源码专题-MySQL-3、redolog undolog binlog"><meta property="og:url" content="https://taylorluo.github.io/2023/02/14/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-3%E3%80%81redolog-undolog-binlog/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. 日志流程图 逻辑日志： 可以简单理解为记录的就是 sql 语句。 物理日志：mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。 只有 Redolog 是物理日志，Binlog 和 Undolog 都是逻辑日志。   2. Binlog逻辑日志 2.1. 记录内容 - DDL 和 DMLbinlog 用于记录数据库执行的写入性操作 (DDL 和 DML)信息，以二进制的形"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/972"><meta property="article:published_time" content="2023-02-14T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.673Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="MySQL"><meta property="article:tag" content="日志文件"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/972"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/02/14/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-3%E3%80%81redolog-undolog-binlog/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"框架源码专题-MySQL-3、redolog undolog binlog",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/972')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">框架源码专题-MySQL-3、redolog undolog binlog</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-14T16:00:00.000Z" title="发表于 2023-02-15 00:00:00">2023-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.673Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="框架源码专题-MySQL-3、redolog undolog binlog"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/02/14/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-3%E3%80%81redolog-undolog-binlog/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><h1 id="1-日志流程图"><a href="#1-日志流程图" class="headerlink" title="1. 日志流程图"></a>1. 日志流程图</h1><ul><li><strong>逻辑日志</strong>： 可以简单理解为记录的就是 sql 语句。</li><li><strong>物理日志</strong>：<code>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。</li><li>只有 Redolog 是物理日志，Binlog 和 Undolog 都是逻辑日志。</li></ul><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230301114657.png" alt="image.png"></p><h1 id="2-Binlog"><a href="#2-Binlog" class="headerlink" title="2. Binlog"></a>2. Binlog</h1><p>逻辑日志</p><h2 id="2-1-记录内容-DDL-和-DML"><a href="#2-1-记录内容-DDL-和-DML" class="headerlink" title="2.1. 记录内容 - DDL 和 DML"></a>2.1. 记录内容 - DDL 和 DML</h2><p><code>binlog</code> 用于记录数据库执行的<span style="background-color:#f0f">写入性操作 (DDL 和 DML)</span>信息，以<span style="background-color:#0f0">二进制的形式</span>保存在磁盘中。<code>binlog</code> 是 <code>mysql</code> 的<span style="background-color:#f0f">逻辑日志</span>，<span style="background-color:#0f0">并且由 <code>Server</code> 层进行记录，使用任何存储引擎的 <code>mysql</code> 数据库都会记录 <code>binlog</code> 日志</span><br>比如 <code>update T set c=c+1 where ID=2;</code> 这条 SQL，redo log 中记录的是 ：<code>xx页号，xx偏移量的数据修改为xxx；</code><span style="background-color:#0f0">binlog 中记录的是：<code>id = 2 这一行的 c 字段 +1</code></span></p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><h2 id="2-2-记录时机-更新完数据页之后"><a href="#2-2-记录时机-更新完数据页之后" class="headerlink" title="2.2. 记录时机 - 更新完数据页之后"></a>2.2. 记录时机 - 更新完数据页之后</h2><p>更新完成之后，事务提交之前，先写入 binlog cache 中<br>提交之后，刷盘到 binlog file 中</p><h2 id="2-3-使用场景"><a href="#2-3-使用场景" class="headerlink" title="2.3. 使用场景"></a>2.3. 使用场景</h2><p>在实际应用中，<code>binlog</code> 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p><ol><li><strong>主从复制</strong> ：在 <code>Master</code> 端开启 <code>binlog</code>，然后将 <code>binlog</code> 发送到各个 <code>Slave</code> 端，<code>Slave</code> 端重放 <code>binlog</code> 从而达到主从数据一致。❕<span style="display:none">%%<br>▶1.🏡⭐️◼️Canal 的使用依赖于主从同步模式，尤其是 Binlog◼️⭐️-point-20230302-0741%%</span><br><span style="background-color:#f0f">变形用法 : Canal</span></li><li><strong>数据恢复</strong> ：通过使用 <code>mysqlbinlog</code> 工具来恢复数据。</li></ol><h2 id="2-4-刷盘时机-cache←前-commit-后→file"><a href="#2-4-刷盘时机-cache←前-commit-后→file" class="headerlink" title="2.4. 刷盘时机 -cache←前 commit 后→file"></a>2.4. 刷盘时机 -cache←前 commit 后→file</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228111521.png" alt="image.png"></p><ul><li> 上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</li><li> 上图的 fsync，才是将数据持久化到磁盘的操作，所以频繁的 fsync 会导致磁盘的 I&#x2F;O 升高<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️binlog 日志记录逻辑 ?🔜MSTM📝 事务发起时，先写入 binlog cache，等事务提交时才写出到文件中◼️⭐️-point-20230301-1110%%</span><br>对于 <code>InnoDB</code> 存储引擎而言，<span style="background-color:#f0f">事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中</span>。那么 <code>binlog</code> 是什么时候刷到磁盘中的呢？<code>mysql</code> 通过 <code>sync_binlog</code> 参数控制 <code>binlog</code> 的刷盘时机，取值范围是 <code>0-N</code></li><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：<span style="background-color:#0f0">每次 <code>commit</code> 的时候都要将 <code>binlog</code> 写入磁盘</span>；<span style="background-color:#f0f">(5.7 之后默认值)</span></li><li>N：每 N 个事务，才会将 <code>binlog</code> 写入磁盘。</li></ul><p>从上面可以看出，<code>sync_binlog</code> 最安全的是设置是 <code>1</code>，这也是 <code>MySQL 5.7.7</code><br>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能</p><h2 id="2-5-日志格式"><a href="#2-5-日志格式" class="headerlink" title="2.5. 日志格式"></a>2.5. 日志格式</h2><p><code>binlog</code> 日志有三种格式，分别为 <code>STATMENT</code>、<code>ROW</code> 和 <code>MIXED</code>。</p><blockquote><p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code>，<code>MySQL 5.7.7</code> 之后，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p></blockquote><ul><li><code>ROW</code>： 基于行的复制 (<code>row-based replication, RBR</code>)，不记录每条 sql 语句的上下文信息，仅需记录哪条数据被修改了。<ul><li>优点： 不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题 ；</li><li>缺点： 会产生大量的日志，尤其是 <code>alter table</code> 的时候会让日志暴涨</li></ul></li></ul><h2 id="2-6-主从复制-主从同步"><a href="#2-6-主从复制-主从同步" class="headerlink" title="2.6. 主从复制 (主从同步)"></a>2.6. 主从复制 (主从同步)</h2><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是 <strong>异步</strong> 的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406164408.png" alt="image.png"><br>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体详细过程如下：</p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><blockquote><p>从库是不是越多越好？</p></blockquote><p>不是的。</p><p>因为从库数量增加，从库连接上来的 I&#x2F;O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p><p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p><blockquote><p>MySQL 主从复制还有哪些模型？</p></blockquote><p>主要有三种：</p><ul><li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li><li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li><li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种 <strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li></ul><h1 id="3-Buffer-Pool"><a href="#3-Buffer-Pool" class="headerlink" title="3. Buffer Pool"></a>3. Buffer Pool</h1><a href="/2022/12/31/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="MySQL-1、基本原理">MySQL-1、基本原理</a><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406181445.png" alt="image.png"></p><h1 id="4-Redolog"><a href="#4-Redolog" class="headerlink" title="4. Redolog"></a>4. Redolog</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/log/how_update.html#redo-log-%E6%96%87%E4%BB%B6%E5%86%99%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E">https://xiaolincoding.com/mysql/log/how_update.html#redo-log-%E6%96%87%E4%BB%B6%E5%86%99%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E</a></p><p>物理日志</p><h2 id="4-1-为什么需要-redo-log"><a href="#4-1-为什么需要-redo-log" class="headerlink" title="4.1. 为什么需要 redo log"></a>4.1. 为什么需要 redo log</h2><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230414-1643%%</span>❕ ^k16y1h</p><p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p><span style="background-color:#f0f">为了防止断电导致数据丢失的问题</span>，当有一条记录需要更新的时候，InnoDB 引擎就会<span style="background-color:#0f0">先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来</span>，这个时候更新就算完成了。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。这里与 redolog 从 redolog buffer 到 redolog file 的落盘细节无关。WAL 说的是 DML 先写出到顺序写的日志文件再写出到随机写的数据库磁盘文件的技术思想。</p><h2 id="4-2-记录内容-DDL-和-DML"><a href="#4-2-记录内容-DDL-和-DML" class="headerlink" title="4.2. 记录内容 -DDL 和 DML"></a>4.2. 记录内容 -DDL 和 DML</h2><p>DML 和 DDL</p><h2 id="4-3-记录时机-prepare-lt-前-commit-后-gt-commit"><a href="#4-3-记录时机-prepare-lt-前-commit-后-gt-commit" class="headerlink" title="4.3. 记录时机 - prepare&lt;- 前 commit 后 -&gt;commit"></a>4.3. 记录时机 - prepare&lt;- 前 commit 后 -&gt;commit</h2><p>Buffer Pool 中的数据更改之后，写到 redolog Buffer 中，状态为 prepare<br>提交之后，状态修改为 commit。<br>提交之后有没有刷盘看参数 <code>innodb_flush_log_at_trx_commit</code> 的配置</p><h2 id="4-4-Crash-Safe-总会执行恢复"><a href="#4-4-Crash-Safe-总会执行恢复" class="headerlink" title="4.4. Crash-Safe- 总会执行恢复"></a>4.4. Crash-Safe- 总会执行恢复</h2><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><ol><li>因为 <code>Innodb</code> 是以 <code>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机 IO 写入性能太差！</li><li>因此 <code>mysql</code> 设计了 <code>redo log</code>， <span style="background-color:#f0f">具体来说就是只记录事务对数据页做了哪些修改</span><br>，这样就能完美地解决性能问题了 (相对而言文件更小并且是顺序 IO)。</li></ol><p>启动 <code>innodb</code> 的时候，<span style="background-color:#f0f">不管上次是正常关闭还是异常关闭，总是会进行恢复操作</span>。因为 <code>redo log</code> 记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志 (如 <code>binlog</code>) 要快很多。<br>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p><h2 id="4-5-大小及存储逻辑"><a href="#4-5-大小及存储逻辑" class="headerlink" title="4.5. 大小及存储逻辑"></a>4.5. 大小及存储逻辑</h2><p>每次更新操作都要往 redo log 中写入，如果 redo log 满了，空间不够用了怎么办？<br>InnoDB 的 redo log 文件是固定大小的，比如可以配置一组 4 个文件，每个文件大小是 1GB，那么 redo log 中可以记录 4GB 的操作，InnoDB 会从第一个文件开始写入，直到第四个文件写满了，又回到第一个文件开头循环写，如下图。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406105110.png" alt="image.png"></p><p>图中的：</p><ol><li>write pos 和 checkpoint 的移动都是顺时针方向；</li><li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li><li>check point ～ write pos 之间的部分（图中蓝色部分）：<span style="background-color:#f0f">待落盘的脏数据页记录</span>；</li></ol><p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（_因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要_），此时 <strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><p>所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p><h2 id="4-6-redolog-buffer"><a href="#4-6-redolog-buffer" class="headerlink" title="4.6. redolog buffer"></a>4.6. redolog buffer</h2><p>实际上，执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</p><p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p><h2 id="4-7-刷盘时机-redologbuffer→磁盘"><a href="#4-7-刷盘时机-redologbuffer→磁盘" class="headerlink" title="4.7. 刷盘时机-redologbuffer→磁盘"></a>4.7. 刷盘时机-redologbuffer→磁盘</h2><p><span style="background-color:#ff0">指的是 redo log 从 redolog buffer 写出到磁盘的策略</span></p><h3 id="4-7-1-默认时机"><a href="#4-7-1-默认时机" class="headerlink" title="4.7.1. 默认时机"></a>4.7.1. 默认时机</h3><ol><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li><span style="background-color:#0f0">InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</span></li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 <code>innodb_flush_log_at_trx_commit</code> 参数控制</li></ol><h3 id="4-7-2-提交事务时策略"><a href="#4-7-2-提交事务时策略" class="headerlink" title="4.7.2. 提交事务时策略"></a>4.7.2. 提交事务时策略</h3><p>除此之外，InnoDB 还提供了另外两种策略，由参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li></ul><p><code>redo log</code> 包括两部分：一个是内存中的日志缓冲 (<code>redo log buffer</code>)，另一个是磁盘上的日志文件 (<code>redo log file</code>)。<span style="background-color:#f0f"><code>mysql</code> 每执行一条 <code>DML</code> 语句，都会先将记录写入 <code>redo log buffer</code>（3 种策略都会先写入 Redolog Buffer）</span> ，后续某个时间点再一次性将多个操作记录写到 <code>redo log file</code>。<span style="display:none">%%<br>▶5.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230316-0950%%</span>❕ ^avp3mz<br>在计算机操作系统中，用户空间 (<code>user space</code>) 下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间 (<code>kernel space</code>) 缓冲区 (<code>OS Buffer</code>)。因此，<code>redo log buffer</code> 写入 <code>redo log file</code> 实际上是先写入 <code>OS Buffer</code>，然后再通过系统调用 <code>fsync()</code> 将其刷到 <code>redo log file</code> 中，过程如下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228092314.png" alt="image.png"></p><p><code>mysql</code> 支持三种将 <code>redo log buffer</code> 写入 <code>redo log file</code> 的时机，可以通过<code></code> innodb_flush_log_at_trx_commit&#96; 参数配置，各参数值含义如下：❕<span style="display:none">%%<br>▶2.🏡⭐️◼️3 种 Redolog 刷盘策略的区别 ?🔜MSTM📝 相同点：都会写入 RedologBuffer。不同点：commit 之后到达的位置 0 和 2 都需要一个缓冲，0 commit 到 RedologBuffer 作为缓冲，然后从 RedologBuffer 中每秒写入 oscache 紧接着刷入磁盘；2 commit 到 oscache 作为缓冲，然后从 oscache 中每秒刷入磁盘。而策略 1，写入 RedologBuffer 之后，紧接着写入 oscache、刷入磁盘，相当于直接 commit 到了磁盘◼️⭐️-point-20230301-1131%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406194950.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228091001.png" alt="image.png"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211010192825378.png" alt="image-20211010192825378"></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40471676/article/details/119732738">https://blog.csdn.net/weixin_40471676&#x2F;article&#x2F;details&#x2F;119732738</a></p><p><strong>总结：</strong> <strong>由于磁盘是一种相对较慢的存储设备，内存与磁盘的交互是一个相对较慢的过程</strong> <strong>由于 innodb_log_file_size 定义的是一个相对较大的值，正常情况下，由前面两种 checkpoint 刷新脏页到磁盘，在前面两种 checkpoint 刷新脏页到磁盘之后，脏页对应的 redo log 空间随即释放，一般不会发生 Async&#x2F;Sync Flush checkpoint。同时也要意识到，为了避免频繁低发生 Async&#x2F;SyncFlush checkpoint，也应该将 innodb_log_file_size 配置的相对较大一些。</strong></p><h2 id="4-8-两个日志文件"><a href="#4-8-两个日志文件" class="headerlink" title="4.8. 两个日志文件"></a>4.8. 两个日志文件</h2><p>刚刚说的 redo log 是执行引擎层的 log 文件，我们都知道，MySQL 整体来看，分为 Server 层和引擎层，而 binlog 是 Server 层面的 log 文件，也就是所有执行引擎都有 binlog</p><blockquote><p>为什么有了 binlog， 还要有 redo log？</p></blockquote><p>这个问题跟 MySQL 的时间线有关系。</p><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。<br>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。<br>❕<span style="display:none">%%<br>▶2.🏡⭐️◼️为什么 MySQL 会有 2 个日志文件 ?🔜MSTM📝 ◼️⭐️-point-20230228-1057%%</span></p><h2 id="4-9-二阶段提交⭐️🔴"><a href="#4-9-二阶段提交⭐️🔴" class="headerlink" title="4.9. 二阶段提交⭐️🔴"></a>4.9. 二阶段提交⭐️🔴</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230527133019.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230527133112.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230527133127.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230527133203.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230527133216.png" alt="image.png"></p><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>举个例子，假设 id &#x3D; 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li><li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul><p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，<span style="background-color:#f0f">如果出现半成功的状态，就会造成主从环境的数据不一致性</span>。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p><h3 id="4-9-1-解析"><a href="#4-9-1-解析" class="headerlink" title="4.9.1. 解析"></a>4.9.1. 解析</h3><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-0804%%</span><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1790507">https://cloud.tencent.com/developer/article/1790507</a></p><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了 <strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 <span style="background-color:#f0f">binlog 作为协调者，存储引擎是参与者</span>。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406224609.png" alt="image.png"></p><p>从图中可看出，事务的提交过程有两个阶段，就是 **<span style="background-color:red">将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入 binlog</span>**，具体如下：</p><ol><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（<code>innodb_flush_log_at_trx_commit</code> &#x3D; 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（<code>sync_binlog</code> &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ol><h3 id="4-9-2-如何判断-binlog-和-redolog-是否达成了一致"><a href="#4-9-2-如何判断-binlog-和-redolog-是否达成了一致" class="headerlink" title="4.9.2. 如何判断 binlog 和 redolog 是否达成了一致"></a>4.9.2. 如何判断 binlog 和 redolog 是否达成了一致</h3><p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/425141">https://www.modb.pro/db/425141</a></p><p><span style="background-color:#f0f">当 MySQL 写完 redo log 并将它标记为 prepare 状态时，并且会在 redo log 中记录一个 XID，它全局唯一的标识着这个事务</span>。而当你设置 <code>sync_binlog=1</code> 时，做完了上面第一阶段写 redo log 后，mysql 就会对应 binlog 并且会直接将其刷新到磁盘中。</p><p>下图就是磁盘上的 row 格式的 binlog 记录。binlog 结束的位置上也有一个 XID。<br><span style="background-color:#f0f">只要这个 XID 和 redo log 中记录的 XID 是一致的，MySQL 就会认为 binlog 和 redo log 逻辑上一致。</span>就上面的场景来说就会 commit，而如果仅仅是 redo log 中记录了 XID，binlog 中没有，MySQL 就会 RollBack</p><p>对于处于 PREPARE 状态的事务，存储引擎既可以提交，也可以回滚，这取决于目前该事务对应的 binlog 是否已经写入硬盘。这时就会读取最后一个 binlog 日志文件，从日志文件中找一下有没有该 PREPARE 事务对应的 xid 记录，如果有的话，就将该事务提交，否则就回滚好了。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230307073250.png" alt="image.png"></p><h3 id="4-9-3-事务没提交的时候，redo-log-会被持久化到磁盘吗"><a href="#4-9-3-事务没提交的时候，redo-log-会被持久化到磁盘吗" class="headerlink" title="4.9.3. 事务没提交的时候，redo log 会被持久化到磁盘吗"></a>4.9.3. 事务没提交的时候，redo log 会被持久化到磁盘吗</h3><p>会的！<br>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p><p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p><p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p><p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p><p><span style="background-color:red">redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</span></p><h3 id="4-9-4-存在问题"><a href="#4-9-4-存在问题" class="headerlink" title="4.9.4. 存在问题"></a>4.9.4. 存在问题</h3><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双 1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，<span style="background-color:#f0f">在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致</span>。</li></ul><blockquote><p><strong>为什么两阶段提交的磁盘 I&#x2F;O 次数会很高？</strong></p></blockquote><p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：</p><ul><li>当 <code>sync_binlog = 1</code> 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；</li><li>当 <code>innodb_flush_log_at_trx_commit = 1</code> 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；</li></ul><p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会 <strong>至少调用 2 次刷盘操作</strong>，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。</p><blockquote><p><strong>为什么锁竞争激烈？</strong></p></blockquote><p>在早期的 MySQL 版本中，通过使用 <code>prepare_commit_mutex</code> 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。</p><p>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</p><h2 id="4-10-redolog-与-binlog-区别⭐️🔴"><a href="#4-10-redolog-与-binlog-区别⭐️🔴" class="headerlink" title="4.10. redolog 与 binlog 区别⭐️🔴"></a>4.10. redolog 与 binlog 区别⭐️🔴</h2><p><span style="display:none">%%<br>▶14.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1228%%</span>❕ ^63ep3q</p><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>文件大小</td><td>redo log 的大小是固定的。</td><td>binlog 可通过配置参数 max_binlog_size 设置每个 binlog 文件的大小。</td></tr><tr><td>实现方式</td><td>redo log 是 InnoDB 引擎层实现的，并不是所有引擎都有。</td><td>binlog 是 Server 层实现的，所有引擎都可以使用 binlog 日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>适用场景</td><td>redo log 适用于崩溃恢复 (crash-safe)</td><td>binlog 适用于主从复制和数据恢复</td></tr></tbody></table><p>由 <code>binlog</code> 和 <code>redo log</code> 的区别可知：<code>binlog</code> 日志只用于归档，只依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的。但只有 <code>redo log</code> 也不行，因为 <code>redo log</code> 是 <code>InnoDB</code><br>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code>binlog</code> 和 <code>redo log</code><br>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失</p><ul><li>redo log 是 InnoDB 引擎特有的；而 binlog 是 MySQL Server 层实现的</li><li>redo log 是物理日志，记录的是“在某个数据页做了什么修改”；而 binlog 是逻辑日志，记录的是语句的原始逻辑。比如 <code>update T set c=c+1 where ID=2;</code> 这条 SQL，redo log 中记录的是 ：<code>xx页号，xx偏移量的数据修改为xxx；</code> binlog 中记录的是：<code>id = 2 这一行的 c 字段 +1</code></li><li>redo log 是循环写的，固定空间会用完；binlog 可以追加写入，一个文件写满了会切换到下一个文件写，并不会覆盖之前的记录</li><li>记录内容时间不同，redo log 记录<span style="background-color:#f0f">事务发起后的 DML 和 DDL 语句</span>；binlog 记录<span style="background-color:#f0f">commit 完成后的 DML 语句和 DDL 语句</span></li><li>作用不同，redo log 作为异常宕机或者介质故障后的数据恢复使用；binlog 作为恢复数据使用，主从复制搭建。</li></ul><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304072934.png" alt="image.png"></p><h1 id="5-Undolog"><a href="#5-Undolog" class="headerlink" title="5. Undolog"></a>5. Undolog</h1><h2 id="5-1-记录内容-DDL-和-DML"><a href="#5-1-记录内容-DDL-和-DML" class="headerlink" title="5.1. 记录内容 -DDL 和 DML"></a>5.1. 记录内容 -DDL 和 DML</h2><p>DML 和 DDL</p><p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong><br>实际上， <strong>原子性</strong> 底层就是通过 <code>undo log</code> 实现的。<code>undo log</code> 主要记录了数据的逻辑变化，比如一条 <code>INSERT</code> 语句，对应一条 <code>DELETE</code> 的 <code>undo log</code>，对于每个 <code>UPDATE</code> 语句，对应一条相反的 <code>UPDATE</code> 的 <code>undo log</code>，这样在发生错误时，就能回滚到事务之前的数据状态。同时，<code>undo log</code> 也是 <code>MVCC</code> (多版本并发控制) 实现的关键</p><h2 id="5-2-记录时机-commit-数据页之前"><a href="#5-2-记录时机-commit-数据页之前" class="headerlink" title="5.2. 记录时机 - commit 数据页之前"></a>5.2. 记录时机 - commit 数据页之前</h2><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，<span style="background-color:#f0f">确切来说是在 Buffer Pool 中的数据修改之前</span>，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406195837.png" alt="image.png"></p><h2 id="5-3-作用-回滚-MVCC"><a href="#5-3-作用-回滚-MVCC" class="headerlink" title="5.3. 作用 - 回滚 + MVCC"></a>5.3. 作用 - 回滚 + MVCC</h2><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><p>undo log 和 redo log 也是引擎层的 log 文件，undo log 提供了回滚和多个行版本控制（MVCC）功能。在数据库修改操作时，不仅记录了 redo log，还记录了 undo log，如果因为某些原因导致事务执行失败回滚了，可以借助 undo log 进行回滚。</p><p>虽然 undo log 和 redo log 都是 InnoDB 特有的，但 undo log 记录的是逻辑日志，redo log 记录的是物理日志。对记录做变更操作（insert,update,delete）时不仅会产生 redo 记录，也会产生 undo 记录要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在 <strong>插入</strong> 一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录 <strong>删掉</strong> 就好了；</li><li>在 <strong>删除</strong> 一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 <strong>插入</strong> 到表中就好了；</li><li>在 <strong>更新</strong> 一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列 <strong>更新为旧值</strong> 就好了。</li></ul><p>而多版本并发控制（MVCC） ，也用到了 undo log ，当读取的某一行被其他事务锁定时，它可以从 undo log 中获取该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p><h2 id="5-4-大小和存储逻辑"><a href="#5-4-大小和存储逻辑" class="headerlink" title="5.4. 大小和存储逻辑"></a>5.4. 大小和存储逻辑</h2><p>undo 记录默认被记录到系统表空间（ibdata1）中，但是从 MySQL5.6 开始，就可以使用独立的 undo 表空间了。不用担心 undo 会把 ibdata1 文件弄大。</p><p>undo log 是采用段 (segment) 的方式来记录的，每个 undo 操作在记录的时候占用一个 undo log segment</p><p>rollback segment 称为回滚段，每个回滚段中有 1024 个 undo log segment，在以前的版本中，只支持一个 rollback segment，也就是只能记录 1024 个 undo log segment，MySQL 5.5 以后，可以支持 128 个 rollback segment，即支持 128✖️1024 个 undo 操作，还可以通过变量 <code>innodb_undo_logs</code> 自定义 rollback segment 数量，默认是 128</p><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/720454.html">https://www.51cto.com/article/720454.html</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7157956679932313608#heading-1">https://juejin.cn/post/7157956679932313608#heading-1</a></p><h2 id="5-5-redolog-和-undolog-区别"><a href="#5-5-redolog-和-undolog-区别" class="headerlink" title="5.5. redolog 和 undolog 区别"></a>5.5. redolog 和 undolog 区别</h2><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ol><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是 commit 更新 <strong>之后</strong> 的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是 commit 更新 <strong>之前</strong> 的值；</li></ol><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406191903.png" alt="image.png"></p><h1 id="6-update-操作流程"><a href="#6-update-操作流程" class="headerlink" title="6. update 操作流程"></a>6. update 操作流程</h1><p><code>update T set c=c+1 where ID=2;</code></p><p>1、执行器先通过引擎查询到 id &#x3D; 2 这行数据，id 是主键，直接遍历主键索引树直接插到这行数据，如果这行数据所在的数据页在内存中，就直接返回结果给执行器，否则，需要先从磁盘读入内存，然后再返回。</p><p>2、执行器拿到引擎给的行数据，把这个值 +1，得到新的一行数据，再调用引擎接口写入这行数据，<span style="background-color:#f0f">发起事务</span>。</p><p>3、引擎将这行数据更新到内存中，同时记录到 redo log 中，此时 redo log 处于 perpare 状态，此时就告知执行器已经更新完成了，随时可以提交事务。</p><p>4、执行器生成这个操作的 binlog，并把 binlog 写入 page cache。</p><p>5、提交事务：执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，把 binlog 写入磁盘，更新完成</p><p>如下图为 update 语句的执行流程，深色代表 MySQL 执行器中执行的，浅色代表 InnoDB 内部执行的。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230228112937.png" alt="image.png"><br>❕<span style="display:none">%%<br>▶2.🏡⭐️◼️不用纠结 redolog 的 prepare 和 commit 是在 redolog Buffer 中还是在磁盘中。因为这个是通过参数可变的。关键就在于 redolog 这两种状态的变化时机和原因。按推断来讲，prepare 时还没有提交，所以应该在内存。而 commit 状态就是根据参数来确定。◼️⭐️-point-20230302-0748%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406170635.png" alt="image.png"></p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p><span style="display:none">%%<br>▶57.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230304-1846%%</span>❕ ^hyl1t6</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230406155635.png" alt="image.png"></p><p>redo log 用来保证 crash-safe，binlog 用来保证可以将数据库状态恢复到任一时刻，undo log 是用来保证事务需要回滚时数据状态的回滚和 MVCC 时，记录各版本数据信息。</p><h1 id="8-实战经验"><a href="#8-实战经验" class="headerlink" title="8. 实战经验"></a>8. 实战经验</h1><h2 id="8-1-MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？"><a href="#8-1-MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？" class="headerlink" title="8.1. MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>8.1. MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I&#x2F;O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p><ul><li>设置<span style="background-color:#f0f">组提交</span>的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li><li>将 <code>sync_binlog</code> 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但<span style="background-color:#f0f">累积 N 个事务后才 fsync</span>，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li><li>将 <code>innodb_flush_log_at_trx_commit</code> 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log 文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li></ul><h1 id="9-参考与感谢"><a href="#9-参考与感谢" class="headerlink" title="9. 参考与感谢"></a>9. 参考与感谢</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023827696">https://segmentfault.com/a/1190000023827696</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renolei/p/5325435.html">https://www.cnblogs.com/renolei/p/5325435.html</a></p><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/681113.html">https://www.51cto.com/article/681113.html</a></p><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7157956679932313608#heading-1">https://juejin.cn/post/7157956679932313608#heading-1</a></p><p>动画： <a target="_blank" rel="noopener" href="https://heapdump.cn/article/3890459">https://heapdump.cn/article/3890459</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/02/14/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-3%E3%80%81redolog-undolog-binlog/">https://taylorluo.github.io/2023/02/14/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-3%E3%80%81redolog-undolog-binlog/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/">日志文件</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/972" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/15/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-4%E3%80%81%E9%94%81/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架源码专题-MySQL-4、锁</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/13/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-2%E3%80%81%E4%BA%8B%E5%8A%A1-MVCC-LBCC/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">框架源码专题-MySQL-2、MVCC</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/31/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="框架源码专题-MySQL-1、基本原理"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">框架源码专题-MySQL-1、基本原理</div></div></a></div><div><a href="/2023/02/13/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-2%E3%80%81%E4%BA%8B%E5%8A%A1-MVCC-LBCC/" title="框架源码专题-MySQL-2、MVCC"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-14</div><div class="title">框架源码专题-MySQL-2、MVCC</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%97%A5%E5%BF%97%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">1. 日志流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Binlog"><span class="toc-text">2. Binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%AE%B0%E5%BD%95%E5%86%85%E5%AE%B9-DDL-%E5%92%8C-DML"><span class="toc-text">2.1. 记录内容 - DDL 和 DML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%AE%B0%E5%BD%95%E6%97%B6%E6%9C%BA-%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E5%90%8E"><span class="toc-text">2.2. 记录时机 - 更新完数据页之后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3. 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA-cache%E2%86%90%E5%89%8D-commit-%E5%90%8E%E2%86%92file"><span class="toc-text">2.4. 刷盘时机 -cache←前 commit 后→file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.5. 日志格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-text">2.6. 主从复制 (主从同步)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Buffer-Pool"><span class="toc-text">3. Buffer Pool</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Redolog"><span class="toc-text">4. Redolog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-redo-log"><span class="toc-text">4.1. 为什么需要 redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%AE%B0%E5%BD%95%E5%86%85%E5%AE%B9-DDL-%E5%92%8C-DML"><span class="toc-text">4.2. 记录内容 -DDL 和 DML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%AE%B0%E5%BD%95%E6%97%B6%E6%9C%BA-prepare-lt-%E5%89%8D-commit-%E5%90%8E-gt-commit"><span class="toc-text">4.3. 记录时机 - prepare&lt;- 前 commit 后 -&gt;commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Crash-Safe-%E6%80%BB%E4%BC%9A%E6%89%A7%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="toc-text">4.4. Crash-Safe- 总会执行恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%A4%A7%E5%B0%8F%E5%8F%8A%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91"><span class="toc-text">4.5. 大小及存储逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-redolog-buffer"><span class="toc-text">4.6. redolog buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA-redologbuffer%E2%86%92%E7%A3%81%E7%9B%98"><span class="toc-text">4.7. 刷盘时机-redologbuffer→磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E9%BB%98%E8%AE%A4%E6%97%B6%E6%9C%BA"><span class="toc-text">4.7.1. 默认时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E6%97%B6%E7%AD%96%E7%95%A5"><span class="toc-text">4.7.2. 提交事务时策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E4%B8%A4%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">4.8. 两个日志文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.9. 二阶段提交⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-%E8%A7%A3%E6%9E%90"><span class="toc-text">4.9.1. 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-binlog-%E5%92%8C-redolog-%E6%98%AF%E5%90%A6%E8%BE%BE%E6%88%90%E4%BA%86%E4%B8%80%E8%87%B4"><span class="toc-text">4.9.2. 如何判断 binlog 和 redolog 是否达成了一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-%E4%BA%8B%E5%8A%A1%E6%B2%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Credo-log-%E4%BC%9A%E8%A2%AB%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%B0%E7%A3%81%E7%9B%98%E5%90%97"><span class="toc-text">4.9.3. 事务没提交的时候，redo log 会被持久化到磁盘吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4-%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">4.9.4. 存在问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-redolog-%E4%B8%8E-binlog-%E5%8C%BA%E5%88%AB%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.10. redolog 与 binlog 区别⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Undolog"><span class="toc-text">5. Undolog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%AE%B0%E5%BD%95%E5%86%85%E5%AE%B9-DDL-%E5%92%8C-DML"><span class="toc-text">5.1. 记录内容 -DDL 和 DML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%AE%B0%E5%BD%95%E6%97%B6%E6%9C%BA-commit-%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E5%89%8D"><span class="toc-text">5.2. 记录时机 - commit 数据页之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BD%9C%E7%94%A8-%E5%9B%9E%E6%BB%9A-MVCC"><span class="toc-text">5.3. 作用 - 回滚 + MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91"><span class="toc-text">5.4. 大小和存储逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-redolog-%E5%92%8C-undolog-%E5%8C%BA%E5%88%AB"><span class="toc-text">5.5. redolog 和 undolog 区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-update-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">6. update 操作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7. 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">8. 实战经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-MySQL-%E7%A3%81%E7%9B%98-I-x2F-O-%E5%BE%88%E9%AB%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">8.1. MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">9. 参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/972')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>