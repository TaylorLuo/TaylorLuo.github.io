<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>分布式专题-5、负载均衡-Ribbon | Taylor</title><meta name="keywords" content="timeline"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？ 1. 负载均衡原理SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。  那么我们发出的请求明明是 http:&#x2F;&#x2F;userservice&#x2F;user&#x2F;1，怎么变成了 http:&#x2F;&#x2F;localhost:8081 的呢？ 2. 源码跟踪为什么我们只输入了 service 名称就"><meta property="og:type" content="article"><meta property="og:title" content="分布式专题-5、负载均衡-Ribbon"><meta property="og:url" content="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？ 1. 负载均衡原理SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。  那么我们发出的请求明明是 http:&#x2F;&#x2F;userservice&#x2F;user&#x2F;1，怎么变成了 http:&#x2F;&#x2F;localhost:8081 的呢？ 2. 源码跟踪为什么我们只输入了 service 名称就"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/942"><meta property="article:published_time" content="2023-06-12T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.691Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="timeline"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/942"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"分布式专题-5、负载均衡-Ribbon",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/942')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式专题-5、负载均衡-Ribbon</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-12T16:00:00.000Z" title="发表于 2023-06-13 00:00:00">2023-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.691Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="分布式专题-5、负载均衡-Ribbon"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><p>我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h1 id="1-负载均衡原理"><a href="#1-负载均衡原理" class="headerlink" title="1. 负载均衡原理"></a>1. 负载均衡原理</h1><p><span style="background-color:#f0f">SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224133.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是 <a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a>，怎么变成了 <a target="_blank" rel="noopener" href="http://localhost:8081/">http://localhost:8081</a> 的呢？</p><h1 id="2-源码跟踪"><a href="#2-源码跟踪" class="headerlink" title="2. 源码跟踪"></a>2. 源码跟踪</h1><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们<span style="background-color:#f0f">根据 service 名称，获取到了服务实例的 ip 和端口</span>。它就是 <code>LoadBalancerInterceptor</code>，这个类会对 RestTemplate 的请求进行拦截，然后从 Eureka 中根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h2 id="2-1-LoadBalancerIntercepor"><a href="#2-1-LoadBalancerIntercepor" class="headerlink" title="2.1. LoadBalancerIntercepor"></a>2.1. LoadBalancerIntercepor</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304231125.png" alt="image.png"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：<span style="background-color:#0f0">获取请求 uri</span>，本例中就是 <a target="_blank" rel="noopener" href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：<span style="background-color:#0f0">获取 uri 路径的主机名</span>，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型，我们继续跟入。</p><h2 id="2-2-LoadBalancerClient"><a href="#2-2-LoadBalancerClient" class="headerlink" title="2.2. LoadBalancerClient"></a>2.2. LoadBalancerClient</h2><p>继续跟入 execute 方法：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224009.png" alt="image.png"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：<span style="background-color:#f0f">根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来</span>。</li><li>getServer(loadBalancer)：<span style="background-color:#f0f">利用内置的负载均衡算法，从服务列表中选择一个</span> 在本例中，可以看到获取了 8082 端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是 8081：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304232315.png" alt="image.png"></p><p>果然实现了负载均衡。</p><h2 id="2-3-负载均衡策略-IRule"><a href="#2-3-负载均衡策略-IRule" class="headerlink" title="2.3. 负载均衡策略 IRule"></a>2.3. 负载均衡策略 IRule</h2><p>在刚才的代码中，可以看到<span style="background-color:#f0f">获取服务使通过一个 <code>getServer</code> 方法来做负载均衡</span>:</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224002.png" alt="image.png"></p><p>我们继续跟入：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223958.png" alt="image.png"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223953.png" alt="image.png"></p><p>我们看看这个 rule 是谁：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223950.png" alt="image.png"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code>，看类的介绍：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304223945.png" alt="image.png"></p><p>这不就是轮询的意思嘛。<br>到这里，整个负载均衡的流程我们就清楚了。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4. 总结"></a>2.4. 总结</h2><p><span style="display:none">%%<br>▶49.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230312-1455%%</span>❕ ^pxs57b</p><p>SpringCloudRibbon 的底层采用了一个<span style="background-color:red">拦截器</span>，<span style="background-color:#f0f">拦截了 RestTemplate 发出的请求，对地址做了修改</span>。用一幅图来总结一下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304224511.png" alt="image.png"></p><p>基本流程如下：</p><ol><li><code>LoadBalancerIntercepor</code> 拦截我们的 RestTemplate 请求 <a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求 url 中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li><code>Eureka</code> 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> <span style="background-color:#f0f">修改请求地址</span>，用 localhost:8081 替代 userservice，得到 <a target="_blank" rel="noopener" href="http://localhost:8081/user/1">http://localhost:8081/user/1</a>，发起真实请求</li></ol><h1 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="3. 负载均衡策略"></a>3. 负载均衡策略</h1><h2 id="3-1-负载均衡策略"><a href="#3-1-负载均衡策略" class="headerlink" title="3.1. 负载均衡策略"></a>3.1. 负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304222952.png" alt="image.png"></p><p>不同规则的含义如下：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230305071024.png" alt="image.png"></p><p>默认的实现就是 <span style="background-color:#f0f">ZoneAvoidanceRule</span>，是一种轮询方案</p><h2 id="3-2-详细介绍"><a href="#3-2-详细介绍" class="headerlink" title="3.2. 详细介绍"></a>3.2. 详细介绍</h2><p><strong>IRule</strong><br>这是所有负载均衡策略的父接口，里边的核心方法就是 choose 方法，用来选择一个服务实例。<br><strong>AbstractLoadBalancerRule</strong><br>AbstractLoadBalancerRule 是一个抽象类，里边主要定义了一个 ILoadBalancer，这里定义它的目的主要是辅助负责均衡策略选取合适的服务端实例。</p><h3 id="3-2-1-RandomRule"><a href="#3-2-1-RandomRule" class="headerlink" title="3.2.1. RandomRule"></a>3.2.1. RandomRule</h3><p>看名字就知道，这种负载均衡策略就是<span style="background-color:#ff0">随机选择一个服务实例</span>，看源码我们知道，在 RandomRule 的无参构造方法中初始化了一个 Random 对象，然后在它重写的 choose 方法又调用了 choose(ILoadBalancer lb, Object key) 这个重载的 choose 方法，在这个重载的 choose 方法中，&#x3D;&#x3D;每次利用 random 对象生成一个不大于服务实例总数的随机数&#x3D;&#x3D;，并将该数作为下标所以获取一个服务实例。</p><h3 id="3-2-2-RoundRobinRule"><a href="#3-2-2-RoundRobinRule" class="headerlink" title="3.2.2. RoundRobinRule"></a>3.2.2. RoundRobinRule</h3><p>RoundRobinRule 这种负载均衡策略叫做<span style="background-color:#ff0">线性轮询负载均衡策略</span>。这个类的 choose(ILoadBalancer lb, Object key) 函数整体逻辑是这样的：开启一个计数器 count，在 while 循环中遍历服务清单，获取清单之前先通过 incrementAndGetModulo 方法获取一个下标，这个下标是一个不断自增长的数先加 1 然后和服务清单总数取模之后获取到的（所以这个下标从来不会越界），拿着下标再去服务清单列表中取服务，每次循环计数器都会加 1，如果连续 10 次都没有取到服务，则会报一个警告 <code>No available alive servers after 10 tries from load balancer: XXXX</code></p><h3 id="3-2-3-RetryRule（在轮询的基础上进行重试）"><a href="#3-2-3-RetryRule（在轮询的基础上进行重试）" class="headerlink" title="3.2.3. RetryRule（在轮询的基础上进行重试）"></a>3.2.3. RetryRule（在轮询的基础上进行重试）</h3><p>看名字就知道这种负载均衡策略带有重试功能。首先 RetryRule 中又定义了一个 subRule，它的实现类是 RoundRobinRule，然后在 RetryRule 的 choose(ILoadBalancer lb, Object key) 方法中，每次还是采用 RoundRobinRule 中的 choose 规则来选择一个服务实例，如果选到的实例正常就返回，如果选择的服务实例为 null 或者已经失效，则<span style="background-color:#0f0">在失效时间 deadline 之前不断的进行重试</span>（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过了 deadline 还是没取到则会返回一个 null。</p><h3 id="3-2-4-WeightedResponseTimeRule"><a href="#3-2-4-WeightedResponseTimeRule" class="headerlink" title="3.2.4. WeightedResponseTimeRule"></a>3.2.4. WeightedResponseTimeRule</h3><p>（权重 —nacos 的 NacosRule ，Nacos 还扩展了一个自己的基于配置的权重扩展）<br>WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，在 WeightedResponseTimeRule 中对 RoundRobinRule 的功能进行了扩展，<br>WeightedResponseTimeRule 中会根据每一个实例的运行情况来给计算出该实例的一个权重，然后在挑选实例的时候则根据权重进行挑选，这样能<br>够实现更优的实例调用。WeightedResponseTimeRule 中有一个名叫 DynamicServerWeightTask 的定时任务，默认情况下每隔 30 秒会计算一次<br>各个服务实例的权重，权重的计算规则也很简单，<span style="background-color:#0f0">如果一个服务的平均响应时间越短则权重越大，那么该服务实例被选中执行任务的概率也就越大</span>。</p><h3 id="3-2-5-ClientConfigEnabledRoundRobinRule"><a href="#3-2-5-ClientConfigEnabledRoundRobinRule" class="headerlink" title="3.2.5. ClientConfigEnabledRoundRobinRule"></a>3.2.5. ClientConfigEnabledRoundRobinRule</h3><p>ClientConfigEnabledRoundRobinRule 选择策略的实现很简单，内部定义了 RoundRobinRule，choose 方法还是采用了 RoundRobinRule 的<br>choose 方法，所以它的选择策略<span style="background-color:#0f0">和 RoundRobinRule 的选择策略一致</span>，不赘述。</p><h3 id="3-2-6-BestAvailableRule"><a href="#3-2-6-BestAvailableRule" class="headerlink" title="3.2.6. BestAvailableRule"></a>3.2.6. BestAvailableRule</h3><p>BestAvailableRule 继承自 ClientConfigEnabledRoundRobinRule，它在 ClientConfigEnabledRoundRobinRule 的基础上主要增加了根据<br>loadBalancerStats 中保存的服务实例的状态信息来<span style="background-color:#0f0">过滤掉失效的服务实例的功能，然后顺便找出并发请求最小的服务实例来使用</span>。然而<br>loadBalancerStats 有可能为 null，如果 loadBalancerStats 为 null，则 BestAvailableRule 将采用它的父类即<br>ClientConfigEnabledRoundRobinRule 的服务选取策略（线性轮询）。</p><h3 id="3-2-7-ZoneAvoidanceRule"><a href="#3-2-7-ZoneAvoidanceRule" class="headerlink" title="3.2.7. ZoneAvoidanceRule"></a>3.2.7. ZoneAvoidanceRule</h3><p><span style="background-color:#f0f">默认规则，复合判断 server 所在区域的性能和 server 的可用性选择服务器</span><br>ZoneAvoidanceRule 是 PredicateBasedRule 的一个实现类，只不过这里多一个过滤条件，ZoneAvoidanceRule 中的过滤条件是以<br>ZoneAvoidancePredicate 为主过滤条件和以<br>AvailabilityPredicate 为次过滤条件组成的一个叫做 CompositePredicate 的组合过滤条件，过滤成功之后，继续采用线性轮询<br>(RoundRobinRule) 的方式从过滤结果中选择一个出来。<br>AvailabilityFilteringRule（先过滤掉故障实例，再选择并发较小的实例）<br> 过滤掉一直连接失败的被标记为 circuit tripped 的后端 Server，并过滤掉那些高并发的后端 Server 或者使用一个 AvailabilityPredicate 来<br>包含过滤 server 的逻辑，其实就是检查 status 里记录的各个 Server 的运行状态</p><h2 id="3-3-自定义负载均衡策略"><a href="#3-3-自定义负载均衡策略" class="headerlink" title="3.3. 自定义负载均衡策略"></a>3.3. 自定义负载均衡策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：<br><span style="background-color:#ff0">这是一种全局配置，不推荐</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@Bean  <br>public IRule randomRule()&#123;  <br>    return new RandomRule();  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：<br><span style="background-color:#0f0">按服务配置，更灵活</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  <br>  ribbon:  <br>    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 <br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注意</strong>，<span style="background-color:#f0f">一般用默认的负载均衡规则，不做修改</span>。</p></blockquote><h1 id="4-饥饿加载"><a href="#4-饥饿加载" class="headerlink" title="4. 饥饿加载"></a>4. 饥饿加载</h1><p><span style="display:none">%%<br>▶48.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️♨️♨️⭐️】◼️⭐️-point-20230312-1358%%</span>❕ ^x4qqqw</p><p>Ribbon <span style="background-color:#f0f">默认是采用懒加载</span>，即<span style="background-color:#f0f">第一次访问时才会去创建</span> <code>LoadBalanceClient</code>，请求时间会很长。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312135815.png" alt="image.png"></p><p><span style="background-color:#f0f">而饥饿加载则会在项目启动时创建，降低第一次访问的耗时</span>，通过下面配置开启饥饿加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ribbon:    <br>  eager-load:    <br>    enabled: true    <br>    clients: userservice<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230312140030.png" alt="image.png"></p><h1 id="5-重试机制"><a href="#5-重试机制" class="headerlink" title="5. 重试机制"></a>5. 重试机制</h1><span style="display:none">- [ ] 🚩 - 重试机制 - 🏡 2023-03-12 18:41</span> #todo<h1 id="6-RestTemplate"><a href="#6-RestTemplate" class="headerlink" title="6. RestTemplate"></a>6. RestTemplate</h1><h2 id="6-1-是什么"><a href="#6-1-是什么" class="headerlink" title="6.1. 是什么"></a>6.1. 是什么</h2><p>RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法, 能够大大提高客户端的编写效率。</p><p>调用 RestTemplate 的默认构造函数，RestTemplate 对象在底层通过使用 java.net 包下的实现创建 HTTP 请求，可以通过使用 ClientHttpRequestFactory 指定不同的 HTTP 请求方式。</p><p>ClientHttpRequestFactory 接口主要提供了两种实现方式</p><ol><li>一种是 SimpleClientHttpRequestFactory，使用 J2SE 提供的方式（既 java.net 包提供的方式）创建底层的 Http 请求连接。</li><li>一种方式是使用 HttpComponentsClientHttpRequestFactory 方式，底层使用 HttpClient 访问远程的 Http 服务，使用 HttpClient 可以配置连接池和证书等信息。</li></ol><p>RestTemplate 的核心之一 Http Client。</p><p>目前通过 RestTemplate 的源码可知，RestTemplate 可支持多种 Http Client 的 http 的访问，如下所示：</p><ul><li>基于 JDK HttpURLConnection 的 SimpleClientHttpRequestFactory，默认。</li><li>基于 Apache HttpComponents Client 的 HttpComponentsClientHttpRequestFactory</li><li>基于 OkHttp3 的 OkHttpClientHttpRequestFactory。</li><li>基于 Netty4 的 Netty4ClientHttpRequestFactory。</li></ul><p>其中 HttpURLConnection 和 HttpClient 为原生的网络访问类，OkHttp3 采用了 OkHttp3 的框架，Netty4 采用了 Netty 框架。</p><h2 id="6-2-配置"><a href="#6-2-配置" class="headerlink" title="6.2. 配置"></a>6.2. 配置</h2><h3 id="6-2-1-RestTempate-的访问的超时设置"><a href="#6-2-1-RestTempate-的访问的超时设置" class="headerlink" title="6.2.1. RestTempate 的访问的超时设置"></a>6.2.1. RestTempate 的访问的超时设置</h3><p>例如，我用的是 Httpclient 的连接池，RestTemplate 的超时设置依赖 HttpClient 的内部的三个超时时间设置。</p><p>HttpClient 内部有三个超时时间设置：连接池获取可用连接超时，连接超时，读取数据超时：</p><p><strong>1.setConnectionRequestTimeout 从连接池中获取可用连接超时：设置从 connect Manager 获取 Connection 超时时间，单位毫秒。</strong></p><p>HttpClient 中的要用连接时尝试从连接池中获取，若是在等待了一定的时间后还没有获取到可用连接（比如连接池中没有空闲连接了）则会抛出获取连接超时异常。</p><p><strong>2.连接目标超时 connectionTimeout，单位毫秒。</strong></p><p>指的是连接目标 url 的连接超时时间，即客服端发送请求到与目标 url 建立起连接的最大时间。如果在该时间范围内还没有建立起连接，则就抛出 connectionTimeOut 异常。</p><p>如测试的时候，将 url 改为一个不存在的 url：“<a target="_blank" rel="noopener" href="http://test.com”/">http://test.com”</a> ，超时时间 3000ms 过后，系统报出异常：   org.apache.commons.httpclient.ConnectTimeoutException:The host did not accept the connection within timeout of 3000 ms</p><p><strong>3.等待响应超时（读取数据超时）socketTimeout ，单位毫秒。</strong></p><p>连接上一个 url 后，获取 response 的返回等待时间 ，即在与目标 url 建立连接后，等待放回 response 的最大时间，在规定时间内没有返回响应的话就抛出 SocketTimeout。</p><p>测试时，将 socketTimeout 设置很短，会报等待响应超时。</p><p>我遇到的问题，restTemplate 请求到一个高可用的服务时，返回的超时时间是设置值的 2 倍，是因为负载均衡器返回的重定向，导致 httpClient 底层认为没有超时，又请求一次，如果负载均衡器下有两个节点，就耗费 connectionTimeout 的双倍时间。</p><h2 id="6-3-连接池"><a href="#6-3-连接池" class="headerlink" title="6.3. 连接池"></a>6.3. 连接池</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384627133">https://zhuanlan.zhihu.com/p/384627133</a></p><h1 id="7-实战经验"><a href="#7-实战经验" class="headerlink" title="7. 实战经验"></a>7. 实战经验</h1><h1 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h1><h2 id="8-1-黑马程序员"><a href="#8-1-黑马程序员" class="headerlink" title="8.1. 黑马程序员"></a>8.1. 黑马程序员</h2><p>微服务开发框架 SpringCloud+RabbitMQ+Docker+Redis+ 搜索 + 分布式微服务全技术栈课程 ^4ps1v8</p><h3 id="8-1-1-视频"><a href="#8-1-1-视频" class="headerlink" title="8.1.1. 视频"></a>8.1.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LQ4y127n4?p=17&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1LQ4y127n4?p=17&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="8-1-2-资料"><a href="#8-1-2-资料" class="headerlink" title="8.1.2. 资料"></a>8.1.2. 资料</h3><p>[[SpringCloud01]]</p><h2 id="8-2-其他"><a href="#8-2-其他" class="headerlink" title="8.2. 其他"></a>8.2. 其他</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210925135730907.png" alt="image-20210925135730907"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/">https://taylorluo.github.io/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timeline/">timeline</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/942" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kafka</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-12%E3%80%81Zookeeper/"><img class="next-cover" src="https://picsum.photos/1920/1086" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">服务注册与发现-12、Zookeeper</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-1%E3%80%81%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="计算机基础-基本原理-1、相关名词"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">计算机基础-基本原理-1、相关名词</div></div></a></div><div><a href="/2023/03/27/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/JDK-1%E3%80%81SPI/" title="框架源码专题-JDK-1、SPI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover5.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">框架源码专题-JDK-1、SPI</div></div></a></div><div><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-9%E3%80%81SQL%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/" title="框架源码专题-MySQL-9、SQL应用优化"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">框架源码专题-MySQL-9、SQL应用优化</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/01/22/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-19%E3%80%81Queue/" title="并发编程专题-基础-19、Queue"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">并发编程专题-基础-19、Queue</div></div></a></div><div><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构实战专题-基础-1、架构演进"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">架构实战专题-基础-1、架构演进</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-text">1. 负载均衡原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA"><span class="toc-text">2. 源码跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-LoadBalancerIntercepor"><span class="toc-text">2.1. LoadBalancerIntercepor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-LoadBalancerClient"><span class="toc-text">2.2. LoadBalancerClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5-IRule"><span class="toc-text">2.3. 负载均衡策略 IRule</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="toc-text">2.4. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-text">3. 负载均衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-text">3.1. 负载均衡策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.2. 详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-RandomRule"><span class="toc-text">3.2.1. RandomRule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-RoundRobinRule"><span class="toc-text">3.2.2. RoundRobinRule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-RetryRule%EF%BC%88%E5%9C%A8%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%95%EF%BC%89"><span class="toc-text">3.2.3. RetryRule（在轮询的基础上进行重试）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-WeightedResponseTimeRule"><span class="toc-text">3.2.4. WeightedResponseTimeRule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-ClientConfigEnabledRoundRobinRule"><span class="toc-text">3.2.5. ClientConfigEnabledRoundRobinRule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-BestAvailableRule"><span class="toc-text">3.2.6. BestAvailableRule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-ZoneAvoidanceRule"><span class="toc-text">3.2.7. ZoneAvoidanceRule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-text">3.3. 自定义负载均衡策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD"><span class="toc-text">4. 饥饿加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">5. 重试机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-RestTemplate"><span class="toc-text">6. RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6.1. 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%85%8D%E7%BD%AE"><span class="toc-text">6.2. 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-RestTempate-%E7%9A%84%E8%AE%BF%E9%97%AE%E7%9A%84%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"><span class="toc-text">6.2.1. RestTempate 的访问的超时设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">6.3. 连接池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C"><span class="toc-text">7. 实战经验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">8. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="toc-text">8.1. 黑马程序员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E8%A7%86%E9%A2%91"><span class="toc-text">8.1.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E8%B5%84%E6%96%99"><span class="toc-text">8.1.2. 资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%85%B6%E4%BB%96"><span class="toc-text">8.2. 其他</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/942')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>