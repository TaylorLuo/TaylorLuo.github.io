<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>1、Spring-基础 | Taylor</title><meta name="keywords" content="timeline"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Spring 基本概念 POJO: 基于 POJO 的轻量级和最小侵入性编程；DI: 通过依赖注入和面向接口实现松耦合；AOP: 基于切面和惯例进行声明式编程；Template: 通过切面和模板减少样板式代码。  比如我们要写 JDBC 这种牵扯到大量样板式的代码。我们其实只关注我们的 sql 语句（也就是它要实现什么功能），我们可不想看到他是如何连接的。等我们写好核心之后再去用切面进行连"><meta property="og:type" content="article"><meta property="og:title" content="1、Spring-基础"><meta property="og:url" content="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. Spring 基本概念 POJO: 基于 POJO 的轻量级和最小侵入性编程；DI: 通过依赖注入和面向接口实现松耦合；AOP: 基于切面和惯例进行声明式编程；Template: 通过切面和模板减少样板式代码。  比如我们要写 JDBC 这种牵扯到大量样板式的代码。我们其实只关注我们的 sql 语句（也就是它要实现什么功能），我们可不想看到他是如何连接的。等我们写好核心之后再去用切面进行连"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://unpkg.com/justlovesmile-img/cover1.JPG"><meta property="article:published_time" content="2023-06-12T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.915Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="timeline"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://unpkg.com/justlovesmile-img/cover1.JPG"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"1、Spring-基础",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://unpkg.com/justlovesmile-img/cover1.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1、Spring-基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-12T16:00:00.000Z" title="发表于 2023-06-13 00:00:00">2023-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.915Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="1、Spring-基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><h1 id="1-Spring-基本概念"><a href="#1-Spring-基本概念" class="headerlink" title="1. Spring 基本概念"></a>1. Spring 基本概念</h1><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131132514.png" alt="image.png"></p><p><strong>POJO</strong>: 基于 POJO 的轻量级和最小侵入性编程；<br><strong>DI</strong>: 通过依赖注入和面向接口实现松耦合；<br><strong>AOP</strong>: 基于切面和惯例进行声明式编程；<br><strong>Template</strong>: 通过切面和模板减少样板式代码。</p><blockquote><p>比如我们要写 JDBC 这种牵扯到大量样板式的代码。我们其实只关注我们的 sql 语句（也就是它要实现什么功能），我们可不想看到他是如何连接的。等我们写好核心之后再去用切面进行连接，断开等。</p></blockquote><h2 id="1-1-POJO"><a href="#1-1-POJO" class="headerlink" title="1.1. POJO"></a>1.1. POJO</h2><a href="/2022/11/11/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-0%E3%80%81Java%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="基本原理-0、Java相关名词">基本原理-0、Java相关名词</a><p>POJO 的全称是 Plain Old Java Object，简单又老的 Java 对象。这里的简单是相对来讲的。 EJB 2. x 的 Entity Beans 比较重量，需要实现 <code>javax.ejb</code> 的一些接口。而 POJO 就比较轻量，就是一个 Java 对象，不需要实现任何的接口。POJO 专指只有 private 属性以及 setter&#x2F;getter&#x2F;toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</p><p>所以 POJO 本质上也是可以方便沟通的术语。</p><p>有了 POJO 这个名字，相比框架里面各种的对象概念，就容易理解多了，所以这个概念被很广地使用开来。可以用 POJO 来解释 JavaBean 这个惯例 (约定): <span style="background-color:#0f0">JavaBean 就是可以序列化的 POJO，并且有无参构造器，可以使用 getter&#x2F;setter 来读写属性。</span>❕<span style="display:none">%%<br>0737-🏡⭐️◼️POJO 是一个约定，约定为只有 private 属性以及 getter、setter、toString 方法的简单的类，相对于 EJB 的 Entity Beans 是简单轻量的。也是领域模型中 DO,DTO,VO,BO 的统称。慢慢变成一种术语，可以用来解释 JavaBeans 这个约定，就是序列化且有无参构造的 POJO◼️⭐️-point-202302020737%%</span></p><p>Spring 的非侵入编程模型意味着使用 POJO 这种类在 Spring 应用和非 Spring 应用中都可以发挥同样的作用。</p><h2 id="1-2-约定-惯例"><a href="#1-2-约定-惯例" class="headerlink" title="1.2. 约定 (惯例)"></a>1.2. 约定 (惯例)</h2><p><span style="background-color:#f0f">约定优于配置</span><br>convention over configuration</p><h2 id="1-3-依赖注入和面向接口"><a href="#1-3-依赖注入和面向接口" class="headerlink" title="1.3. 依赖注入和面向接口"></a>1.3. 依赖注入和面向接口</h2><p>就是使用聚合 + 构造导入 (或者 setter 导入) 的方式扩展<br>设计模式中大量使用这种方式</p><h2 id="1-4-Spring-的核心"><a href="#1-4-Spring-的核心" class="headerlink" title="1.4. Spring 的核心"></a>1.4. Spring 的核心</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131135415.png" alt="image.png"><br>❕<span style="display:none">%%<br>0709-🏡⭐️◼️Spring 通过 IOC 实现依赖反转，由容器创建管理 Javabean 并维护 Javabean 之间清晰松散的耦合关系，解放程序员的精力放在业务逻辑编码上，同时通过 AOP 实现面向接口编程，可以无侵入的增强业务功能，进一步减少对业务代码的侵入性◼️⭐️-point-202302010709%%</span></p><h2 id="1-5-Spring-的优缺点"><a href="#1-5-Spring-的优缺点" class="headerlink" title="1.5. Spring 的优缺点"></a>1.5. Spring 的优缺点</h2><h3 id="1-5-1-优点"><a href="#1-5-1-优点" class="headerlink" title="1.5.1. 优点"></a>1.5.1. 优点</h3><ol><li><p><strong>方便解耦，简化开发</strong><br>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p></li><li><p><strong>AOP 编程的支持</strong><br>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p></li><li><p><strong>声明式事务的支持</strong><br>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p></li><li><p><strong>方便程序的测试</strong><br>Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序。</p></li><li><p><strong>方便集成各种优秀框架</strong><br>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。</p></li><li><p><strong>降低 JavaEE API 的使用难度</strong><br>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。</p></li><li><p><strong>Java 源码是经典学习范例</strong><br>Spring 的源码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。Spring 框架源码无疑是 Java 技术的最佳实践范例。</p></li></ol><h3 id="1-5-2-缺点"><a href="#1-5-2-缺点" class="headerlink" title="1.5.2. 缺点"></a>1.5.2. 缺点</h3><ol><li>Spring 明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring 依赖反射，反射影响性能</li><li>使用门槛升高，入门 Spring 需要较长时间</li></ol><h2 id="1-6-Spring-的核心模块"><a href="#1-6-Spring-的核心模块" class="headerlink" title="1.6. Spring 的核心模块"></a>1.6. Spring 的核心模块</h2><p>^ob40ki<br>^hasxle<br>大约 20 几个模块，总共 1300 多个文件，这些组件被分别整合在：核心容器、AOP、Aspect、Instrumentation、Messing、DataAccess、Web、Test 等几大模块中<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131144911.png" alt="image.png"></p><ol><li>spring core：提供了框架的基本组成部分，<span style="background-color:#0f0">包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能</span>。</li><li>spring beans：提供了 BeanFactory，是<span style="background-color:#0f0">工厂模式的一个经典实现</span>，Spring 将管理对象称为 Bean。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring jdbc：提供了一个 JDBC 的抽象层，消除了烦琐的 JDBC 编码和数据库厂商特有的错误代码解析， 用于简化 JDBC。</li><li>spring aop：提供了面向切面的编程实现，让你可以<span style="background-color:#0f0">自定义拦截器、切点等</span>。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring test：主要为测试提供支持的，支持使用 JUnit 或 TestNG 对 Spring 组件进行单元测试和集成测试。</li></ol><h1 id="2-IOC-相关"><a href="#2-IOC-相关" class="headerlink" title="2. IOC 相关"></a>2. IOC 相关</h1><h2 id="2-1-什么是-IOC-容器"><a href="#2-1-什么是-IOC-容器" class="headerlink" title="2.1. 什么是 IOC 容器"></a>2.1. 什么是 IOC 容器</h2><p>控制反转即 IOC (Inversion of Control)，它把传统上<span style="background-color:#0f0">由程序代码</span>直接操控的对象的调用权交给容器，<span style="background-color:#0f0">通过容器来实现对象组件的装配和管理</span>。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。<br><span style="background-color:#0f0">Spring IOC 负责创建对象，管理对象（通过依赖注入（DI）），装配对象，配置对象，并且管理这些对象的整个生命周期。</span></p><h2 id="2-2-IOC-的作用和意义"><a href="#2-2-IOC-的作用和意义" class="headerlink" title="2.2. IOC 的作用和意义"></a>2.2. IOC 的作用和意义</h2><p><strong>作用</strong></p><ol><li>管理对象的创建和依赖关系的维护</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的生成过程，比如我们无需去关心类是如何完成代理的</li></ol><blockquote><p> 控制反转    控制了什么？<br>UserService service&#x3D;new UserService();   &#x2F;&#x2F; 耦合度太高 、维护不方便<br>引入 Ioc   就将创建对象的控制权交给 Spring 的 Ioc.   以前由程序员自己控制对象创建， 现在交给 Spring 的 Ioc 去创建， <br>如果要去使用对象需要通过 DI（依赖注入）@Autowired 自动注入 就可以使用对象 ;</p></blockquote><p><strong>意义</strong><br><span style="background-color:#0f0">1. IOC 容器以最小的代价和最小的侵入性使松散耦合得以实现。</span><br><span style="background-color:#0f0">2. IOC 容器支持加载服务时的饿汉式初始化和懒加载。</span><br>❕<span style="display:none">%%<br>▶10.🏡⭐️◼️IOC 容器的意义◼️⭐️-point-20230226-2231%%</span></p><h2 id="2-3-IOC-的实现机制"><a href="#2-3-IOC-的实现机制" class="headerlink" title="2.3. IOC 的实现机制"></a>2.3. IOC 的实现机制</h2><p>工厂模式 + 反射</p><h2 id="2-4-什么是-Spring-的依赖注入-DI-？IOC-和-DI-的区别是什么"><a href="#2-4-什么是-Spring-的依赖注入-DI-？IOC-和-DI-的区别是什么" class="headerlink" title="2.4. 什么是 Spring 的依赖注入 (DI)？IOC 和 DI 的区别是什么"></a>2.4. 什么是 Spring 的依赖注入 (DI)？IOC 和 DI 的区别是什么</h2><p>很多人把 IOC 和 DI 说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的，希望大家能够严谨一点，IOC 和 DI 是从不同的角度描述的同一件事，<span style="background-color:#0f0">IOC 是从容器的角度描述，而 DI 是从应用程序的角度来描述，也可以这样说，IOC 是依赖倒置原则的设计思想，而 DI 是具体的实现方式</span></p><h2 id="2-5-BeanDefinition-的作用"><a href="#2-5-BeanDefinition-的作用" class="headerlink" title="2.5. BeanDefinition 的作用"></a>2.5. BeanDefinition 的作用</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131200612.png" alt="image.png"></p><p>它主要负责存储 Bean 的定义信息，包括 beanClass、scope、lazyInit、dependsOn、autowireMode 等信息，决定 Bean 的生产方式。后续 BeanFactory 根据这些信息就行生产 Bean： 比如实例化 ，通过 class 进行反射进而得到实例对象 ， 比如 lazy  则不会在 ioc 加载时创建 Bean。</p><p>举例：由 BeanDefinition 中 Object 类型的 beanClass 强转为 String，然后通过反射得到 Class 对象<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131201517.png" alt="image.png"></p><h2 id="2-6-BeanFactory-和-ApplicationContext-有什么区别"><a href="#2-6-BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="2.6. BeanFactory 和 ApplicationContext 有什么区别"></a>2.6. BeanFactory 和 ApplicationContext 有什么区别</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131120831.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131120859.png" alt="image.png"></p><h3 id="2-6-1-答案-2"><a href="#2-6-1-答案-2" class="headerlink" title="2.6.1. 答案 2"></a>2.6.1. 答案 2</h3><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。其中 ApplicationContext 是 BeanFactory 的子接口。</p><h4 id="2-6-1-1-功能大小"><a href="#2-6-1-1-功能大小" class="headerlink" title="2.6.1.1. 功能大小"></a>2.6.1.1. 功能大小</h4><ol><li>BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。</li><li>ApplicationContext 接口作为 BeanFactory 的派生，除了提供 BeanFactory 所具有的功能外，<span style="background-color:#0f0">还提供了更完整的框架功能</span>：<blockquote><p>继承 MessageSource，因此支持国际化。<br>统一的资源文件访问方式。<br>提供在监听器中注册 bean 的事件。<br>同时加载多个配置文件。<br>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。</p></blockquote></li></ol><p>资源文件访问方式： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kongbubihai/p/15915434.html">https://www.cnblogs.com/kongbubihai/p/15915434.html</a></p><h4 id="2-6-1-2-加载方式"><a href="#2-6-1-2-加载方式" class="headerlink" title="2.6.1.2. 加载方式"></a>2.6.1.2. 加载方式</h4><ol><li>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，<span style="background-color:#f0f">即只有在使用到某个 Bean 时 (调用 getBean())，才对该 Bean 进行加载实例化</span>。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入，BeanFacotry 加载后，直至第一次使用调 getBean 方法才会抛出异常。</li><li>ApplicationContext，它是<span style="background-color:#f0f">在容器启动时，一次性创建了所有的 Bean</span>。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ，确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131212230.png" alt="image.png"></p><p>下面的 3 个绿色的，都是功能扩展接口。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：<span style="background-color:#0f0">支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）</span>。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置。生命周期事件回调等。</p><h2 id="2-7-BeanFactory-和-FactoryBean-有什么区别"><a href="#2-7-BeanFactory-和-FactoryBean-有什么区别" class="headerlink" title="2.7. BeanFactory 和 FactoryBean 有什么区别"></a>2.7. BeanFactory 和 FactoryBean 有什么区别</h2><ol><li>BeanFactory 是一个工厂，也就是一个容器，是来管理和生产 bean 的；</li><li>Spring 中有两种类型的 bean，一种是普通 bean，另一种是工厂 bean，即 FactoryBean。工厂 bean 跟普通 bean 不同，其返回的对象不是指定类的一个实例，其返回的是该工厂 bean 的 <code>getObject</code> 方法所返回的对象。工厂 bean 必须实现 <code>org.springframework.beans.factory.FactoryBean</code> 接口。</li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131210539.png" alt="image.png"></p><h2 id="2-8-有哪些不同类型的依赖注入实现方式"><a href="#2-8-有哪些不同类型的依赖注入实现方式" class="headerlink" title="2.8. 有哪些不同类型的依赖注入实现方式"></a>2.8. 有哪些不同类型的依赖注入实现方式</h2><p>依赖注入是时下最流行的 IOC 实现方式，依赖注入分为接口注入（Interface Injection），Setter 方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。<span style="background-color:red">其中接口注入由于在灵活性和易用性比较差，现在从 Spring4 开始已被废弃。</span><br><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br><strong>Setter 方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131214444.png" alt="image.png"></p><p>最佳实践<br>两种依赖方式都可以使用，构造器注入和 Setter 方法注入。<span style="background-color:#f0f">最好的解决方案是用构造器参数实现强制依赖，即组合的方式；setter 方法实现可选依赖，即聚合的方式。</span></p><h2 id="2-9-Spring-中配置-注册-Bean-的方式⭐️🔴"><a href="#2-9-Spring-中配置-注册-Bean-的方式⭐️🔴" class="headerlink" title="2.9. Spring 中配置 (注册)Bean 的方式⭐️🔴"></a>2.9. Spring 中配置 (注册)Bean 的方式⭐️🔴</h2><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><h2 id="2-10-BeanDefinition-的加载过程"><a href="#2-10-BeanDefinition-的加载过程" class="headerlink" title="2.10. BeanDefinition 的加载过程"></a>2.10. BeanDefinition 的加载过程</h2><h1 id="3-生命周期相关"><a href="#3-生命周期相关" class="headerlink" title="3. 生命周期相关"></a>3. 生命周期相关</h1><h2 id="3-1-Spring-框架中-bean-的生命周期⭐️🔴⭐️🔴"><a href="#3-1-Spring-框架中-bean-的生命周期⭐️🔴⭐️🔴" class="headerlink" title="3.1. Spring 框架中 bean 的生命周期⭐️🔴⭐️🔴"></a>3.1. Spring 框架中 bean 的生命周期⭐️🔴⭐️🔴</h2><p>^fkjjz0</p><h3 id="3-1-1-BD-相关"><a href="#3-1-1-BD-相关" class="headerlink" title="3.1.1. BD 相关"></a>3.1.1. BD 相关</h3><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><h3 id="3-1-2-整体流程"><a href="#3-1-2-整体流程" class="headerlink" title="3.1.2. 整体流程"></a>3.1.2. 整体流程</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230131224135.png" alt="image.png"></p><ol><li>Spring 对 bean 进行实例化；</li><li>Spring 将值和 bean 的引用注入到 bean 对应的属性中；</li><li>如果 bean 实现了 BeanNameAware 接口，Spring 将 bean 的 ID 传递给 setBean-Name() 方法；</li><li>如果 bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，BeanFactory 容器实例传入；</li><li>如果 bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 postProcessBeforeInitialization() 方法；</li><li>如果 bean 实现了 InitializingBean 接口，Spring 将调用它们的 after-PropertiesSet() 方法。类似地，如果 bean 使用 initmethod 声明了初始化方法，该方法也会被调用；</li><li>如果 bean 实现了 BeanPostProcessor 接口，Spring 将调用它们的 post-ProcessAfterInitialization() 方法；</li></ol><p>此时，bean 已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；<br>如果 bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy() 接口方法。同样，如果 bean 使用 destroy-method 声明了销毁方法，该方法也会被调用。</p><h3 id="3-1-3-后置处理器相关⭐️🔴⭐️🔴"><a href="#3-1-3-后置处理器相关⭐️🔴⭐️🔴" class="headerlink" title="3.1.3. 后置处理器相关⭐️🔴⭐️🔴"></a>3.1.3. 后置处理器相关⭐️🔴⭐️🔴</h3><p>^n9drb6<br><span style="display:none">%%<br>▶10.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230321-2309%%</span>❕ ^jyw4v5</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230206174637.png" alt="image.png"><br>❕<span style="display:none">%%<br>1056-🏡⭐️◼️记忆方式 ?🔜MSTM📝 AutowiredAnnotationBPP&#x2F;CommonAnnotationBPP&#x3D;MI; AbstractAutoproxyCreator&#x3D;SB◼️⭐️-point-202302081056%%</span></p><ol><li><p>&#x3D;&#x3D;doCreateBean 之前&#x3D;&#x3D;，<code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation()</code><br>①可以提前返回一个代理对象，而终止 bean 的创建给 BeanPostProcessors 一个机会来返回代理来替代真正的实例，应用实例化前的前置处理器，用户自定义动态代理的方式，针对于当前的被代理类需要经过标准的代理流程来创建对象。如果使用该扩展点，可以直接返回代理对象。<br>② <a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></p></li><li><p>&#x3D;&#x3D;在实例化之前&#x3D;&#x3D;，即 <code>createBeanInstance</code> 之前还可以利用 <code>SmartInstantiationAwareBeanPostProcessor</code> 的 <code>determineCandidateConstructors</code> 方法来指定构造函数</p><hr></li><li><p>①在<span style="background-color:#0f0">实例化之后属性赋值之前</span>，在 <code>MergedBeanDefinitionPostProcessor</code> 的子实现接口 <code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessMergedBeanDefinition</code> 方法中，解析@Autowired @Value 转换为 InjectionMetadata 并缓存在 <code>injectionMetadataCache</code> 中</p></li></ol><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a><p>注意：<span style="background-color:#f0f">@Lazy 是 BD 属性，不是 Bean 属性，所以没有预解析的逻辑，只有 BeanDefinition 的解析逻辑，在第 5 大步中，不在 9 大后置处理器中。</span><br><a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a></p><p>②在<span style="background-color:#0f0">实例化之后属性赋值之前</span>，在 <code>MergedBeanDefinitionPostProcessor</code> 的子实现接口 <code>InitDestroyAnnotationBeanPostProcessor</code> 的子类 <code>CommonAnnotationBeanPostProcessor</code> 的 <code>postProcessMergedBeanDefinition</code> 方法中，处理@PostConstruct 和@PreDestroy 注解，调用父类 <code>InitDestroyAnnotationBeanPostProcessor</code> 的 <code>findLifecycleMetadata</code> 方法构建 lifecycleMetadata 并缓存在 <code>lifecycleMetadataCache</code> 中<br><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a></p><ol start="4"><li><p>在<span style="background-color:#0f0">实例化之后属性赋值之前</span>，将 <code>SmartInstantiationAwareBeanPostProcessor</code> 的子实现接口 <code>AbstractAutoProxyCreator</code> 的 <code>getEarlyBeanReference</code> 方法作为钩子函数放入三级缓存，待到依赖方真正赋值时，调用 <code>singletonFactory.getObject()</code> 就会返回被依赖方的动态代理对象，从而解决了 AOP 的循环依赖问题 ❕<span style="display:none">%%<br>1925-🏡⭐️◼️AbstractAutoProxyCreator 的作用原理 ?🔜MSTM📝 实例化之后属性赋值之前，将 AbstractAutoProxyCreator 的 getEarlyReferenceBean 方法作为钩子函数放入三级缓存，在依赖方属性填充时会获取到三级缓存并执行 singletonFactory. getObject，届时会调用 getEarlyReferenceBean，如果有 aop 的 BPP，就会返回一个动态代理对象◼️⭐️-point-202302051925%%</span></p><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-2%E3%80%81IOC/" title="Spring-2、IOC">Spring-2、IOC</a></li><li><p>在 <code>applyPropertyValues</code> <span style="background-color:#0f0">真正赋值之前</span>，与 1 相同的，<code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessAfterInstantiation</code>，如果实现改接口重写该方法，可以跳过属性赋值的步骤</p></li><li><p>在 <code>applyPropertyValues</code> <span style="background-color:#0f0">真正赋值之前</span>，与 3-①相对应的，<code>InstantiationAwareBeanPostProcessor</code> 的子实现接口 <code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessProperties</code> 方法中完成 bean 中@Autowired，@Inject，@Value 注解的解析并注入<br><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a></p><a href="/2023/02/11/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-9%E3%80%81@Lazy/" title="Spring-9、@Lazy">Spring-9、@Lazy</a> @Lazy 的赋值是在这里</li></ol><hr><ol start="7"><li>在 <code>invokeInitMethods</code> <span style="background-color:#f0f">初始化之前</span>，与 3-②相对应的，BeanPostProcessor 的子类 <code>InitDestroyAnnotationBeanPostProcessor</code> 会调用 <code>postProcessBeforeInitialization</code> 方法，此时 <code>@PostConstruct</code> 注解的方法会被调用。确切的说应该是在 <code>afterPropertiesSet</code> 之前调用，这与 xml 方式配置的方式不同，后者是在 <code>afterPropertiesSet</code> 之后，执行 <code>invokeInitMethods</code> 之前调用<a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a></li></ol><hr><ol start="8"><li>在<span style="background-color:red">初始化完成之后</span>，如果有用到，则会调用 <code>BeanPostProcessor</code> 的子实现类 <code>AbstractAutoProxyCreator</code> 的 <code>postProcessAfterInitialization()</code> 方法来生成动态代理</li></ol><p>❕<span style="display:none">%%<br>0720-🏡⭐️◼️解析切面的地方 ?🔜MSTM📝 第一个 PP，InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation 中，解析切面并缓存所有通知到 advisorsCache 中◼️⭐️-point-202302120720%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230303112858.png"></p><h3 id="3-1-4-生命周期回调相关"><a href="#3-1-4-生命周期回调相关" class="headerlink" title="3.1.4. 生命周期回调相关"></a>3.1.4. 生命周期回调相关</h3><h4 id="3-1-4-1-初始化之前执行的生命周期的回调"><a href="#3-1-4-1-初始化之前执行的生命周期的回调" class="headerlink" title="3.1.4.1. 初始化之前执行的生命周期的回调"></a>3.1.4.1. 初始化之前执行的生命周期的回调</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230205210842.png" alt="image.png"></p><p><span style="background-color:#f0f">真正初始化之前执行的生命周期回调</span> ❕<span style="display:none">%%<br>2116-🏡⭐️◼️扩展点 7 中的 3 个都在哪里 ?🔜MSTM📝 ApplicationContextAwareBPP、ImportAwareBPP、InitDestoryAnnotationBPP 都是在真正初始方法执行之前执行◼️⭐️-point-202302052116%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230201134805.png" alt="image.png"><br>❕<span style="display:none">%%<br>2237-🏡⭐️◼️invokeAwareMethods 方法有个重要点 ?🔜MSTM📝 就是对于实现 BeanFactoryAware 接口的 BPP，会设置 BeanFactory，在这个地方，AOP 设置了重要的属性 advisorRetrievalHelper、aspectJAdvisorsBuilder、aspectJAdvisorFactory，用于在后面实例化之前解析切面缓存通知◼️⭐️-point-20230216-2237%%</span></p><h4 id="3-1-4-2-初始化之后的生命周期的回调"><a href="#3-1-4-2-初始化之后的生命周期的回调" class="headerlink" title="3.1.4.2. 初始化之后的生命周期的回调"></a>3.1.4.2. 初始化之后的生命周期的回调</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230201134931.png" alt="image.png"></p><h2 id="3-2-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#3-2-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="3.2. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>3.2. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h2><h3 id="3-2-1-XML"><a href="#3-2-1-XML" class="headerlink" title="3.2.1. XML"></a>3.2.1. XML</h3><p>在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用 autowire 来配置自动装载模式。<br>在 Spring 框架 xml 配置中共有 5 种自动装配：</p><ol><li>no：<span style="background-color:#ff0">默认的方式是不进行自动装配的</span>，通过手工设置 ref 属性来进行装配 bean。</li><li>byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。</li></ol><h3 id="3-2-2-注解"><a href="#3-2-2-注解" class="headerlink" title="3.2.2. 注解"></a>3.2.2. 注解</h3><h4 id="3-2-2-1-Autowired-与-Qualifier"><a href="#3-2-2-1-Autowired-与-Qualifier" class="headerlink" title="3.2.2.1. @Autowired 与@Qualifier"></a>3.2.2.1. @Autowired 与@Qualifier</h4><ol><li>@Autowired 是<span style="background-color:red">根据类型自动装配</span>的，加上@Qualifier 则可以根据 byName 的方式自动装配。</li><li>@Qualifier 不能单独使用。</li></ol><h4 id="3-2-2-2-Autowired-与-Resource-异同"><a href="#3-2-2-2-Autowired-与-Resource-异同" class="headerlink" title="3.2.2.2. @Autowired 与@Resource 异同"></a>3.2.2.2. @Autowired 与@Resource 异同</h4><ol><li>@Autowired 与@Resource 都可以用来装配 bean。都可以写在字段上，或写在 setter 方法上。</li><li><span style="background-color:#f0f">@Autowired 默认按类型装配</span>（属于 Spring 规范），默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false，如：@Autowired(required&#x3D;false)。<span style="background-color:#f0f">如果我们想使用名称装配可以结合@Qualifier 注解进行使用</span></li><li>@Resource（属于 J2EE 复返），<span style="background-color:#f0f">默认按照名称进行装配</span>，名称可以通过 name 属性进行指定。如果没有指定 name 属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter 方法上默认取属性名进行装配。<span style="background-color:#0f0">当找不到与名称匹配的 bean 时才按照类型进行装配</span>。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。</li><li>它们的作用相同都是用注解方式注入对象，但执行顺序不同。<span style="background-color:#f0f">@Autowired 先 byType，@Resource 先 byName。</span></li></ol><p>PS: Autowired 根据类型装配的原因：<br>!<a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/King_weng/article/details/122057561">https://blog.csdn.net/King_weng/article/details/122057561</a></p><h2 id="3-3-哪些是重要的-bean-生命周期方法-能否重载"><a href="#3-3-哪些是重要的-bean-生命周期方法-能否重载" class="headerlink" title="3.3. 哪些是重要的 bean 生命周期方法 能否重载"></a>3.3. 哪些是重要的 bean 生命周期方法 能否重载</h2><p>有两个重要的 bean 生命周期方法，第一个是 setup ， 它是在容器加载 bean 的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</p><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><h2 id="3-4-使用-Autowired-注解自动装配的过程是怎样的⭐️🔴"><a href="#3-4-使用-Autowired-注解自动装配的过程是怎样的⭐️🔴" class="headerlink" title="3.4. 使用@Autowired 注解自动装配的过程是怎样的⭐️🔴"></a>3.4. 使用@Autowired 注解自动装配的过程是怎样的⭐️🔴</h2><p>^ov9bn5</p><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-10%E3%80%81@Autowired/" title="Spring-10、@Autowired">Spring-10、@Autowired</a><h2 id="3-5-PostConstruct-原理⭐️🔴⭐️🔴"><a href="#3-5-PostConstruct-原理⭐️🔴⭐️🔴" class="headerlink" title="3.5. @PostConstruct 原理⭐️🔴⭐️🔴"></a>3.5. @PostConstruct 原理⭐️🔴⭐️🔴</h2><p>^ry6di8</p><a href="/2023/02/19/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-11%E3%80%81@PostConstruct/" title="Spring-11、@PostConstruct">Spring-11、@PostConstruct</a><h2 id="3-6-如何在-Spring-创建完所有-bean-之后做扩展"><a href="#3-6-如何在-Spring-创建完所有-bean-之后做扩展" class="headerlink" title="3.6. 如何在 Spring 创建完所有 bean 之后做扩展"></a>3.6. 如何在 Spring 创建完所有 bean 之后做扩展</h2><h3 id="3-6-1-基于-SmartInitializingSingleton-接口"><a href="#3-6-1-基于-SmartInitializingSingleton-接口" class="headerlink" title="3.6.1. 基于 SmartInitializingSingleton 接口"></a>3.6.1. 基于 SmartInitializingSingleton 接口</h3><p>在创建所有单例 Bean 的方法中： </p><p>1 finishBeanFactoryInitialization(beanFactory);<br>SmartInitializingSingleton 接口是在所有的 Bean 实例化完成以后，Spring 回调的方法, <br>所以这里也是一个扩展点，可以在单例 bean 全部完成实例化以后做处理。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202161432.png" alt="image.png"></p><h3 id="3-6-2-基于-Spring-事件监听"><a href="#3-6-2-基于-Spring-事件监听" class="headerlink" title="3.6.2. 基于 Spring 事件监听"></a>3.6.2. 基于 Spring 事件监听</h3><p>生命周期的最后一步是 finishRefresh();，这里面中有一个方法是 publishEvent<br>所以这里也可以进行扩展，监听 ContextRefreshedEvent 事件 。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202161549.png" alt="image.png"></p><h2 id="3-7-Spring-容器启动时，为什么先加载-BeanFactoryPostProcess"><a href="#3-7-Spring-容器启动时，为什么先加载-BeanFactoryPostProcess" class="headerlink" title="3.7. Spring 容器启动时，为什么先加载 BeanFactoryPostProcess"></a>3.7. Spring 容器启动时，为什么先加载 BeanFactoryPostProcess</h2><ol><li>因为 BeanDefinition 会在 ioc 容器加载的先注册， 而 BeanFactoryPostProcess 就是在所有的 BeanDefinition 注册完后做扩展的，所以要先加载 BeanFactoryPostProcess</li><li>解析配置类的组件  它就实现 BeanFactoryPostProcess， 所以要先去加载 BeanFactoryPostProcess</li></ol><h1 id="4-BeanDefinition-相关"><a href="#4-BeanDefinition-相关" class="headerlink" title="4. BeanDefinition 相关"></a>4. BeanDefinition 相关</h1><h2 id="4-1-BeanDefinition-的注册顺序"><a href="#4-1-BeanDefinition-的注册顺序" class="headerlink" title="4.1. BeanDefinition 的注册顺序"></a>4.1. BeanDefinition 的注册顺序</h2><p>1. @Configuration   <br>2. @Component <br>3. @Import—类<br>4. @Bean<br>5. @Import—ImportBeanDefinitionRegistrar</p><p>详细版<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202171228.png" alt="image.png"></p><h1 id="5-线程相关"><a href="#5-线程相关" class="headerlink" title="5. 线程相关"></a>5. 线程相关</h1><h2 id="5-1-Spring-如何处理线程并发问题⭐️🔴"><a href="#5-1-Spring-如何处理线程并发问题⭐️🔴" class="headerlink" title="5.1. Spring 如何处理线程并发问题⭐️🔴"></a>5.1. Spring 如何处理线程并发问题⭐️🔴</h2><p>^yqybkq<br>在一般情况下，只有无状态的 Bean 才可以在多线程环境下共享，在 Spring 中，绝大部分 Bean 都可以声明为 singleton 作用域，因为 Spring 对一些 Bean 中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题。</p><p>&#x3D;&#x3D;ThreadLocal&#x3D;&#x3D; 和 &#x3D;&#x3D;线程同步机制&#x3D;&#x3D;都是为了解决多线程中相同变量的访问冲突问题。<span style="background-color:#0f0">同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队</span>。<span style="background-color:#f0f">而 ThreadLocal 采用了“空间换时间”的方式</span>。</p><p>ThreadLocal 会为每一个线程提供一个<span style="background-color:#0f0">独立的变量副本</span>，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal</p><h1 id="6-设计模式相关"><a href="#6-设计模式相关" class="headerlink" title="6. 设计模式相关"></a>6. 设计模式相关</h1><h2 id="6-1-Spring-中用到了哪些设计模式⭐️🔴⭐️🔴"><a href="#6-1-Spring-中用到了哪些设计模式⭐️🔴⭐️🔴" class="headerlink" title="6.1. Spring 中用到了哪些设计模式⭐️🔴⭐️🔴"></a>6.1. Spring 中用到了哪些设计模式⭐️🔴⭐️🔴</h2><ol><li>单例模式：Bean 默认为单例模式 [[内功心法专题-设计模式-3、单例模式]] ^4jhz9m</li><li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例 [[内功心法专题-设计模式-4、工厂模式]]</li><li>原型模式: [[内功心法专题-设计模式-5、原型模式]]</li><li>建造者模式: [[内功心法专题-设计模式-6、建造者模式]]</li><li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；<a href="/2023/01/12/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="设计模式-7、代理模式">设计模式-7、代理模式</a></li><li>适配器模式: <a href="/2023/01/13/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="设计模式-8、适配器模式">设计模式-8、适配器模式</a></li><li>装饰者模式: [[内功心法专题-设计模式-9、装饰者模式]]</li><li>桥接模式: <a href="/2023/01/14/009-%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95%E4%B8%93%E9%A2%98/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10%E3%80%81%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="设计模式-10、桥接模式">设计模式-10、桥接模式</a></li><li>组合模式：[[内功心法专题-设计模式-12、组合模式]]</li><li>享元模式：[[内功心法专题-设计模式-13、享元模式]]</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate [[内功心法专题-设计模式-14、模板方法模式]]</li><li>策略模式：[[内功心法专题-设计模式-15、策略模式]]</li><li>命令模式：[[内功心法专题-设计模式-16、命令模式]]</li><li>责任链模式：[[内功心法专题-设计模式-17、责任链模式]]</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring 中 listener 的实现 ApplicationListener [[内功心法专题-设计模式-19、观察者模式]]</li><li>迭代器模式：[[内功心法专题-设计模式-21、迭代器模式]]</li><li>解释器模式：[[内功心法专题-设计模式-24、解释器模式]]<br>❕<span style="display:none">%%<br>2129-🏡⭐️◼️Spring 中用到了哪些设计模式 ?🔜MSTM📝 23 种设计模式中用到了 17 种，其中抽象工厂模式、外观模式、状态模式、中介者模式、访问者模式、备忘录模式 6 种没有使用到◼️⭐️-point-202302052129%%</span></li></ol><h2 id="6-2-单例-bean-的优势"><a href="#6-2-单例-bean-的优势" class="headerlink" title="6.2. 单例 bean 的优势"></a>6.2. 单例 bean 的优势</h2><ol><li>减少了新生成实例的消耗。新生成实例消耗包括两方面：第一，spring 会通过反射或者 cglib 来生成 bean 实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。 提供服务器内存的利用率 ，减少服务器内存消耗  </li><li>减少 jvm 垃圾回收由于不会给每个请求都新生成 bean 实例，所以自然回收的对象少了。</li><li>可以快速获取到 bean 因为单例的获取 bean 操作除了第一次生成之外其余的都是从缓存里获取的所以很快。❕<span style="display:none">%%<br>2135-🏡⭐️◼️单例 bean 有哪些好处 ?🔜MSTM📝 1. 减少了生成新实例的性能消耗，包括两部分：Spring 通过反射或者 cglib 方式生成对象的性能消耗、为对象分配内存的性能消耗。2. 减少 JVM 的 GC 和 STW。3. 可以快速获得 bean ◼️⭐️-point-202302052135%%</span></li></ol><h1 id="7-注解相关"><a href="#7-注解相关" class="headerlink" title="7. 注解相关"></a>7. 注解相关</h1><h2 id="7-1-Spring-有哪几种配置方式"><a href="#7-1-Spring-有哪几种配置方式" class="headerlink" title="7.1. Spring 有哪几种配置方式"></a>7.1. Spring 有哪几种配置方式</h2><p> 这里有三种重要的方法给 Spring 容器提供配置元数据。</p><p>1. XML 配置文件。  spring 诞生<br>spring.xml    <code> &lt;bean&gt;</code></p><p>2. 基于注解的配置。  Spring2.5+<br>spring.xml  + @Component  @Autowired</p><p>3. 基于 java 的配置。 JavaConfig  Spring3.0+<br>@Configuration   @Bean   ….</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230321224533.png" alt="image.png"></p><h2 id="7-2-JavaConfig-与-XML-方式-Spring-配置的不同⭐️🔴"><a href="#7-2-JavaConfig-与-XML-方式-Spring-配置的不同⭐️🔴" class="headerlink" title="7.2. JavaConfig 与 XML 方式 Spring 配置的不同⭐️🔴"></a>7.2. JavaConfig 与 XML 方式 Spring 配置的不同⭐️🔴</h2><p>^b5hhm9</p><a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230203164128.png" alt="image.png"></p><h3 id="7-2-1-JavaConfig"><a href="#7-2-1-JavaConfig" class="headerlink" title="7.2.1. JavaConfig"></a>7.2.1. JavaConfig</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204122011.png" alt="image.png"></p><p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/63dd8eb4b59543238fa3a6a5">https://www.processon.com/diagraming/63dd8eb4b59543238fa3a6a5</a></p><h4 id="7-2-1-1-注册核心-BPP"><a href="#7-2-1-1-注册核心-BPP" class="headerlink" title="7.2.1.1. 注册核心 BPP"></a>7.2.1.1. 注册核心 BPP</h4><ol><li>在 <code>new AnnotationConfigApplicationContext(MainConfig.class)</code> 中的 <code>this</code> 方法中 <code>AnnotatedBeanDefinitionReader</code> 为工厂注册 6 大内置核心组件，其中 <code>ConfigurationClassPostProcessor</code> 是用来处理配置类的</li><li><code>刷新第5步：invokeBeanFactoryPostProcessors()</code><br><span style="background-color:#f0f">getBean</span> <code>ConfigurationClassPostProcessor</code></li></ol><h4 id="7-2-1-2-读取配置类-注册配置类"><a href="#7-2-1-2-读取配置类-注册配置类" class="headerlink" title="7.2.1.2. 读取配置类 (注册配置类)"></a>7.2.1.2. 读取配置类 (注册配置类)</h4><p>在 <code>new AnnotationConfigApplicationContext(MainConfig.class)</code> 中的 <code>register(componentClasses)</code> 方法中使用 <code>AnnotatedBeanDefinitionReader</code> 注册配置类</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230203195618.png" alt="image.png"></p><h4 id="7-2-1-3-解析配置类-扫描注册引入类"><a href="#7-2-1-3-解析配置类-扫描注册引入类" class="headerlink" title="7.2.1.3. 解析配置类 (扫描注册引入类)"></a>7.2.1.3. 解析配置类 (扫描注册引入类)</h4><p>执行 <code>ConfigurationClassPostProcessor</code> 的 <code>postProcessor.postProcessBeanDefinitionRegistry()</code> 方法，把【配置类中的】所有 bean 的定义信息导入进来。由 ConfigurationClassParser 解析每一个配置类</p><p>核心方法，将完全填充好的 ConfigurationClass 实例转化为 BeanDefinition 注册入 IOC 容器 <code>this.reader.loadBeanDefinitions(configClasses)</code></p><h3 id="7-2-2-XML"><a href="#7-2-2-XML" class="headerlink" title="7.2.2. XML"></a>7.2.2. XML</h3><p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/63ddb70fc12afe0cadb59d2c">https://www.processon.com/diagraming/63ddb70fc12afe0cadb59d2c</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204121938.png" alt="image.png"></p><h4 id="7-2-2-1-读取配置文件"><a href="#7-2-2-1-读取配置文件" class="headerlink" title="7.2.2.1. 读取配置文件"></a>7.2.2.1. 读取配置文件</h4><h5 id="7-2-2-1-1-XmlBeanDefinitionReader"><a href="#7-2-2-1-1-XmlBeanDefinitionReader" class="headerlink" title="7.2.2.1.1. XmlBeanDefinitionReader"></a>7.2.2.1.1. XmlBeanDefinitionReader</h5><h5 id="7-2-2-1-2-DefaultDocumentLoader"><a href="#7-2-2-1-2-DefaultDocumentLoader" class="headerlink" title="7.2.2.1.2. DefaultDocumentLoader"></a>7.2.2.1.2. DefaultDocumentLoader</h5><p>此处获取 xml 文件的 document 对象，这个解析过程是由 documentLoader 完成的，最终开始将 resource 读取成一个 document 文档<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204095148.png" alt="image.png"></p><h4 id="7-2-2-2-解析配置类"><a href="#7-2-2-2-解析配置类" class="headerlink" title="7.2.2.2. 解析配置类"></a>7.2.2.2. 解析配置类</h4><h5 id="7-2-2-2-1-DefaultBeanDefinitionDocumentReader"><a href="#7-2-2-2-1-DefaultBeanDefinitionDocumentReader" class="headerlink" title="7.2.2.2.1. DefaultBeanDefinitionDocumentReader"></a>7.2.2.2.1. <strong>DefaultBeanDefinitionDocumentReader</strong></h5><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204095229.png" alt="image.png"></p><h2 id="7-3-Component-Controller-Repository-Service"><a href="#7-3-Component-Controller-Repository-Service" class="headerlink" title="7.3. Component Controller Repository Service"></a>7.3. Component Controller Repository Service</h2><ol><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ol><h2 id="7-4-Import-可以有几种用法-注册-BD-方法"><a href="#7-4-Import-可以有几种用法-注册-BD-方法" class="headerlink" title="7.4. @Import 可以有几种用法 (注册 BD 方法)"></a>7.4. @Import 可以有几种用法 (注册 BD 方法)</h2><a href="/2022/12/03/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Spring-1、基本原理">Spring-1、基本原理</a><p><strong>4 种</strong><br>1. 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成 Bean)<br>2. 通过<span style="background-color:#0f0">实现 ImportSelector 接口</span> 可以一次性注册多个，返回一个 string[]  每一个值就是类的完整类路径<br>a. 通过<span style="background-color:#0f0">实现 DeferredImportSelector 接口</span>可以一次性注册多个，返回一个 string[]  每一个值就是类的完整类路径<br>i. 区别：DeferredImportSelector 顺序靠后<br>3. 通过<span style="background-color:#0f0">实现 ImportBeanDefinitionRegistrar 接口</span>可以一次性注册多个，通过 BeanDefinitionRegistry 来动态注册 BeanDefinition</p><h2 id="7-5-Configuration-的作用解析原理"><a href="#7-5-Configuration-的作用解析原理" class="headerlink" title="7.5. @Configuration 的作用解析原理"></a>7.5. @Configuration 的作用解析原理</h2><p>@Configuration 用来代替 xml 配置方式 spring.xml 配置文件 bean 的吗？不全对<br>因为没有@Configuration 也是可以配置@Bean</p><h3 id="7-5-1-Configuration-加与不加有什么区别"><a href="#7-5-1-Configuration-加与不加有什么区别" class="headerlink" title="7.5.1. @Configuration 加与不加有什么区别"></a>7.5.1. @Configuration 加与不加有什么区别</h3><p><strong>作用：</strong><br>加了@Configuration 会为配置类创建 cglib 动态代理（保证配置类@Bean 方法调用 Bean 的单例），@Bean 方法的调用就会通过容器 getBean 进行获取<br><strong>原理：</strong></p><ol><li>创建 Spring 上下文的时候会在 this() 方法中注册一个解析配置的处理器 ConfigurationClassPostProcessor（它实现了 BeanFactoryPostProcessor 和<br>BeanDefinitionRegistryPostProcessor)</li><li>在 refresh () 方法第 5 步中，调用 <code>invokeBeanFactoryPostProcessor</code>，就会去调用<br><code>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry</code> 进行解析配置（解析配置类就是去解析并注册各种注解的 BeanDefinition，比如@Bean @Configuration @Import @Component … 把这些注解的 BeanDefinition 解析并放入 BeanDefinitionMap 中</li><li>调用 invokeBeanFactoryPostProcessors，还会调用 <code>ConfigurationClassPostProcessor.postProcessBeanFactory</code>，在里面会调用 <code>enhanceConfigurationClasses(beanFactory)</code> 方法来创建 cglib 动态代理</li></ol><h2 id="7-6-Bean-之间的方法调用是怎么保证单例的"><a href="#7-6-Bean-之间的方法调用是怎么保证单例的" class="headerlink" title="7.6. @Bean 之间的方法调用是怎么保证单例的"></a>7.6. @Bean 之间的方法调用是怎么保证单例的</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1t44y1C73F?p=45&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1t44y1C73F?p=45&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>（ @Configuration 加与不加的区别是什么？）<br>1.如果希望@bean 的方法返回是对象是单例  需要在类上面加上@Configuration,<br>2.Spring 会在 invokeBeanFactoryPostProcessor  通过内置 BeanFactoryPostProcessor 中会 CGLib 生成动态代理代理<br>3.当@Bean 方法进行互调时， 则会通过 CGLIB 进行增强，通过调用的方法名作为 bean 的名称去 ioc 容器中获取，进而保证了@Bean 方法的单例</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202191415.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202191651.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230204165509.png" alt="image.png"></p><h1 id="8-AOP-相关"><a href="#8-AOP-相关" class="headerlink" title="8. AOP 相关"></a>8. AOP 相关</h1><h2 id="8-1-是什么做什么"><a href="#8-1-是什么做什么" class="headerlink" title="8.1. 是什么做什么"></a>8.1. 是什么做什么</h2><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p>可用于权限认证、日志、事务处理等。</p><p>AOP、OOP 在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP(面向对象编程) 针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而 AOP 作为面向对象的一种补充，则是针对业务处理过程中的切面进行提取， 已达到业务代码和公共行为代码之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p><h2 id="8-2-各种概念关系"><a href="#8-2-各种概念关系" class="headerlink" title="8.2. 各种概念关系"></a>8.2. 各种概念关系</h2><ol><li>AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。<a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></li><li>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理</li><li>Objenesis 是 CGLIB 的增强，不需要构造函数就可以代理</li></ol><blockquote><p><span style="background-color:#f0f">直接使用注入的代理类的属性是不行的</span><br>当我们@Autowired 注入了代理类，如果想当然的直接使用被注入对象的属性，则一定会报空指针，而我们正常情况为什么没有发生问题呢，原因是我们一般都是调用该对象的方法，而不是直接使用其中的属性的，而调用其中的方法，则代理类处理完切面任务之后，会进入到真正的对象，而真正的对象里的各个属性都是有值的，不会发生空指针。</p></blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30095631/article/details/108086616">https://blog.csdn.net/qq_30095631/article/details/108086616</a></p><h2 id="8-3-解释一下-Spring-AOP-里面的几个名词"><a href="#8-3-解释一下-Spring-AOP-里面的几个名词" class="headerlink" title="8.3. 解释一下 Spring AOP 里面的几个名词"></a>8.3. 解释一下 Spring AOP 里面的几个名词</h2><p>（1）<strong>连接点（Join point</strong>）： 指定就是被增强的业务方法<br>（2）<strong>切面（Aspect）</strong>：  在 Spring Aop 指定就是“切面类” ，<span style="background-color:#0f0">切面类管理着切点、通知</span>。<br>（3）<strong>切点（Pointcut）</strong>：  <span style="background-color:#0f0">由他决定哪些方法需要增强、哪些不需要增强，  结合切点表达式进行实现</span><br>（4）<strong>通知（Advice）</strong>：     <span style="background-color:#0f0">就是需要增加到业务方法中的公共代码，通知有很多种类型分别可以在需要增加的业务方法</span><br>不同位置进行执行（前置通知、后置通知、异常通知、返回通知、环绕通知）<br>（5）目标对象（Target Object）：  指定是增强的对象<br>（6）<strong>织入（Weaving）</strong> ：  spring aop 用的织入方式：动态代理。  就是为目标对象创建动态代理的过程就叫织入。</p><h2 id="8-4-Spring-通知有哪些类型？"><a href="#8-4-Spring-通知有哪些类型？" class="headerlink" title="8.4. Spring 通知有哪些类型？"></a>8.4. Spring 通知有哪些类型？</h2><p>在 AOP 术语中，在的某个特定的连接点上执行的动作<br>Spring 切面可以应用 5 种类型的通知：<br>1. 前置通知（Before）：在目标方法被调用之前调用通知功能；<br>2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；<br>3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；<br>4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；<br>5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p><p>执行顺序：</p><p>1、正常执行：<br>@Around &gt; @Before ­­­&gt;方法 &gt; @After ­­­­&gt; @AfterReturning ­­­ &gt; @Around<br>2、异常执行：<br>@Around &gt; @Before­­­&gt;方法 &gt; @After­­­­ &gt; @AfterThrowing­­­</p><p>Spring 在<span style="background-color:#f0f">5.2.7 之后</span>就改变的 advice 的执行顺序</p><p>1、正常执行：<br>@Around &gt; @Before ­­­&gt;方法 ­­­­&gt; @AfterReturning ­­­&gt; @After &gt; @Around<br>2、异常执行：<br>@Around &gt; @Before­­­&gt;方法­­­­ &gt; @AfterThrowing­­­ &gt; @After</p><h2 id="8-5-Spring-AOP-与-AspectJ-AOP-有什么区别？"><a href="#8-5-Spring-AOP-与-AspectJ-AOP-有什么区别？" class="headerlink" title="8.5. Spring AOP 与 AspectJ AOP 有什么区别？"></a>8.5. Spring AOP 与 AspectJ AOP 有什么区别？</h2><h3 id="8-5-1-关系"><a href="#8-5-1-关系" class="headerlink" title="8.5.1. 关系"></a>8.5.1. 关系</h3><p>当在 Spring 中要使用@Aspect、@Before 等这些注解的时候， 就需要添加 AspectJ 相关依赖</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230202211531.png" alt="image.png"></p><p>Spring Aop 提供了 AspectJ 的支持，但只用到的 AspectJ 的切点解析和匹配。 @Aspect、@Before 等这些注解都是由 AspectJ 发明的<br><span style="background-color:#f0f">AOP 实现的关键在于代理模式，AOP 代理主要分为静态代理和动态代理。静态代理的代表为 AspectJ；动态代理则以 Spring AOP 为代表。</span></p><h3 id="8-5-2-区别"><a href="#8-5-2-区别" class="headerlink" title="8.5.2. 区别"></a>8.5.2. 区别</h3><p>（1）AspectJ 是静态代理的增强，所谓静态代理，就是 AOP 框架会在编译阶段生成 AOP 代理类，因此也称为<span style="background-color:#f0f">编译时增强</span>，他会在编译阶段将 AspectJ(切面) 织入到 Java 字节码中，运行的时候就是增强之后的 AOP 对象。<br>（2）Spring AOP 使用的动态代理，它基于动态代理来实现。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。</p><h2 id="8-6-JDK-动态代理和-CGLIB-动态代理的区别"><a href="#8-6-JDK-动态代理和-CGLIB-动态代理的区别" class="headerlink" title="8.6. JDK 动态代理和 CGLIB 动态代理的区别"></a>8.6. JDK 动态代理和 CGLIB 动态代理的区别</h2><p>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理：</p><ol><li>JDK 动态代理<span style="background-color:#0f0">只提供接口的代理，不支持类的代理</span>。<br>JDK 会在运行时为目标类生成一个动态代理类 $proxy*.class  . <br> 该代理类是实现了目标类接口， 并且代理类会<span style="background-color:#0f0">实现接口所有的方法</span>增强代码。 <br>调用时通过代理类先去调用处理类进行增强，再通过<span style="background-color:#f0f">反射</span>的方式进行调用目标方法。从而实现 AOP</li><li>如果代理类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。<br>CGLIB 的底层是<span style="background-color:#0f0">通过 ASM 在运行时动态的生成目标类的一个子类</span>。（还有其他相关类，主要是为增强调用时效率）会生成多个 ，并且会重写父类所有的方法增强代码，调用时先通过代理类进行增强，再<span style="background-color:#f0f">直接调用父类对应的方法</span>进行调用目标方法。从而实现AOP。<br><span style="background-color:#ff0">CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final</span>，那么它是无法使用 CGLIB 做动态代理的。CGLIB 除了生成目标子类代理类，<span style="background-color:#0f0">还有一个 FastClass(路由类)，可以（但不是必须）让本类方法调用进行增强，而不会像 jdk 代理那样本类方法调用增强会失效</span>，但是为了 AOP 整体一致性，这个特性并未对外使用</li><li>在老版本 CGLIB 的速度是 JDK 速度的 10 倍左右, 但是实际上 JDK 的速度在版本升级的时候每次都提高很多性能,而 CGLIB 仍止步不前。在对 JDK 动态代理与 CGlib 动态代理的代码实验中看，1W 次执行下，JDK7 及 8 的动态代理性能比 CGlib 要好 20% 左右。</li></ol><h2 id="8-7-JavaConfig-方式如何启用-AOP-如何强制使用-cglib"><a href="#8-7-JavaConfig-方式如何启用-AOP-如何强制使用-cglib" class="headerlink" title="8.7. JavaConfig 方式如何启用 AOP? 如何强制使用 cglib"></a>8.7. JavaConfig 方式如何启用 AOP? 如何强制使用 cglib</h2><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230323-0744%%</span>❕ ^sn8xbz</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@EnableAspectJAutoProxy</span><br>(proxyTargetClass = <span class="hljs-literal">true</span>) <span class="hljs-comment">//强制CGLIB</span><br>(exposeProxy = <span class="hljs-literal">true</span>) 在线程中暴露代理对象<span class="hljs-meta">@EnableAspectJAutoProxy</span><br></code></pre></td></tr></table></figure><p>^lcbyzk</p><blockquote><ol><li>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。</li><li>SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。<span style="background-color:#ff0">目标类没有实现接口或者接收代理类的类型不是共同父接口就会导致类型转换异常。</span></li><li>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项 <code>spring.aop.proxy-target-class=false</code> 来进行修改，<code>proxyTargetClass</code> 配置已无效。<br>❕<span style="display:none">%%<br>1211-🏡⭐️◼️强制开启 CGLIB 代理的方法 ?🔜MSTM📝 增加配置参数 proxy-target-class&#x3D;”true”◼️⭐️-point-202302091211%%</span></li></ol></blockquote><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a><p>对比记忆：<a href="/2023/02/01/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-8%E3%80%81BeanDefinition/" title="Spring-8、BeanDefinition">Spring-8、BeanDefinition</a><br>❕<span style="display:none">%%<br>0653-🏡⭐️◼️CGLIB 相关的 2 个配置 ?🔜MSTM📝 都是 proxy 开头，一个用于 AOP 中指定使用 cglib 作为动态代理的生成方式：proxytargetclass。一个用于方法 bean 是否需要 full 模式，即是否需要生成一个 cglib 动态代理：proxybeanmethod。◼️⭐️-point-202302100653%%</span></p><p>^1k8ap0</p><h2 id="8-8-AOP-失效-or-如何在同一个-service-中使用传播行为"><a href="#8-8-AOP-失效-or-如何在同一个-service-中使用传播行为" class="headerlink" title="8.8. AOP 失效 or 如何在同一个 service 中使用传播行为"></a>8.8. AOP 失效 or 如何在同一个 service 中使用传播行为</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230608-1708%%</span>❕ ^tzh2qj</p><p>解决方式：必须走代理， 重新拿到代理对象再次执行方法才能进行增强</p><p>1. 在本类中自动注入当前的 bean<br>2. 设置暴露当前代理对象到本地线程， 可以通过 AopContext.currentProxy() 拿到当前正在调用的动态代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy=true)</span><br><span class="hljs-type">SpuInfoService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (SpuInfoService) AopContext.currentProxy();<br></code></pre></td></tr></table></figure><h2 id="8-9-介绍-AOP-有几种实现方式"><a href="#8-9-介绍-AOP-有几种实现方式" class="headerlink" title="8.9. 介绍 AOP 有几种实现方式"></a>8.9. 介绍 AOP 有几种实现方式</h2><ol><li>Spring 1.2 基于接口的配置：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。</li><li>Spring 2.0 schema-based 配置：Spring 2.0 以后使用 XML 的方式来配置，使用命名空间 <aop></aop></li><li>Spring 2.0 @AspectJ 配置：使用注解的方式来配置最方便的，还有，这里虽然叫做 @AspectJ，但是这个和 AspectJ 其实没啥关系。</li><li>AspectJ  方式，这种方式其实和 Spring 没有关系，采用 AspectJ 进行动态织入的方式实现 AOP，需要用 AspectJ 单独编译。</li></ol><h2 id="8-10-Spring-的-AOP-是在哪里创建的动态代理？"><a href="#8-10-Spring-的-AOP-是在哪里创建的动态代理？" class="headerlink" title="8.10. Spring 的 AOP 是在哪里创建的动态代理？"></a>8.10. Spring 的 AOP 是在哪里创建的动态代理？</h2><p>1. 正常的 Bean 会在 Bean 的生命周期的‘初始化’后， 通过 BeanPostProcessor.postProcessAfterInitialization 创建 aop 的动态代理<br>2. 还有一种特殊情况： 循环依赖的 Bean 会在 Bean 的生命周期‘属性注入’时存在的循环依赖的情况下， 也会为循环依赖的 Bean<br>通过 MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 创建 aop</p><h2 id="8-11-Spring-的-Aop-的完整实现流程？"><a href="#8-11-Spring-的-Aop-的完整实现流程？" class="headerlink" title="8.11. Spring 的 Aop 的完整实现流程？"></a>8.11. Spring 的 Aop 的完整实现流程？</h2><p>^f9oy7j<br>Aop 的实现大致分为三大步：JavaConfig<br>当@EnableAspectJAutoProxy 会通过@Import 注册一个 BeanPostProcessor 处理 AOP</p><ol><li><p><strong>解析切面</strong>： 在 Bean 创建之前的第一个 Bean 后置处理器会去解析切面（解析切面中通知、切点，一个通知就会解析成一个 advisor(通知、切点)） <br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209132856.png" alt="image.png"></p></li><li><p><strong>创建动态代理</strong>：正常的 Bean 初始化后调用 BeanPostProcessor  拿到之前缓存的 advisor ，再通过 advisor 中 pointcut  判断当前 Bean 是否被切点表达式匹配，如果匹配，就会为 Bean 创建动态代理（创建方式：1.jdk 动态代理、 2.cglib)。</p></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209133211.png" alt="image.png"></p><ol start="3"><li><strong>调用</strong>：拿到动态代理对象，调用方法就会判断当前方法是否增强的方法，就会通过调用链的方式依次去执行通知<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230209133351.png" alt="image.png"></li></ol><h1 id="9-事务相关"><a href="#9-事务相关" class="headerlink" title="9. 事务相关"></a>9. 事务相关</h1><h1 id="10-参考与感谢"><a href="#10-参考与感谢" class="headerlink" title="10. 参考与感谢"></a>10. 参考与感谢</h1><h2 id="10-1-图灵徐庶"><a href="#10-1-图灵徐庶" class="headerlink" title="10.1. 图灵徐庶"></a>10.1. 图灵徐庶</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mf4y1c7cV/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV/?spm_id_from=..search-card.all.click&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>[[Spring全家桶面试题—图灵徐庶.pdf]]<br><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f5075c763768959e2d109df#map">https://www.processon.com/view/link/5f5075c763768959e2d109df#map</a> ^b7goye</p><a href="/2022/12/04/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-3%E3%80%81AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-@EnableAspectJAutoProxy/" title="Spring-3、AOP实现原理-@EnableAspectJAutoProxy">Spring-3、AOP实现原理-@EnableAspectJAutoProxy</a></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/">https://taylorluo.github.io/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timeline/">timeline</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/justlovesmile-img/cover1.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="https://picsum.photos/1920/962" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot-1、基本原理</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1%E3%80%81%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83/"><img class="next-cover" src="https://picsum.photos/1920/1084" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">经验专题-序列化与反序列化-1、选型比较</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-1%E3%80%81%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="计算机基础-基本原理-1、相关名词"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">计算机基础-基本原理-1、相关名词</div></div></a></div><div><a href="/2023/03/27/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/JDK-1%E3%80%81SPI/" title="框架源码专题-JDK-1、SPI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover5.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">框架源码专题-JDK-1、SPI</div></div></a></div><div><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-9%E3%80%81SQL%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/" title="框架源码专题-MySQL-9、SQL应用优化"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">框架源码专题-MySQL-9、SQL应用优化</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/01/22/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-19%E3%80%81Queue/" title="并发编程专题-基础-19、Queue"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">并发编程专题-基础-19、Queue</div></div></a></div><div><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构实战专题-基础-1、架构演进"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">架构实战专题-基础-1、架构演进</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. Spring 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-POJO"><span class="toc-text">1.1. POJO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%A6%E5%AE%9A-%E6%83%AF%E4%BE%8B"><span class="toc-text">1.2. 约定 (惯例)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.3. 依赖注入和面向接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-text">1.4. Spring 的核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Spring-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5. Spring 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E4%BC%98%E7%82%B9"><span class="toc-text">1.5.1. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5.2. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-text">1.6. Spring 的核心模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-IOC-%E7%9B%B8%E5%85%B3"><span class="toc-text">2. IOC 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-IOC-%E5%AE%B9%E5%99%A8"><span class="toc-text">2.1. 什么是 IOC 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-IOC-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-text">2.2. IOC 的作用和意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-IOC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">2.3. IOC 的实现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%EF%BC%9FIOC-%E5%92%8C-DI-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">2.4. 什么是 Spring 的依赖注入 (DI)？IOC 和 DI 的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-BeanDefinition-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.5. BeanDefinition 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-BeanFactory-%E5%92%8C-ApplicationContext-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2.6. BeanFactory 和 ApplicationContext 有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E7%AD%94%E6%A1%88-2"><span class="toc-text">2.6.1. 答案 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-1-%E5%8A%9F%E8%83%BD%E5%A4%A7%E5%B0%8F"><span class="toc-text">2.6.1.1. 功能大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-2-%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-text">2.6.1.2. 加载方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-BeanFactory-%E5%92%8C-FactoryBean-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2.7. BeanFactory 和 FactoryBean 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2.8. 有哪些不同类型的依赖注入实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Spring-%E4%B8%AD%E9%85%8D%E7%BD%AE-%E6%B3%A8%E5%86%8C-Bean-%E7%9A%84%E6%96%B9%E5%BC%8F%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">2.9. Spring 中配置 (注册)Bean 的方式⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-BeanDefinition-%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">2.10. BeanDefinition 的加载过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3"><span class="toc-text">3. 生命周期相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.1. Spring 框架中 bean 的生命周期⭐️🔴⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-BD-%E7%9B%B8%E5%85%B3"><span class="toc-text">3.1.1. BD 相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">3.1.2. 整体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.1.3. 后置处理器相关⭐️🔴⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E7%9B%B8%E5%85%B3"><span class="toc-text">3.1.4. 生命周期回调相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-text">3.1.4.1. 初始化之前执行的生命周期的回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-text">3.1.4.2. 初始化之后的生命周期的回调</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%A7%A3%E9%87%8A%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8Cspring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.2. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-XML"><span class="toc-text">3.2.1. XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.2.2. 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-1-Autowired-%E4%B8%8E-Qualifier"><span class="toc-text">3.2.2.1. @Autowired 与@Qualifier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-2-Autowired-%E4%B8%8E-Resource-%E5%BC%82%E5%90%8C"><span class="toc-text">3.2.2.2. @Autowired 与@Resource 异同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%93%AA%E4%BA%9B%E6%98%AF%E9%87%8D%E8%A6%81%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95-%E8%83%BD%E5%90%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">3.3. 哪些是重要的 bean 生命周期方法 能否重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BD%BF%E7%94%A8-Autowired-%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.4. 使用@Autowired 注解自动装配的过程是怎样的⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-PostConstruct-%E5%8E%9F%E7%90%86%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.5. @PostConstruct 原理⭐️🔴⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%89%80%E6%9C%89-bean-%E4%B9%8B%E5%90%8E%E5%81%9A%E6%89%A9%E5%B1%95"><span class="toc-text">3.6. 如何在 Spring 创建完所有 bean 之后做扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%9F%BA%E4%BA%8E-SmartInitializingSingleton-%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.6.1. 基于 SmartInitializingSingleton 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%9F%BA%E4%BA%8E-Spring-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">3.6.2. 基于 Spring 事件监听</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Spring-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E5%8A%A0%E8%BD%BD-BeanFactoryPostProcess"><span class="toc-text">3.7. Spring 容器启动时，为什么先加载 BeanFactoryPostProcess</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-BeanDefinition-%E7%9B%B8%E5%85%B3"><span class="toc-text">4. BeanDefinition 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-BeanDefinition-%E7%9A%84%E6%B3%A8%E5%86%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">4.1. BeanDefinition 的注册顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-text">5. 线程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Spring-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.1. Spring 如何处理线程并发问题⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3"><span class="toc-text">6. 设计模式相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Spring-%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.1. Spring 中用到了哪些设计模式⭐️🔴⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">6.2. 单例 bean 的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3"><span class="toc-text">7. 注解相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Spring-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">7.1. Spring 有哪几种配置方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-JavaConfig-%E4%B8%8E-XML-%E6%96%B9%E5%BC%8F-Spring-%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%8D%E5%90%8C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">7.2. JavaConfig 与 XML 方式 Spring 配置的不同⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-JavaConfig"><span class="toc-text">7.2.1. JavaConfig</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-1-%E6%B3%A8%E5%86%8C%E6%A0%B8%E5%BF%83-BPP"><span class="toc-text">7.2.1.1. 注册核心 BPP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-2-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%B3%A8%E5%86%8C%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">7.2.1.2. 读取配置类 (注册配置类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-3-%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%89%AB%E6%8F%8F%E6%B3%A8%E5%86%8C%E5%BC%95%E5%85%A5%E7%B1%BB"><span class="toc-text">7.2.1.3. 解析配置类 (扫描注册引入类)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-XML"><span class="toc-text">7.2.2. XML</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-1-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">7.2.2.1. 读取配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-1-1-XmlBeanDefinitionReader"><span class="toc-text">7.2.2.1.1. XmlBeanDefinitionReader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-1-2-DefaultDocumentLoader"><span class="toc-text">7.2.2.1.2. DefaultDocumentLoader</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-2-%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">7.2.2.2. 解析配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-2-1-DefaultBeanDefinitionDocumentReader"><span class="toc-text">7.2.2.2.1. DefaultBeanDefinitionDocumentReader</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Component-Controller-Repository-Service"><span class="toc-text">7.3. Component Controller Repository Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Import-%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95-%E6%B3%A8%E5%86%8C-BD-%E6%96%B9%E6%B3%95"><span class="toc-text">7.4. @Import 可以有几种用法 (注册 BD 方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Configuration-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86"><span class="toc-text">7.5. @Configuration 的作用解析原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-Configuration-%E5%8A%A0%E4%B8%8E%E4%B8%8D%E5%8A%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">7.5.1. @Configuration 加与不加有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Bean-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E7%9A%84"><span class="toc-text">7.6. @Bean 之间的方法调用是怎么保证单例的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-AOP-%E7%9B%B8%E5%85%B3"><span class="toc-text">8. AOP 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">8.1. 是什么做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB"><span class="toc-text">8.2. 各种概念关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-Spring-AOP-%E9%87%8C%E9%9D%A2%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D"><span class="toc-text">8.3. 解释一下 Spring AOP 里面的几个名词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Spring-%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">8.4. Spring 通知有哪些类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Spring-AOP-%E4%B8%8E-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8.5. Spring AOP 与 AspectJ AOP 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-%E5%85%B3%E7%B3%BB"><span class="toc-text">8.5.1. 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-%E5%8C%BA%E5%88%AB"><span class="toc-text">8.5.2. 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.6. JDK 动态代理和 CGLIB 动态代理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-JavaConfig-%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8-AOP-%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-cglib"><span class="toc-text">8.7. JavaConfig 方式如何启用 AOP? 如何强制使用 cglib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-AOP-%E5%A4%B1%E6%95%88-or-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA-service-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">8.8. AOP 失效 or 如何在同一个 service 中使用传播行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E4%BB%8B%E7%BB%8D-AOP-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">8.9. 介绍 AOP 有几种实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-Spring-%E7%9A%84-AOP-%E6%98%AF%E5%9C%A8%E5%93%AA%E9%87%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">8.10. Spring 的 AOP 是在哪里创建的动态代理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-Spring-%E7%9A%84-Aop-%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">8.11. Spring 的 Aop 的完整实现流程？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-text">9. 事务相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">10. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%9B%BE%E7%81%B5%E5%BE%90%E5%BA%B6"><span class="toc-text">10.1. 图灵徐庶</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://unpkg.com/justlovesmile-img/cover1.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>