<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>SpringBoot-1、基本原理 | Taylor</title><meta name="keywords" content="timeline"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. SpringBoot 的特性https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Et411Y7tQ?p&#x3D;117&amp;vd_source&#x3D;c5b2d0d7bc377c0c35dbc251d95cf204 1.1. 依赖管理1.1.1. 父项目做依赖管理   1、无需关注版本号，自动版本仲裁   2、可以修改默认版本号 1.1.2. starter 场景启动器   1、见到"><meta property="og:type" content="article"><meta property="og:title" content="SpringBoot-1、基本原理"><meta property="og:url" content="https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. SpringBoot 的特性https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Et411Y7tQ?p&#x3D;117&amp;vd_source&#x3D;c5b2d0d7bc377c0c35dbc251d95cf204 1.1. 依赖管理1.1.1. 父项目做依赖管理   1、无需关注版本号，自动版本仲裁   2、可以修改默认版本号 1.1.2. starter 场景启动器   1、见到"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picsum.photos/1920/962"><meta property="article:published_time" content="2023-06-12T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.680Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="timeline"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picsum.photos/1920/962"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"SpringBoot-1、基本原理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://picsum.photos/1920/962')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot-1、基本原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-12T16:00:00.000Z" title="发表于 2023-06-13 00:00:00">2023-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.680Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="SpringBoot-1、基本原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><h1 id="1-SpringBoot-的特性"><a href="#1-SpringBoot-的特性" class="headerlink" title="1. SpringBoot 的特性"></a>1. SpringBoot 的特性</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=117&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=117&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="1-1-依赖管理"><a href="#1-1-依赖管理" class="headerlink" title="1.1. 依赖管理"></a>1.1. 依赖管理</h2><h3 id="1-1-1-父项目做依赖管理"><a href="#1-1-1-父项目做依赖管理" class="headerlink" title="1.1.1. 父项目做依赖管理"></a>1.1.1. 父项目做依赖管理</h3><p>1、无需关注版本号，自动版本仲裁<br>2、可以修改默认版本号</p><h3 id="1-1-2-starter-场景启动器"><a href="#1-1-2-starter-场景启动器" class="headerlink" title="1.1.2. starter 场景启动器"></a>1.1.2. starter 场景启动器</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230226073735.png" alt="image.png"></p><p>1、见到很多 spring-boot-starter-xxx ： xxx 就某种场景<br>2、只要引入 starter，这个场景的所有常规需要的依赖我们都自动引入<br>3、SpringBoot 所有支持的场景<br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a><br>4、见到的 xxx-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。<br>5、所有场景启动器最底层的依赖</p><h2 id="1-2-自动配置"><a href="#1-2-自动配置" class="headerlink" title="1.2. 自动配置"></a>1.2. 自动配置</h2><p>● 自动配好 Tomcat<br>○ 引入 Tomcat 依赖。<br>○ 配置 Tomcat<br>● 自动配好 SpringMVC<br>○ 引入 SpringMVC 全套组件<br>○ 自动配好 SpringMVC 常用组件（功能）<br>● 自动配好 Web 常见功能，如：字符编码问题<br>○ SpringBoot 帮我们配置好了所有 web 开发的常见场景<br>● 默认的包结构<br>○ 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来<br>○ 无需以前的包扫描配置<br>○ 想要改变扫描路径，@SpringBootApplication(scanBasePackages&#x3D;”com.atguigu”)<br>● 或者@ComponentScan 指定扫描路径<br>● 各种配置拥有默认值<br>○ 默认配置最终都是映射到某个类上，如：MultipartProperties<br>○ 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象<br>● 按需加载所有自动配置项<br>○ 非常多的 starter<br>○ 引入了哪些场景这个场景的自动配置才会开启<br>○ SpringBoot 所有的自动配置功能都在 spring-boot-autoconfigure 包里面</p><h1 id="2-谈谈你对-SpringBoot-的理解-优点特性"><a href="#2-谈谈你对-SpringBoot-的理解-优点特性" class="headerlink" title="2. 谈谈你对 SpringBoot 的理解 (优点特性)"></a>2. 谈谈你对 SpringBoot 的理解 (优点特性)</h1><p>SpringBoot 的用来快速开发 Spring 应用的一个脚手架、其设计目的是用来简新 Spring 应用的初始搭建以及开发过程。</p><ol><li>SpringBoot 提供了很多内置的 Starter 结合自动配置，实现了对主流框架的<span style="background-color:#0f0">无配置集成</span>、开箱即用；</li><li>SpringBoot 简化了开发，采用 JavaConfig 的方式可以使用<span style="background-color:#0f0">零 xml</span>的方式进行开发；</li><li>SpringBoot<span style="background-color:#0f0">内置 Web 容器</span>无需依赖外部 Web 服务器，省略了 Web.xml，直接运行 jar 文件就可以启动 web 应用；</li><li>SpringBoot 帮我管理了常用的第三方依赖的版本，<span style="background-color:#0f0">减少出现版本冲突</span>的问题；</li><li>SpringBoot<span style="background-color:#0f0">自带了监控功能</span>，可以监控应用程序的运行状况，或者内存、线程池、Http 请求统计等，同时还提供了优雅关闭应用程序等功能。</li></ol><h1 id="3-SpringBoot-自动配置原理-SpringBootApplication-⭐️🔴"><a href="#3-SpringBoot-自动配置原理-SpringBootApplication-⭐️🔴" class="headerlink" title="3. SpringBoot 自动配置原理 -@SpringBootApplication ⭐️🔴"></a>3. SpringBoot 自动配置原理 -@SpringBootApplication ⭐️🔴</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230303-0844%%</span><br>^py2rrk<br><a target="_blank" rel="noopener" href="https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM">https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM</a> ^c46210</p><h2 id="3-1-引导加载自动配置类"><a href="#3-1-引导加载自动配置类" class="headerlink" title="3.1. 引导加载自动配置类"></a>3.1. 引导加载自动配置类</h2><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230326-2214%%</span>❕ ^dxovlh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication&#123;&#125;   <br></code></pre></td></tr></table></figure><h3 id="3-1-1-SpringBootConfiguration"><a href="#3-1-1-SpringBootConfiguration" class="headerlink" title="3.1.1. @SpringBootConfiguration"></a>3.1.1. @SpringBootConfiguration</h3><p>@Configuration。代表当前是一个配置类</p><h3 id="3-1-2-ComponentScan"><a href="#3-1-2-ComponentScan" class="headerlink" title="3.1.2. @ComponentScan"></a>3.1.2. @ComponentScan</h3><p>指定扫描哪些，是一个 Spring 注解；<br>在 SpringBoot 中，在该注解属性中配置了排除规则：排除 2 种类型：<br>①继承了 TypeExcludeFilter 的类<br>②SpringBoot 的自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  </span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></code></pre></td></tr></table></figure><h3 id="3-1-3-EnableAutoConfiguration"><a href="#3-1-3-EnableAutoConfiguration" class="headerlink" title="3.1.3. @EnableAutoConfiguration"></a>3.1.3. @EnableAutoConfiguration</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222142714.png" alt="image.png"></p><h4 id="3-1-3-1-AutoConfigurationPackage"><a href="#3-1-3-1-AutoConfigurationPackage" class="headerlink" title="3.1.3.1. @AutoConfigurationPackage"></a>3.1.3.1. @AutoConfigurationPackage</h4><p><span style="display:none">%%<br>▶6.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-1703%%</span>❕ ^j6d450</p><p><code>@Import(AutoConfigurationPackages.Registrar.class)</code><br>自动配置包，指定了默认的包规则，将指定的<span style="background-color:#f0f">一个包下的所有组件</span>导入进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span>  <br><span class="hljs-comment">//给容器中导入一个组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br><span class="hljs-comment">//利用Registrar给容器中导入一系列组件</span><br><span class="hljs-comment">//将指定的一个包下的所有组件导入进来，MainApplication 所在包下。</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326072101.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222160725.png" alt="image.png"></p><h4 id="3-1-3-2-Import-AutoConfigurationImportSelector-class"><a href="#3-1-3-2-Import-AutoConfigurationImportSelector-class" class="headerlink" title="3.1.3.2. @Import(AutoConfigurationImportSelector.class)"></a>3.1.3.2. @Import(AutoConfigurationImportSelector.class)</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230324173014.png" alt="image.png"></p><p>selectImports→getAutoConfigurationEntry 获取到所有需要导入到容器中的配置类</p><p><span style="background-color:#f0f">方法调用路径</span><br>AutoConfigurationImportSelector. <code>getAutoConfigurationEntry</code> &#x3D;&#x3D;→&#x3D;&#x3D; <span style="background-color:#f0f">SpringFactoriesLoader</span>. <code>loadSpringFactories</code> &#x3D;&#x3D;→&#x3D;&#x3D;<br>classLoader.getResources(“<code>META-INF/spring.factories</code>“)</p><p><span style="background-color:#f0f">默认扫描当前系统里面所有 META-INF&#x2F;spring.factories 位置的文件</span> ❕<span style="display:none">%%<br>▶2.🏡⭐️◼️自定义 starter 就是依靠这种策略 ?🔜MSTM📝 可以被扫描到需要注入的组件◼️⭐️-point-20230226-0847%%</span></p><p>比如 <code>spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件<br><span class="hljs-number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类<br><span class="hljs-number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span>；得到所有的组件<br><span class="hljs-number">4</span>、从META-INF/spring.factories位置来加载一个文件。<br>	默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件<br>    spring-boot-autoconfigure-<span class="hljs-number">2.3</span><span class="hljs-number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories<br>    <br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222162310.png" alt="image.png"></p><h5 id="3-1-3-2-1-SPI-原理"><a href="#3-1-3-2-1-SPI-原理" class="headerlink" title="3.1.3.2.1. SPI 原理"></a>3.1.3.2.1. SPI 原理</h5><p><span style="display:none">%%<br>▶2.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-0804%%</span>❕ ^bypdob</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304124004.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230304132455.png" alt="image.png"></p><h2 id="3-2-按需开启自动配置项"><a href="#3-2-按需开启自动配置项" class="headerlink" title="3.2. 按需开启自动配置项"></a>3.2. 按需开启自动配置项</h2><p>虽然我们 127 个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration，但按照条件装配规则（@Conditional），最终会按需配置。</p><h2 id="3-3-修改默认配置"><a href="#3-3-修改默认配置" class="headerlink" title="3.3. 修改默认配置"></a>3.3. 修改默认配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="hljs-comment">//容器中有这个类型组件</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="hljs-comment">//容器中没有这个名字 multipartResolver 的组件</span><br>		<span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> &#123;<br>            <span class="hljs-comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span><br>            <span class="hljs-comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span><br>			<span class="hljs-comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span><br>			<span class="hljs-keyword">return</span> resolver;<br>		&#125;<br>给容器中加入了文件上传解析器；<br><br></code></pre></td></tr></table></figure><p><span style="background-color:#0f0">SpringBoot 默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</span></p><h2 id="3-4-与-SpringMVC-配置的区别"><a href="#3-4-与-SpringMVC-配置的区别" class="headerlink" title="3.4. 与 SpringMVC 配置的区别"></a>3.4. 与 SpringMVC 配置的区别</h2><h3 id="3-4-1-关于-JSON-编码配置"><a href="#3-4-1-关于-JSON-编码配置" class="headerlink" title="3.4.1. 关于 JSON 编码配置"></a>3.4.1. 关于 JSON 编码配置</h3><p>Spring 整合 SpringMVC 时需要设置 JSON 格式<br>Springboot 不需要，因为在<artifactid>spring-boot-starter-web</artifactid>中<br>自动配置了 jacjson-databind，使用的是 <code>MappingJackson2HttpMessageConverter</code></p><h3 id="3-4-2-EnableAspectJAutoProxy⭐️🔴"><a href="#3-4-2-EnableAspectJAutoProxy⭐️🔴" class="headerlink" title="3.4.2. @EnableAspectJAutoProxy⭐️🔴"></a>3.4.2. @EnableAspectJAutoProxy⭐️🔴</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302142824.png" alt="image.png"></p><p>在 Spring 中，如果不在配置类中添加@EnableAspectJAutoProxy，那么所有 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%87%E9%9D%A2&spm=1001.2101.3001.7020">切面</a> 注解是不生效的（springboot 因为有自动配置，所以不需要开发人员手工配置@EnableAspectJAutoProxy）</p><h2 id="3-5-自动配置总结"><a href="#3-5-自动配置总结" class="headerlink" title="3.5. 自动配置总结"></a>3.5. 自动配置总结</h2><ul><li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties 里面拿。xxxProperties 和配置文件进行了绑定</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置<ul><li>用户直接自己@Bean 替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p><strong>xxxxxAutoConfiguration —&gt; 组件 —&gt;</strong> <strong>xxxxProperties 里面拿值 —-&gt; application.properties</strong></p><h2 id="3-6-黑马补充"><a href="#3-6-黑马补充" class="headerlink" title="3.6. 黑马补充"></a>3.6. 黑马补充</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y117RJ?p=172&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y117RJ?p=172&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325121857.png" alt="image.png"></p><h1 id="4-SpringBoot-的启动原理⭐️🔴"><a href="#4-SpringBoot-的启动原理⭐️🔴" class="headerlink" title="4. SpringBoot 的启动原理⭐️🔴"></a>4. SpringBoot 的启动原理⭐️🔴</h1><p><span style="display:none">%%<br>▶15.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1327%%</span>❕ ^ro0jas<br><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0703%%</span>❕ ^214fh8</p><p><strong>概述</strong></p><ol><li>运行 main 方法： 初始化 new SpringApplication  从 spring.factories  读取 ApplicationListener、ApplicationContextInitializer</li><li>运行 run 方法</li><li>读取环境变量配置信息</li><li>创建 springApplication 上下文： ServletWebServerApplicationContext</li><li>预初始化上下文 </li><li>调用 refresh 加载 ioc 容器 <br><code>invokeBeanFactoryPostProcessor </code>  <span style="background-color:#0f0">解析@Import</span>:  加载所有的自动配置类<br><code>onRefresh</code>  <span style="background-color:#0f0">创建 (内置)servlet 容器</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224181156.png" alt="image.png"></li></ol><p>在这个过程中 springboot 会调用很多监听器对外进行扩展<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=196&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=196&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="4-1-创建-SpringApplication"><a href="#4-1-创建-SpringApplication" class="headerlink" title="4.1. 创建 SpringApplication"></a>4.1. 创建 SpringApplication</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224142822.png" alt="image.png"></p><ol><li>判定当前应用的类型。ClassUtils.isPresent → WebApplicationType.SERVLET</li><li>使用系统方法 <code>getSpringFactoriesInstances</code> 分别查找以下类型：<br>○ 查找 <font color="#ff0000">bootstrappers</font>：&#x3D;&#x3D;初始启动引导器&#x3D;&#x3D;<br>去 <code>spring.factories</code> 文件中找 org.springframework.boot. <code>Bootstrapper</code><br>放入 <code>List&lt;Bootstrapper&gt;</code><br>○ 查找 <font color="#ff0000">ApplicationContextInitializer</font>：&#x3D;&#x3D;初始化器&#x3D;&#x3D;<br>去 spring.factories 找 ApplicationContextInitializer<br>放入 <code>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers</code><br>○ 查找 <font color="#ff0000">ApplicationListener</font> ：&#x3D;&#x3D;应用监听器&#x3D;&#x3D;<br>去 spring.factories 找 ApplicationListener<br>放入 <code>List&lt;ApplicationListener&lt;?&gt;&gt; listeners</code></li><li><span style="background-color:#f0f">保存当前启动类为配置类</span></li></ol><h2 id="4-2-运行-SpringApplication"><a href="#4-2-运行-SpringApplication" class="headerlink" title="4.2. 运行 SpringApplication"></a>4.2. 运行 SpringApplication</h2><h3 id="4-2-1-记录应用的启动时间-创建引导上下文-bootstrappers-intitialize"><a href="#4-2-1-记录应用的启动时间-创建引导上下文-bootstrappers-intitialize" class="headerlink" title="4.2.1. 记录应用的启动时间 - 创建引导上下文 -bootstrappers.intitialize"></a>4.2.1. 记录应用的启动时间 - 创建引导上下文 -bootstrappers.intitialize</h3><p>○ <strong>StopWatch</strong>，记录应用的启动时间<br>○ 创建引导上下文（Context 环境）createBootstrapContext()<br>■ <span style="background-color:#f0f">获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置</span><br>○ 让当前应用进入 headless 模式。java.awt.headless</p><h3 id="4-2-2-发布-ApplicationStartingEvent-事件"><a href="#4-2-2-发布-ApplicationStartingEvent-事件" class="headerlink" title="4.2.2. 发布 ApplicationStartingEvent 事件"></a>4.2.2. 发布 ApplicationStartingEvent 事件</h3><p>○ <span style="background-color:#f0f">获取所有 RunListener（运行监听器）</span><span style="background-color:#0f0">【为了方便所有 Listener 进行事件感知】</span><br>■ getSpringFactoriesInstances 去 spring.factories 找 SpringApplicationRunListener.<br>○ <span style="background-color:#f0f">遍历 SpringApplicationRunListener 调用 starting 方法</span>；<br>■ 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</p><h3 id="4-2-3-读取环境配置信息发布-environmentPreparedEvent"><a href="#4-2-3-读取环境配置信息发布-environmentPreparedEvent" class="headerlink" title="4.2.3. 读取环境配置信息发布 environmentPreparedEvent"></a>4.2.3. 读取环境配置信息发布 environmentPreparedEvent</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180423.png" alt="image.png"></p><p>○ <span style="background-color:#f0f">保存命令行参数</span>；ApplicationArguments<br>○ 准备环境 prepareEnvironment（）;<br>■ 返回或者创建基础环境信息对象。StandardServletEnvironment<br>■ 配置环境信息对象。<br><span style="background-color:#f0f">● 读取所有的配置源的配置属性值：<br><code>ConfigFileApplicationListener</code> 会监听 <code>onApplicationEnvironmentPreparedEvent</code> 事件来加载配置文件 <code>application.properties</code> 的环境变量</span><br>■ 绑定环境信息<br>■ 监听器调用 listener.environmentPrepared()；<span style="background-color:#f0f">通知所有的监听器当前环境准备完成</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227132255.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227124928.png" alt="image.png"></p><h3 id="4-2-4-根据项目类型创建-IOC-容器⭐️🔴"><a href="#4-2-4-根据项目类型创建-IOC-容器⭐️🔴" class="headerlink" title="4.2.4. 根据项目类型创建 IOC 容器⭐️🔴"></a>4.2.4. 根据项目类型创建 IOC 容器⭐️🔴</h3><p>○ <span style="background-color:#f0f">实例化 Spring 上下文（createApplicationContext（））</span><br>■ 根据项目类型（Servlet）创建相应的 WEB 容器<br>■ 当前会创建 <code>AnnotationConfigServletWebServerApplicationContext</code></p><h3 id="4-2-5-准备-IOC-容器基本信息-刷新前准备-contextPrepared-loaded"><a href="#4-2-5-准备-IOC-容器基本信息-刷新前准备-contextPrepared-loaded" class="headerlink" title="4.2.5. 准备 IOC 容器基本信息 (刷新前准备 -contextPrepared-loaded)"></a>4.2.5. 准备 IOC 容器基本信息 (刷新前准备 -contextPrepared-loaded)</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180542.png" alt="image.png"></p><p>○ 准备 ApplicationContext IOC 容器的基本信息 prepareContext()<br>■ 保存环境信息<br>■ IOC 容器的后置处理流程。<br>■ 应用初始化器；applyInitializers；<br>● <span style="background-color:#f0f">遍历所有的 ApplicationContextInitializer 。调用 initialize</span>。来对 ioc 容器进行初始化扩展功能<br>● <span style="background-color:#f0f">遍历所有的 listener 调用 contextPrepared</span>。EventPublishRunListenr；通知所有的监听器 <code>contextPrepared</code><br><span style="background-color:#ff0">● 将启动类作为配置类进行读取 –&gt;将配置注册为 BeanDefinition</span> <span style="background-color:red">未看到有这块代码</span><br>■ 所有的监听器调用 <code>contextLoaded</code>。<span style="background-color:#f0f">通知所有的监听器 contextLoaded</span>；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227132333.png" alt="image.png"></p><h3 id="4-2-6-刷新-IOC-容器⭐️🔴"><a href="#4-2-6-刷新-IOC-容器⭐️🔴" class="headerlink" title="4.2.6. 刷新 IOC 容器⭐️🔴"></a>4.2.6. 刷新 IOC 容器⭐️🔴</h3><p>○ <span style="background-color:#f0f">刷新 IOC 容器。refreshContext</span><br>■ 创建容器中的所有组件（Spring 注解）<br>○ 容器刷新完成后工作 afterRefresh 无实现，可扩展</p><p><code>AnnotationConfigServletWebServerApplicationContext.refresh</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180854.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224180945.png" alt="image.png"></p><h4 id="4-2-6-1-invokeBeanFactoryPostProcessors"><a href="#4-2-6-1-invokeBeanFactoryPostProcessors" class="headerlink" title="4.2.6.1. invokeBeanFactoryPostProcessors"></a>4.2.6.1. invokeBeanFactoryPostProcessors</h4><p><code>invokeBeanFactoryPostProcessor </code>  <span style="background-color:#0f0">解析@Import</span>:  加载所有的自动配置类<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️SpringBoot 启动时配置类解析的时机 ?🔜MSTM📝 跟 Spring 是相同的，都是在第 5 步 invokeBeanFactoryPostProcessors。而且在 onrefresh 方法中创建了 Servlet 容器◼️⭐️-point-20230224-1821%%</span></p><h4 id="4-2-6-2-onrefresh-创建子容器"><a href="#4-2-6-2-onrefresh-创建子容器" class="headerlink" title="4.2.6.2. onrefresh 创建子容器"></a>4.2.6.2. onrefresh 创建子容器</h4><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224173708.png" alt="image.png"><br><code>onRefresh</code>  <span style="background-color:#0f0">创建 (内置)servlet 容器</span></p><h3 id="4-2-7-记录启动结束时间并输出"><a href="#4-2-7-记录启动结束时间并输出" class="headerlink" title="4.2.7. 记录启动结束时间并输出"></a>4.2.7. 记录启动结束时间并输出</h3><h3 id="4-2-8-发布-ApplicationStartedEvent"><a href="#4-2-8-发布-ApplicationStartedEvent" class="headerlink" title="4.2.8. 发布 ApplicationStartedEvent"></a>4.2.8. 发布 ApplicationStartedEvent</h3><p>○ 所有监听器调用 listeners.started(context); <span style="background-color:#f0f">通知所有的监听器 started</span></p><h3 id="4-2-9-调用所有-runners"><a href="#4-2-9-调用所有-runners" class="headerlink" title="4.2.9. 调用所有 runners"></a>4.2.9. 调用所有 runners</h3><p>○ 调用所有 runners；callRunners()<br>■ 获取容器中的 ApplicationRunner<br>■ 获取容器中的 CommandLineRunner<br>■ 合并所有 runner 并且按照@Order 进行排序<br>■ 遍历所有的 runner。调用 run 方法<br>○ 如果以上有异常，<br>■ 调用 Listener 的 failed</p><h3 id="4-2-10-如果启动异常则发送-ApplicationFailedEvent"><a href="#4-2-10-如果启动异常则发送-ApplicationFailedEvent" class="headerlink" title="4.2.10. 如果启动异常则发送 ApplicationFailedEvent"></a>4.2.10. 如果启动异常则发送 ApplicationFailedEvent</h3><p>○ 调用所有监听器的 running 方法 listeners.running(context); <span style="background-color:#f0f">通知所有的监听器 running</span><br>○ running 如果有问题。继续通知 failed 。调用所有 Listener 的 failed；<span style="background-color:#f0f">通知所有的监听器 failed</span></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/584866-20201221110418589-124191923.jpg" alt="img"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/1032567-20160930171658625-1237959183.png" alt="img"></p><h1 id="5-嵌入式-Servlet-容器启动原理-V2"><a href="#5-嵌入式-Servlet-容器启动原理-V2" class="headerlink" title="5. 嵌入式 Servlet 容器启动原理 V2"></a>5. 嵌入式 Servlet 容器启动原理 V2</h1><p><span style="display:none">%%<br>▶4.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0706%%</span>❕ ^kb445n</p><p>SpringBoot_V1: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mf4y1c7cV/?p=79&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV/?p=79&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>SpringBoot_V2: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=169&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222110234.png" alt="image.png"></p><h2 id="5-1-引入依赖触发自动配置"><a href="#5-1-引入依赖触发自动配置" class="headerlink" title="5.1. 引入依赖触发自动配置"></a>5.1. 引入依赖触发自动配置</h2><h3 id="5-1-1-容器工厂自动配置类⭐️🔴"><a href="#5-1-1-容器工厂自动配置类⭐️🔴" class="headerlink" title="5.1.1. 容器工厂自动配置类⭐️🔴"></a>5.1.1. 容器工厂自动配置类⭐️🔴</h3><p>当引入 <code>spring-boot-starter-web</code> 依赖时会在 SpringBoot 中添加并生效<br>servlet 容器工厂自动配置类： <code>ServletWebServerFactoryAutoConfiguration</code><br>(生效原理： <code>@ConditionalOnWebApplication(type = Type.SERVLET)</code>)<br>V1: EmbeddedServletContainerAutoConfiguration</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227100508.png" alt="image.png"></p><h3 id="5-1-2-Web-容器工厂-默认-Tomcat"><a href="#5-1-2-Web-容器工厂-默认-Tomcat" class="headerlink" title="5.1.2. Web 容器工厂 - 默认 Tomcat"></a>5.1.2. Web 容器工厂 - 默认 Tomcat</h3><p>该自动配置类通过@Import 导入了 (通过@ConditionalOnClass 判断决定使用哪一个) 一个 Web 容器工厂（默认 web-starter 会导入 tomcat 包)，即 <code>TomcatServletWebServerFactory</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325201425.png" alt="image.png"></p><h3 id="5-1-3-Web-容器工厂定制化器的后置处理器"><a href="#5-1-3-Web-容器工厂定制化器的后置处理器" class="headerlink" title="5.1.3. Web 容器工厂定制化器的后置处理器"></a>5.1.3. Web 容器工厂定制化器的后置处理器</h3><h4 id="5-1-3-1-BeanPostProcessorsRegistrar"><a href="#5-1-3-1-BeanPostProcessorsRegistrar" class="headerlink" title="5.1.3.1. BeanPostProcessorsRegistrar"></a>5.1.3.1. BeanPostProcessorsRegistrar</h4><p>在 <code>ServletWebServerFactoryAutoConfiguration</code> 中还通过 <code>BeanPostProcessorsRegistrar</code> 引入了<span style="background-color:#f0f">容器工厂定制化器的后置处理器</span> <code>WebServerFactoryCustomizerBeanPostProcessor</code></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090251.png" alt="image.png"></p><p><code>WebServerFactoryCustomizerBeanPostProcessor</code>，会获取所有的定制器，调用每个定制器的 customer 方法，<span style="background-color:#f0f">用来给 Servlet 容器进行赋值</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090135.png" alt="image.png"></p><p>V1: <code>EmbeddedServletContainerCustomizerBeanPostProcessor</code></p><h4 id="5-1-3-2-WebServerFactoryCustomizer-容器工厂定制化器-⭐️🔴"><a href="#5-1-3-2-WebServerFactoryCustomizer-容器工厂定制化器-⭐️🔴" class="headerlink" title="5.1.3.2. WebServerFactoryCustomizer(容器工厂定制化器)⭐️🔴"></a>5.1.3.2. WebServerFactoryCustomizer(容器工厂定制化器)⭐️🔴</h4><p>我们在自定义容器配置时，也可以使用这个 <code>WebServerFactoryCustomizer</code><br>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizationBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableServletWebServerFactory&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory server)</span> &#123;<br>        server.setPort(<span class="hljs-number">9000</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-SpringBoot-应用执行-Run-方法"><a href="#5-2-SpringBoot-应用执行-Run-方法" class="headerlink" title="5.2. SpringBoot 应用执行 Run 方法"></a>5.2. SpringBoot 应用执行 Run 方法</h2><p><code>SpringApplication.run(Boot05WebAdminApplication.class, args);</code></p><h3 id="5-2-1-创建-IOC-容器"><a href="#5-2-1-创建-IOC-容器" class="headerlink" title="5.2.1. 创建 IOC 容器"></a>5.2.1. 创建 IOC 容器</h3><p>【创建 IOC 容器对象，并初始化容器，创建容器的每一个组件】；如果是 web 环境则创建 AnnotationConfig&#x3D;&#x3D;ServletWebServer&#x3D;&#x3D;ApplicationContext。如果不是 web 环境则创建 AnnotationConfigApplicationContext</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224184939.png" alt="image.png"></p><p>SpringBoot_V2:<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190131.png" alt="image.png"></p><p>SpringBoot_V1:<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222190659.png" alt="image.png"></p><h3 id="5-2-2-调用父类-refresh"><a href="#5-2-2-调用父类-refresh" class="headerlink" title="5.2.2. 调用父类 refresh()"></a>5.2.2. 调用父类 refresh()</h3><p>刷新创建好的 IOC 容器<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222191503.png" alt="image.png"></p><h3 id="5-2-3-执行重写的-onRefresh-方法"><a href="#5-2-3-执行重写的-onRefresh-方法" class="headerlink" title="5.2.3. 执行重写的 onRefresh() 方法"></a>5.2.3. 执行重写的 onRefresh() 方法</h3><p>刷新 12 步中的第 9 步：web 的 IOC 容器 <code>ServletWebServerApplicationContext</code> <span style="background-color:#f0f">重写了 onRefresh 方法</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227090720.png" alt="image.png"><br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️新技能 get ?🔜MSTM📝 前面的图标都点点看看◼️⭐️-point-20230227-0907%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222191532.png" alt="image.png"></p><h3 id="5-2-4-从容器中获取-TomcatServletWebServerFactory"><a href="#5-2-4-从容器中获取-TomcatServletWebServerFactory" class="headerlink" title="5.2.4. 从容器中获取 TomcatServletWebServerFactory"></a>5.2.4. 从容器中获取 TomcatServletWebServerFactory</h3><p>V1：EmbeddedServletContainerFactory<br>因为前面有@Bean 注解注入，所以可以从 IOC 容器中获取嵌入式的 Servlet 容器工厂 TomcatServletWebServerFactory，然后就可以用来创建 Servlet 容器<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302090820.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091509.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091355.png" alt="image.png"></p><h3 id="5-2-5-后置处理器执行配置定制"><a href="#5-2-5-后置处理器执行配置定制" class="headerlink" title="5.2.5. 后置处理器执行配置定制"></a>5.2.5. 后置处理器执行配置定制</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302095054.png" alt="image.png"></p><p>当 TomcatServletWebServerFactory 创建 Servlet 容器对象时，后置处理器看这个对象，就来获取所有的定制器来定制 Servlet 容器的相关配置；</p><h3 id="5-2-6-创建-Servlet-容器并启动"><a href="#5-2-6-创建-Servlet-容器并启动" class="headerlink" title="5.2.6. 创建 Servlet 容器并启动"></a>5.2.6. 创建 Servlet 容器并启动</h3><p>通过 <code>getWebServer</code> 创建嵌入式的 Servlet 容器；<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230302091847.png" alt="image.png"></p><h3 id="5-2-7-顺序总结"><a href="#5-2-7-顺序总结" class="headerlink" title="5.2.7. 顺序总结"></a>5.2.7. 顺序总结</h3><p>IOC 容器启动时创建 Servlet 容器，然后先启动嵌入式的 Servlet 容器，最后再将 IOC 容器中剩下的没有创建出的对象创建出来</p><h2 id="5-3-概述"><a href="#5-3-概述" class="headerlink" title="5.3. 概述"></a>5.3. 概述</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190813.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224190858.png" alt="image.png"><br>❕<span style="display:none">%%<br>▶2.🏡⭐️◼️SpringBoot 中 SpringMVC 与 Spring 整合的 SpringMVC 区别 ?🔜MSTM📝 一般的 SpringMVC 是需要启动子容器的，而 SpringBoot 中只有 1 个容器，SpringMVC 是通过注入自动配置类生成的◼️⭐️-point-20230224-1911%%</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227093856.png" alt="image.png"></p><h1 id="6-SpringBoot-外置-Tomcat-启动原理⭐️🔴"><a href="#6-SpringBoot-外置-Tomcat-启动原理⭐️🔴" class="headerlink" title="6. SpringBoot 外置 Tomcat 启动原理⭐️🔴"></a>6. SpringBoot 外置 Tomcat 启动原理⭐️🔴</h1><p><span style="display:none">%%<br>▶3.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230324-0704%%</span>❕ ^er3z4j</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="6-1-操作步骤⭐️🔴"><a href="#6-1-操作步骤⭐️🔴" class="headerlink" title="6.1. 操作步骤⭐️🔴"></a>6.1. 操作步骤⭐️🔴</h2><p>1、必须创建一个 war 项目；<br>2、将嵌入式的 Tomcat 指定为 <code>provided</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、必须编写一个 <code>SpringBootServletInitializer</code> 的子类，并重写 configure 方法里面的写法，遵照固定写法，将 SpringBoot 的启动类放入 <code>application.sources</code> 的方法参数中。 ❕<span style="display:none">%%<br>▶13.🏡⭐️◼️使用外置的 Tomcat 启动 SpringBoot 项目的方法 ?🔜MSTM📝 需要编写一个 SpringBootServletInitializer 的子类，并将 SpringBoot 启动类放入到重写的 Configurer 方法中 application.sources 的入参中。◼️⭐️-point-20230302-1656%%</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalServletInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder application)</span> &#123;<br>        <span class="hljs-comment">//传入SpringBoot的主程序，</span><br>        <span class="hljs-keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4、启动服务器就可以；</p><h2 id="6-2-底层原理⭐️🔴"><a href="#6-2-底层原理⭐️🔴" class="headerlink" title="6.2. 底层原理⭐️🔴"></a>6.2. 底层原理⭐️🔴</h2><p>利用了 servlet3.0 规范官方文档：  当 servlet 容器启动时候就会去所有 jar 包中的 <code>META-INF/services</code>  文件夹中找到 <code>javax.servlet.ServletContainerInitializer</code>，有的 jar 包中存在这个文件并在里面会绑定一个 <code>ServletContainerInitializer</code>.   当 servlet 容器启动时候就会去该文件中找到 ServletContainerInitializer 的实现类，从而 <code>创建它的实例并调用其 onstartUp 方法</code><br>❕<span style="display:none">%%<br>▶14.🏡⭐️◼️标准的 SPI 机制：Tomcat 启动后会遍历查看所有 jar 包中 META-INF&#x2F;services 目录下的 javax.servlet.ServletContainerInitializer 文件中配置的全限定名为 <code>org.springframework.web.SpringServletContainerInitializer</code>，new Instance 并放入感兴趣的类集合中，遍历调用他们的 onstartup 方法；伪 SPI 机制：SpringBoot 的自动配置类的加载方式，启动时查找 META-INF&#x2F;spring.factories 文件中 enableAutoConfiguration&#x3D;xxx,\，根据每个类上@ConditionalOn 等条件判断，将 xxx 加载并创建 Bean◼️⭐️-point-20230302-1827%%</span></p><h2 id="6-3-执行流程"><a href="#6-3-执行流程" class="headerlink" title="6.3. 执行流程"></a>6.3. 执行流程</h2><p><span style="display:none">%%<br>▶9.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1054%%</span>❕ ^7d9w7<br>1、启动 Tomcat 服务器<br>2、spring web 模块里有这个文件</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224210917.png" alt="image.png"></p><p>文件内容是： <code>org.springframework.web.SpringServletContainerInitializer</code><br>3、SpringServletContainerInitializer 将 handlerTypes 标注的所有类型的类传入到 onStartip 方法的 <code>Set&lt;Class&lt;?&gt;&gt;</code> 中，并为这些感兴趣类创建实例<br>4、每个创建好的 WebApplicationInitializer 调用自己的 onStratup<br>5、因为有下图所示的继承关系，我们编写的 <code>ExternalServletInitializer</code> 和 <code>SpringBootServletInitializer</code> 都会被创建实例，并执行各自的 <code>StartUp</code> 方法，然而 ExternalServletInitializer 没有该方法，所以会调用其父类 SpringBootServletInitializer 的 onstartUp 方法。<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224204100.png" alt="image.png"></p><p>6、<code>SpringBootServletInitializer</code> 执行 onStartup 方法会执行 createRootApplicationContext，在调用其中的 <code>Configure</code> 时，由于其子类 <code>ExternalServletInitializer</code> 重写了这个方法，所以会调用子类重写的这个方法，那么就会将 SpringBoot 的主程序类传入进来。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224210646.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224204134.png" alt="image.png"></p><p>7、build SpringApplication 并启动；</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230325223837.png" alt="image.png"></p><h2 id="6-4-其他"><a href="#6-4-其他" class="headerlink" title="6.4. 其他"></a>6.4. 其他</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W76m?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1gW411W76m?p=51&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br>嵌入式的 Servlet 容器：应用打成 jar 包<br>​ 优点：简单、便携<br>​ 缺点：默认不支持 JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义定制器】，自己来编写嵌入式的容器工厂）</p><p>外置的 Servlet 容器：外面安装 Tomcat 是以 war 包的方式打包。<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W76m?p=52&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1gW411W76m?p=52&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h1 id="7-SpringBoot-的核心注解"><a href="#7-SpringBoot-的核心注解" class="headerlink" title="7. SpringBoot 的核心注解"></a>7. SpringBoot 的核心注解</h1><p>1. @SpringBootApplication 注解：这个注解标识了一个 SpringBoot 工程，它实际上是另外三个注解的组合，这三个注解是：<br>① @SpringBootConfiguration ：这个注解实际就是一个@Configuration，表示启动类也是一个配置类<br>② @EnableAutoConfiguration：向 Spring 容器中导入了一个 Selector，用来加载 ClassPath 下 SpringFactories 中所定义的自动配置类，将这些自动加载为配置 Bean  <br>③ @ComponentScan，但这个注解是 Spring 提供的<br>2.  @Conditional 也很关键，如果没有它我们无法在自定义应用中进行定制开发<br>@ConditionalOnBean、 <br>@ConditionalOnClass、<br>@ConditionalOnExpression、<br>@ConditionalOnMissingBean 等。</p><h1 id="8-为什么-SpringBoot-的-jar-可以直接运行⭐️🔴"><a href="#8-为什么-SpringBoot-的-jar-可以直接运行⭐️🔴" class="headerlink" title="8. 为什么 SpringBoot 的 jar 可以直接运行⭐️🔴"></a>8. 为什么 SpringBoot 的 jar 可以直接运行⭐️🔴</h1><p><span style="display:none">%%<br>▶5.🏡⭐️◼️【fatjar, spring-boot-loader.jar, MANIFEST-MF, mainclass, jarlauncher, startclass】◼️⭐️-point-20230303-1616%%</span> ^lf3ecs</p><h2 id="8-1-spring-boot-maven-plugin-打-Fat-jar"><a href="#8-1-spring-boot-maven-plugin-打-Fat-jar" class="headerlink" title="8.1. spring-boot-maven-plugin 打 Fat jar"></a>8.1. spring-boot-maven-plugin 打 Fat jar</h2><p><span style="display:none">%%<br>▶5.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-0847%%</span>❕ ^s0yjgz</p><ol><li><p>SpringBoot 提供了一个插件 <code>spring-boot-maven-plugin</code> 用于把程序打包成一个可执行的 jar 包。</p></li><li><p>SpringBoot 应用打包之后，生成一个 Fat jar(jar 包中包含 jar)，包含了<span style="background-color:#f0f">应用依赖的 jar 包和 <code>Spring Boot loader</code> 相关的类</span>。❕<span style="display:none">%%<br>▶10.🏡⭐️◼️与自定义 starter 里的类 spring-boot-starter 类对比记忆◼️⭐️-point-20230302-1516%%</span></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133452.png" alt="image.png"></p></li></ol><p><span style="background-color:#ff0">如果我们要看 spring-boot-loader 源码，那么就需要自己引入依赖</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133402.png" alt="image.png"></p><h2 id="8-2-MANIFEST-MF-文件"><a href="#8-2-MANIFEST-MF-文件" class="headerlink" title="8.2. MANIFEST.MF 文件"></a>8.2. MANIFEST.MF 文件</h2><ol start="3"><li>java -jar 会去找 jar 中的 <code>MANIFEST.MF</code> 文件，在那里面找到真正的启动类（<code>Main-Class</code>），Fat jar 的启动 Main 函数是 <code>JarLauncher</code>，在 <code>spring-boot-loader.jar</code> 中</li></ol><p>[[JVM源码分析之JVM启动流程_猿灯塔_InfoQ写作社区#^qwkqfc]]</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224123155.png" alt="image.png"></p><p>在 JarLauncher 类中的 main 方法中有 <code>launch</code> 方法，进入之后有 2 个非常重要的方法： <code>createClassLoader</code> 和 <code>launch</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133833.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224133951.png" alt="image.png"></p><h2 id="8-3-LaunchedURLClassLoader"><a href="#8-3-LaunchedURLClassLoader" class="headerlink" title="8.3. LaunchedURLClassLoader"></a>8.3. LaunchedURLClassLoader</h2><ol start="4"><li><code>createClassLoader</code> 负责创建一 <code>LaunchedURLClassLoader</code> 来<span style="background-color:#f0f">加载 BOOT-INF\lib 下面的 jar</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224132056.png" alt="image.png"></li></ol><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224123526.png" alt="image.png"></p><h2 id="8-4-launch"><a href="#8-4-launch" class="headerlink" title="8.4. launch"></a>8.4. launch</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230224132303.png" alt="image.png"></p><p><span style="background-color:#f0f"><code>launch</code> 负责以一个新线程启动应用的启动类的 Main 函数（找到 manifest 中的 Start-Class）</span></p><h1 id="9-自定义-starter⭐️🔴"><a href="#9-自定义-starter⭐️🔴" class="headerlink" title="9. 自定义 starter⭐️🔴"></a>9. 自定义 starter⭐️🔴</h1><p><span style="display:none">%%<br>▶76.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230306-1507%%</span>📙❕ ^5tcs5g</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=70&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=70&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h2 id="9-1-使用场景⭐️🔴"><a href="#9-1-使用场景⭐️🔴" class="headerlink" title="9.1. 使用场景⭐️🔴"></a>9.1. 使用场景⭐️🔴</h2><p>在我们的日常开发工作中，经常会有一些独立于业务之外的配置模块，我们经常将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，只需要将其在 pom 中引用依赖即可，利用 SpringBoot 为我们完成自动装配即可。</p><p>常见的自定义 Starter 场景比如:</p><p>动态数据源<br>登录模块<br>基于 AOP 技术实现日志切面<br><span style="display:none">%%<br>▶4.🏡⭐️◼️【🌈费曼无敌🌈⭐️♨️⭐️】◼️⭐️-point-20230315-0932%%</span>❕ ^xbsang</p><p><strong>场景一：简化多服务公用框架集成</strong>- 封装 swagger 配置<br>众所周知，springboot 或者其他第三方所提供的 starter，都是<span style="background-color:#0f0">做框架集成，通过简化配置，提高开发效率</span>，所以我们自定义 starter 的第一个应用场景也是基于这个思路。那我们日常开发工作中，有哪些框架是多个服务共用的，并且 springboot 或者其他第三方暂未提供，或者嫌弃第三方写的太烂，想自己重新实现的，都可以通过编写自定义 starter 来简化工作。我们公司采用微服务架构，每个服务都会使用 swagger 来生成在线接口文档。<span style="background-color:#ff0">未封装 swagger-starter 之前，那么在每个服务里边，都需要增加 swagger 的配置类</span>。而封装 swagger-starter 之后，可以省去这一步的操作，还可以通过增加自定义配置来实现一些自定义的功能。比如我们公司安全部门要求生产环境不能对外开放 swagger 接口文档地址，那么我们就可以添加一个 enabled 的参数来代表 swagger 是否启用，默认启用，在生产环境的配置中将 enabled 设为 false 即可达到这个目的。类似的额外功能还有很多，比如增加请求头等等，其他的读者自行发掘。<br>上面提到的是业务无关性的 starter 应用场景，那么我们抛出一个问题，是否有业务相关且多个业务场景或者多个服务会使用的应用场景？根据这个问题的描述，我们至少可以列出以下几个业务相关场景。 <a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/" title="服务治理-10、限流熔断降级(服务保护)-Sentinel">服务治理-10、限流熔断降级(服务保护)-Sentinel</a><br><strong>场景二：服务间调用的鉴权。</strong><br>我们<span style="background-color:#f0f">公司内部服务之间互相调用需要进行鉴权</span>（还是安全部门的要求），由于服务间是通过 feign 来实现相互调用，所以无法通过网关来进行统一鉴权。实现方案是通过新增 feign 拦截器，&#x3D;&#x3D;在源头服务发起调用之前增加鉴权参数，请求到达目标服务后通过鉴权参数进行鉴权&#x3D;&#x3D;。这两步操作很明显是每个服务都需要的，那么这种情况下，我们就可以把这两步操作封装成 starter，达到简化开发的目的。同时，我们还可以通过增加配置，实现更细粒度的调用权限控制，比如订单服务只能调用库存服务的查询商品库存接口，而无法调用更新商品库存的接口。<br><strong>场景三：邮件，短信，验证码功能。</strong><br>这些功能，在某些公司可能会放在 common 包里，但是这样其实会导致 common 包的臃肿，因为并不是所有服务都会使用到。有些公司（还是我们公司）可能对邮件服务器的访问有严格权限控制的，而且权限开通流程比较繁复的，那么会考虑做成服务，部署在已经具有访问权限的主机上，减去重复申请权限工作。如果除去这些限制，那么将这些功能封装成 starter 还是挺不错的，<span style="background-color:#f0f">可以避免 common 包的臃肿</span></p><h2 id="9-2-操作步骤"><a href="#9-2-操作步骤" class="headerlink" title="9.2. 操作步骤"></a>9.2. 操作步骤</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225092241.png" alt="image.png"></p><h3 id="9-2-1-确定场景需要使用依赖"><a href="#9-2-1-确定场景需要使用依赖" class="headerlink" title="9.2.1. 确定场景需要使用依赖"></a>9.2.1. 确定场景需要使用依赖</h3><h3 id="9-2-2-使用注解编写自动配置"><a href="#9-2-2-使用注解编写自动配置" class="headerlink" title="9.2.2. 使用注解编写自动配置"></a>9.2.2. 使用注解编写自动配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//指定这个类是一个配置类</span><br><span class="hljs-meta">@ConditionalOnXXX</span> <span class="hljs-comment">//在指定条件下成立的情况下自动配置类生效</span><br><span class="hljs-meta">@AutoConfigureAfter</span> <span class="hljs-comment">//指定自动配置类的顺序</span><br><span class="hljs-meta">@Bean</span> <span class="hljs-comment">//给容器中添加组件</span><br><br><span class="hljs-meta">@ConfigurationProperties</span> <span class="hljs-comment">//结合相关xxxProperties类来绑定相关的配置</span><br><span class="hljs-meta">@EnableConfigurationProperties</span> <span class="hljs-comment">//让xxxProperties生效加到容器中</span><br><br>自动配置类要能加载<br>将需要启动就加载的自动配置类，配置在META-INF/spring.factories<br># Auto Configure<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225100054.png" alt="image.png"></p><h3 id="9-2-3-编写-2-个模块"><a href="#9-2-3-编写-2-个模块" class="headerlink" title="9.2.3. 编写 2 个模块"></a>9.2.3. 编写 2 个模块</h3><p><span style="display:none">%%<br>▶12.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230305-1118%%</span>❕ ^8m431i</p><ol><li><p>启动器空的 jar 只需要做依赖管理导入；比如 <code>xxx-spring-boot-starter</code>，使用方只需要引入这个启动器即可<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326085427.png" alt="image.png"></p></li><li><p>专门写一个自动配置模块；比如 <code>xxx-spring-boot-starter-autoconfigurer</code>，所有的依赖项都放在这个模块的 <code>META-INF/spring.factories</code> 中，key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code><br>同时 pom 中需要添加基础依赖 <code>spring-boot-starter</code><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326085456.png" alt="image.png"></p></li><li><p>启动器依赖自动配置，别人只需要引入 starter<br>xxx-spring-boot-starter<br>❕<span style="display:none">%%<br>▶1.🏡⭐️◼️如果自定义 starter 中用到了属性信息 ?🔜MSTM📝 可以编写一个属性类，使用注解@ConfigurationProperties，然后使用 setter 方法或者构造导入的方法关联到 Service 类上，在 Configurer 类里直接注入使用◼️⭐️-point-20230226-0812%%</span></p></li></ol><h2 id="9-3-与-common-包对比"><a href="#9-3-与-common-包对比" class="headerlink" title="9.3. 与 common 包对比"></a>9.3. 与 common 包对比</h2><ol><li>common 包不灵活，需要不需要的内容都在一个 common 包里，不需要的内容也随着 common 包引入到工程中</li><li>单个功能增加太多，common 包容易变的臃肿</li></ol><h2 id="9-4-示例代码"><a href="#9-4-示例代码" class="headerlink" title="9.4. 示例代码"></a>9.4. 示例代码</h2><p>[[SpringBoot-V1-入门简介#^u6byiq]]<br>[[pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;springboot2&#x2F;boot-09-customer-starter&#x2F;atguigu-hello-spring-boot-starter-autoconfigure&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;atguigu&#x2F;hello&#x2F;auto&#x2F;HelloServiceAutoConfiguration.java]]</p><p>[[SpringBoot-V1-入门简介#8 1 新建一个 starter]]</p><h1 id="10-配置读取原理和优先级规则⭐️🔴"><a href="#10-配置读取原理和优先级规则⭐️🔴" class="headerlink" title="10. 配置读取原理和优先级规则⭐️🔴"></a>10. 配置读取原理和优先级规则⭐️🔴</h1><p><span style="display:none">%%<br>▶7.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230303-1851%%</span> ^uxezha</p><h2 id="10-1-读取原理"><a href="#10-1-读取原理" class="headerlink" title="10.1. 读取原理"></a>10.1. 读取原理</h2><p>通过事件监听的方式读取的配置文件：<code>ConfigFileApplicationListener</code><br>优先级从高到低，高优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。<br><code>ConfigFileApplicationListener</code> 会监听 <code>onApplicationEnvironmentPreparedEvent</code> 事件来加载配置文件 <code>application.properties</code> 的环境变量<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225112751.png" alt="image.png"></p><h2 id="10-2-优先级规则"><a href="#10-2-优先级规则" class="headerlink" title="10.2. 优先级规则"></a>10.2. 优先级规则</h2><h3 id="10-2-1-文件优先级"><a href="#10-2-1-文件优先级" class="headerlink" title="10.2.1. 文件优先级"></a>10.2.1. 文件优先级</h3><h4 id="10-2-1-1-外部配置源"><a href="#10-2-1-1-外部配置源" class="headerlink" title="10.2.1.1. 外部配置源"></a>10.2.1.1. 外部配置源</h4><p>常用：properties 文件、YAML 文件、环境变量、命令行参数；</p><h4 id="10-2-1-2-properties-优于-ymal"><a href="#10-2-1-2-properties-优于-ymal" class="headerlink" title="10.2.1.2. properties 优于 ymal"></a>10.2.1.2. properties 优于 ymal</h4><p>正常的情况是先加载 yml，接下来加载 properties 文件。如果相同的配置存在于两个文件中。最后会使用 properties 中的配置。最后读取的优先级最高。</p><p>两个配置文件中的端口号不一样会读取 properties 中的端口号</p><h3 id="10-2-2-查找覆盖优先级"><a href="#10-2-2-查找覆盖优先级" class="headerlink" title="10.2.2. 查找覆盖优先级"></a>10.2.2. 查找覆盖优先级</h3><p>配置文件查找位置：<span style="background-color:#f0f">查找覆盖顺序：优先级逐级变高</span></p><pre><code>        1. classpath 根路径
        2. classpath 根路径下 config 目录
        3. jar 包当前目录
        4. jar 包当前目录的 config 目录
        5. /config 子目录的直接子目录
</code></pre><h3 id="10-2-3-加载生效优先级"><a href="#10-2-3-加载生效优先级" class="headerlink" title="10.2.3. 加载生效优先级"></a>10.2.3. 加载生效优先级</h3><p>配置文件加载顺序：<span style="background-color:#f0f">加载顺序：外部&gt;内部、加 profile&gt;不加 profile</span></p><pre><code>        1.  当前 jar 包内部的 application.properties 和 application.yml
    　2.  当前 jar 包内部的 application-&#123;profile&#125;.properties 和 application-&#123;profile&#125;.yml
    　3. 引用的外部 jar 包的 application.properties 和 application.yml
    　4. 引用的外部 jar 包的 application-&#123;profile&#125;.properties 和 application-&#123;profile&#125;.yml
</code></pre><h3 id="10-2-4-官方文档"><a href="#10-2-4-官方文档" class="headerlink" title="10.2.4. 官方文档"></a>10.2.4. 官方文档</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225114206.png" alt="image.png"></p><p><span style="background-color:#f0f">指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</span></p><h3 id="10-2-5-案例"><a href="#10-2-5-案例" class="headerlink" title="10.2.5. 案例"></a>10.2.5. 案例</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225112420.png" alt="image.png"></p><h1 id="11-SpringBoot-的默认日志实现框架及切换"><a href="#11-SpringBoot-的默认日志实现框架及切换" class="headerlink" title="11. SpringBoot 的默认日志实现框架及切换"></a>11. SpringBoot 的默认日志实现框架及切换</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mf4y1c7cV?p=82&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1mf4y1c7cV?p=82&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=23&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=23&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230225115626.png" alt="image.png"></p><h2 id="11-1-SpringBoot-日志框架"><a href="#11-1-SpringBoot-日志框架" class="headerlink" title="11.1. SpringBoot 日志框架"></a>11.1. SpringBoot 日志框架</h2><p>1. SpringBoot 底层使用 slf4j+logback 的方式进行日志记录<br>logback 桥接：logback-classic<br>2. SpringBoot 同时也把其他的日志都替换成了 slf4j；<br>a. log4j2 适配： log4j-over-slf4j   (默认提供了适配器，如果切换 log4j2 只需要更换场景启动器即可)<br>b. jul 适配：jul-to-slf4j <br>c. jcl 适配：jcl-over-slf4j<br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326121315.png"></p><h2 id="11-2-将-logback-切换成-log4j2"><a href="#11-2-将-logback-切换成-log4j2" class="headerlink" title="11.2. 将 logback 切换成 log4j2"></a>11.2. 将 logback 切换成 log4j2</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230326130656.png" alt="image.png"></p><p>1. 将 logback 的场景启动器排除（slf4j 只能运行有 1 个桥接器）<br>2. 添加 log4j2 的场景启动器<br>3. 添加 log4j2 的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 排除掉logback的依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 添加log4j2依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="11-3-将-logback-切换成-log4j"><a href="#11-3-将-logback-切换成-log4j" class="headerlink" title="11.3. 将 logback 切换成 log4j"></a>11.3. 将 logback 切换成 log4j</h2><p>1. 要将 logback 的桥接器排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2. 添加 log4j 的桥接器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j‐log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3. 添加 log4j 的配置文件</p><h1 id="12-容器"><a href="#12-容器" class="headerlink" title="12. 容器"></a>12. 容器</h1><p>在 Web 环境中是由 Spring 和 SpringMvc 两个容器组成的，在 SpringBoot 环境中只有一个容器 AnnotationConfigEmbeddedWebApplicationContext。也就是可以说是由 SpringBoot 容器管理的。</p><h2 id="12-1-配置嵌入式-Servlet-容器"><a href="#12-1-配置嵌入式-Servlet-容器" class="headerlink" title="12.1. 配置嵌入式 Servlet 容器"></a>12.1. 配置嵌入式 Servlet 容器</h2><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222080746.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222080710.png" alt="image.png"></p><h2 id="12-2-嵌入式-Servlet-容器自动配置原理-v1⭐️🔴"><a href="#12-2-嵌入式-Servlet-容器自动配置原理-v1⭐️🔴" class="headerlink" title="12.2. 嵌入式 Servlet 容器自动配置原理 v1⭐️🔴"></a>12.2. 嵌入式 Servlet 容器自动配置原理 v1⭐️🔴</h2><p><span style="display:none">%%<br>▶8.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230302-1057%%</span><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=48&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=48&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230223220427.png" alt="image.png"> ^17d8bq</p><h3 id="12-2-1-引入依赖触发自动配置"><a href="#12-2-1-引入依赖触发自动配置" class="headerlink" title="12.2.1. 引入依赖触发自动配置"></a>12.2.1. 引入依赖触发自动配置</h3><p> 当加入 <code>Spring-boot-starter-web</code> 场景启动器依赖时，<code>@ConditionalOnWebApplication</code> 注解会触发 EmbeddedServletContainerAutoConfiguration 自动配置类开启嵌入式 Servlet 容器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@Import(BeanPostProcessorsRegistrar.class)</span><br><span class="hljs-comment">//给容器导入组件 后置处理器 在Bean初始化前后执行前置后置的逻辑 创建完对象还没属性赋值进行初始化工作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedServletContainerAutoConfiguration</span> &#123;<br>    <span class="hljs-meta">@Configuration</span><br>	<span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)</span><span class="hljs-comment">//当前是否引入tomcat依赖</span><br>    <span class="hljs-comment">//判断当前容器没有用户自定义EmbeddedServletContainerFactory，就会创建默认的嵌入式容器</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmbeddedTomcat</span> &#123;<br><br>		<span class="hljs-meta">@Bean</span><br>		<span class="hljs-keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="hljs-title function_">tomcatEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TomcatEmbeddedServletContainerFactory</span>();<br>		&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-2-创建默认的嵌入式容器-EmbeddedServletContainerFactory"><a href="#12-2-2-创建默认的嵌入式容器-EmbeddedServletContainerFactory" class="headerlink" title="12.2.2. 创建默认的嵌入式容器 -EmbeddedServletContainerFactory"></a>12.2.2. 创建默认的嵌入式容器 -EmbeddedServletContainerFactory</h3><p>如果当前容器没有用户自定义 EmbeddedServletContainerFactory，就会创建一个默认的 TomcatEmbeddedServletContainerFactory，用来创建嵌入式容器，默认为 Tomcat，也支持其他嵌入式容器，3 种工厂分别可以创建 3 种 EmbeddedServletContainer，继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222085416.jpg" alt="24.EmdServletFactory"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222085423.jpg" alt="25.EmdServletContainer"></p><p>以 TomcatEmbeddedServletContainerFactory 为例，<span style="background-color:#0f0">new 了一个 Tomcat 出来</span>并配置，然后传入 <code>getTomcatEmbeddedServletContainer</code> 方法，在该方法中会启动 Tomcat。SpringBoot2 中该方法名字为 getWebServer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> EmbeddedServletContainer <span class="hljs-title function_">getEmbeddedServletContainer</span><span class="hljs-params">(</span><br><span class="hljs-params">      ServletContextInitializer... initializers)</span> &#123;<br>   <span class="hljs-type">Tomcat</span> <span class="hljs-variable">tomcat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tomcat</span>();<br>    <span class="hljs-comment">//配置tomcat的基本环节</span><br>   <span class="hljs-type">File</span> <span class="hljs-variable">baseDir</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.baseDirectory != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.baseDirectory<br>         : createTempDir(<span class="hljs-string">&quot;tomcat&quot;</span>));<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   <span class="hljs-type">Connector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connector</span>(<span class="hljs-built_in">this</span>.protocol);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(<span class="hljs-literal">false</span>);<br>   configureEngine(tomcat.getEngine());<br>   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-built_in">this</span>.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>    <span class="hljs-comment">//将配置好的tomcat传入进去；并且启动tomcat容器</span><br>   <span class="hljs-keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-3-嵌入式配置自动解析方式-EmbeddedServletContainerCustomizerBeanPostProcessor"><a href="#12-2-3-嵌入式配置自动解析方式-EmbeddedServletContainerCustomizerBeanPostProcessor" class="headerlink" title="12.2.3. 嵌入式配置自动解析方式 -EmbeddedServletContainerCustomizerBeanPostProcessor"></a>12.2.3. 嵌入式配置自动解析方式 -EmbeddedServletContainerCustomizerBeanPostProcessor</h3><p>有 2 种方式：ServerProperties、EmbeddedServletContainerCustomizer</p><p><strong>EmbeddedServletContainerCustomizer 自动应用 Servlet 容器配置原理</strong>：<br>是通过 <strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong> 来完成的</p><p>容器在配置类 <code>EmbeddedServletContainerAutoConfiguration</code> 中通过 <code>@Import(BeanPostProcessorsRegistrar.class)</code> 导入了 <strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong>，在 <code>postProcessBeforeInitialization</code> 方法中，判断如果当前初始化的是一个 ConfigurableEmbeddedServletContainer，就会获取所有的定制器，调用每个定制器的 customer 方法给 Servlet 容器进行赋值。</p><p><code>BeanPostProcessorsRegistrar.registerBeanDefinitions</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span><br><span class="hljs-params">      BeanDefinitionRegistry registry)</span> &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.beanFactory == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   registerSyntheticBeanIfMissing(registry,<br>         <span class="hljs-string">&quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;</span>,<br>         EmbeddedServletContainerCustomizerBeanPostProcessor.class);<br>   registerSyntheticBeanIfMissing(registry,<br>         <span class="hljs-string">&quot;errorPageRegistrarBeanPostProcessor&quot;</span>,<br>         ErrorPageRegistrarBeanPostProcessor.class);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>EmbeddedServletContainerCustomizerBeanPostProcessor.postProcessBeforeInitialization</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span><br>      <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer</span><br>   <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;<br>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);<br>   &#125;<br>   <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(</span><br><span class="hljs-params">    ConfigurableEmbeddedServletContainer bean)</span> &#123;<br>    <span class="hljs-comment">//获取所有的定制器，调用每个定制器的customer方法给Servlet容器进行赋值</span><br>    <span class="hljs-keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;<br>        customizer.customize(bean);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="hljs-title function_">getCustomizers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.customizers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Look up does not include the parent context</span><br>        <span class="hljs-built_in">this</span>.customizers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;EmbeddedServletContainerCustomizer&gt;(<br>            <span class="hljs-built_in">this</span>.beanFactory<br>            <span class="hljs-comment">//从容器中获取所有的这个类型的组件：EmbeddedServletContainerCustomizer</span><br>            <span class="hljs-comment">//定制Servlet,给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span><br>            .getBeansOfType(EmbeddedServletContainerCustomizer.class,<br>                            <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>            .values());<br>        Collections.sort(<span class="hljs-built_in">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);<br>        <span class="hljs-built_in">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-built_in">this</span>.customizers);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.customizers;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="background-color:#0f0">而 ServerProperties 也是 EmbeddedServletContainerCustomizer 实现类，所以也会被自动配置</span><br><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230222094902.png" alt="image.png"></p><h3 id="12-2-4-总结"><a href="#12-2-4-总结" class="headerlink" title="12.2.4. 总结"></a>12.2.4. 总结</h3><p>1）、SpringBoot 根据导入的依赖情况，给容器中添加响应的容器工厂比如 tomcat<br>对应的 <code>TomcatEmbeddedServletContainerFactory</code></p><p>2）、容器中某个组件要创建对象就要通过后置处理器；<br><code>EmbeddedServletContainerCustomizerBeanPostProcessor</code><br>只要是嵌入式的 Servlet 容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取的所有的 EmbeddedServletContainerCustomizer，调用定制器的定制方法</p><h2 id="12-3-定制化原理"><a href="#12-3-定制化原理" class="headerlink" title="12.3. 定制化原理"></a>12.3. 定制化原理</h2><ol><li>修改配置文件；</li><li>xxxxxCustomizer；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebServerFactoryCustomizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebServerFactoryCustomizer</span>&lt;ConfigurableServletWebServerFactory&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory server)</span> &#123;<br>        server.setPort(<span class="hljs-number">9000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>编写自定义的配置类 xxxConfiguration；+ @Bean 替换、增加容器中默认组件；视图解析器</li><li>Web 应用编写一个配置类实现 <code>WebMvcConfigurer</code> 即可定制化 web 功能；+ <code>@Bean</code> 给容器中再扩展一些组件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminWebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span><br></code></pre></td></tr></table></figure><ol start="5"><li>@EnableWebMvc + WebMvcConfigurer —— @Bean 可以全面接管 SpringMVC，所有规则全部自己重新配置；实现定制和扩展功能<br>○ 原理<br>○ 1、WebMvcAutoConfiguration 默认的 SpringMVC 的自动配置功能类。静态资源、欢迎页…..<br>○ 2、一旦使用 @EnableWebMvc 会@Import(<code>DelegatingWebMvcConfiguration.class</code>)<br>○ 3、DelegatingWebMvcConfiguration 的作用，只保证 SpringMVC 最基本的使用<br>■ 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer 合起来一起生效<br>■ 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取<br>■ public class DelegatingWebMvcConfiguration extends <code>WebMvcConfigurationSupport</code><br>○ 4、WebMvcAutoConfiguration 里面的配置要能生效必须 <span style="background-color:#f0f">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br>○ 5、@EnableWebMvc 导致了 WebMvcAutoConfiguration 没有生效。</li></ol><h1 id="13-Java-Config"><a href="#13-Java-Config" class="headerlink" title="13. Java Config"></a>13. Java Config</h1><h2 id="13-1-Configuration-proxyBeanMethods-x3D-false"><a href="#13-1-Configuration-proxyBeanMethods-x3D-false" class="headerlink" title="13.1. @Configuration(proxyBeanMethods &#x3D; false)"></a>13.1. @Configuration(proxyBeanMethods &#x3D; false)</h2><p>lite 模式下，直接返回新实例对象，不用生成代理。</p><p>Spring 5.2.0+ 的版本，建议你的配置类均采用 Lite 模式去做，即显示设置 <code>proxyBeanMethods = false</code>。Spring Boot 在 2.2.0 版本（依赖于 Spring 5.2.0）起就把它的所有的自动配置类的此属性改为了 false，即@Configuration(proxyBeanMethods &#x3D; false)，目的是为了提高 Spring 启动速度</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunxing323/article/details/108655250">https://blog.csdn.net/yunxing323/article/details/108655250</a></p><h2 id="13-2-Import"><a href="#13-2-Import" class="headerlink" title="13.2. @Import"></a>13.2. @Import</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921204122547.png" alt="image-20210921204122547"></p><h1 id="14-Rest-原理"><a href="#14-Rest-原理" class="headerlink" title="14. Rest 原理"></a>14. Rest 原理</h1><h2 id="14-1-filter-wrapper"><a href="#14-1-filter-wrapper" class="headerlink" title="14.1. filter+wrapper"></a>14.1. filter+wrapper</h2><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921060612553.png" alt="image-20210921060612553"><br>Rest 原理（表单提交要使用 REST 的时候）<br>● 表单提交会带上 <code>_method=PUT</code><br>● 请求过来被 <code>HiddenHttpMethodFilter</code> 拦截<br>○ 请求是否正常，并且是 POST<br>■ 获取到 _method 的值。<br>■ 兼容以下请求；<code>PUT、DELETE、PATCH</code><br>■ 原生 request（post），包装模式 <code>requesWrapper</code> 重写了 getMethod 方法，返回的是传入的值。<br>■ 过滤器链放行的时候用 wrapper。以后的方法调用 getMethod 是调用 requesWrapper 的。</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921060523227.png" alt="image-20210921060523227"></p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230324190828.png" alt="image.png"></p><p>Rest 使用客户端工具，<br>● 如 PostMan 直接发送 Put、delete 等方式请求，无需 Filter，但要注意方式可用取值为 <code>GET、PUT、DELETE、PATCH</code>。</p><h2 id="14-2-自定义隐藏域名称"><a href="#14-2-自定义隐藏域名称" class="headerlink" title="14.2. 自定义隐藏域名称"></a>14.2. 自定义隐藏域名称</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义filter</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HiddenHttpMethodFilter <span class="hljs-title function_">hiddenHttpMethodFilter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HiddenHttpMethodFilter</span> <span class="hljs-variable">methodFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HiddenHttpMethodFilter</span>();<br>        methodFilter.setMethodParam(<span class="hljs-string">&quot;_m&quot;</span>);<br>        <span class="hljs-keyword">return</span> methodFilter;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="15-请求映射原理⭐️🔴"><a href="#15-请求映射原理⭐️🔴" class="headerlink" title="15. 请求映射原理⭐️🔴"></a>15. 请求映射原理⭐️🔴</h1><p><span style="display:none">%%<br>▶1.🏡⭐️◼️【🌈费曼无敌🌈⭐️第一步⭐️】◼️⭐️-point-20230410-0835%%</span>❕ ^ijjhr0</p><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=139&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV1Et411Y7tQ?p=139&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><p>DispatchServlet</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20210921061541902.png" alt="image-20210921061541902"></p><h2 id="15-1-请求路径"><a href="#15-1-请求路径" class="headerlink" title="15.1. 请求路径"></a>15.1. 请求路径</h2><p><code>HttpServlet.doGet</code> → <code>FrameworkServlet.processRequest</code> → <code>FrameworkServlet.doService</code> → <code>DispatcherServlet.doService</code> → <code>DispatcherServlet.doDispatch</code> (每个请求都会调用这个方法)</p><h2 id="15-2-执行逻辑"><a href="#15-2-执行逻辑" class="headerlink" title="15.2. 执行逻辑"></a>15.2. 执行逻辑</h2><h3 id="15-2-1-handlerMappings"><a href="#15-2-1-handlerMappings" class="headerlink" title="15.2.1. handlerMappings"></a>15.2.1. handlerMappings</h3><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011085954656.png" alt="image-20211011085954656"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011091433222.png" alt="image-20211011091433222"></p><p>● 请求进来，挨个尝试所有的 HandlerMapping 看是否有请求信息。<br>○ 如果有就找到这个请求对应的 handler<br>○ 如果没有就是下一个 HandlerMapping</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090131565.png" alt="image-20211011090131565"></p><h3 id="15-2-2-RequestMappingHeaderMapping"><a href="#15-2-2-RequestMappingHeaderMapping" class="headerlink" title="15.2.2. RequestMappingHeaderMapping"></a>15.2.2. RequestMappingHeaderMapping</h3><p>保存了所有@RequestMapping 和对应 handler 的所有映射关系</p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090316527.png" alt="image-20211011090316527"></p><h3 id="15-2-3-获取-handler-逻辑"><a href="#15-2-3-获取-handler-逻辑" class="headerlink" title="15.2.3. 获取 handler 逻辑"></a>15.2.3. 获取 handler 逻辑</h3><h3 id="15-2-4-mappingRegistry"><a href="#15-2-4-mappingRegistry" class="headerlink" title="15.2.4. mappingRegistry"></a>15.2.4. mappingRegistry</h3><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230227103610.png" alt="image-20211011090316527"></p><p><img src="https://github.com/TaylorLuo/typora-imgs/raw/master/img/image-20211011090729432.png" alt="image-20211011090729432"></p><h1 id="16-其他"><a href="#16-其他" class="headerlink" title="16. 其他"></a>16. 其他</h1><h2 id="16-1-jar-包引入方式"><a href="#16-1-jar-包引入方式" class="headerlink" title="16.1. jar 包引入方式"></a>16.1. jar 包引入方式</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1500334">https://cloud.tencent.com/developer/article/1500334</a></p><h3 id="16-1-1-spring-boot-starter-parent"><a href="#16-1-1-spring-boot-starter-parent" class="headerlink" title="16.1.1. spring-boot-starter-parent"></a>16.1.1. spring-boot-starter-parent</h3><h3 id="16-1-2-spring-boot-dependencies"><a href="#16-1-2-spring-boot-dependencies" class="headerlink" title="16.1.2. spring-boot-dependencies"></a>16.1.2. spring-boot-dependencies</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/haohao_g/article/details/99695535">https://blog.csdn.net/haohao_g/article/details/99695535</a></p><p><strong>使用场景</strong>：可能有自己的企业标准 parent</p><p>或者你可能只是比较喜欢明确声明所有的 Maven 配置</p><h2 id="16-2-多继承问题"><a href="#16-2-多继承问题" class="headerlink" title="16.2. 多继承问题"></a>16.2. 多继承问题</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7145f01ac3ad">https://www.jianshu.com/p/7145f01ac3ad</a></p><h2 id="16-3-dependencyManagement"><a href="#16-3-dependencyManagement" class="headerlink" title="16.3. dependencyManagement"></a>16.3. dependencyManagement</h2><p>dependencyManagement 节点的作用是统一 maven 引入依赖 JAR 包的版本号，可以看出 spring-boot-dependencies 最重要的一个作用就是对 springboot 可能用到的依赖 JAR 包做了版本号的控制管理</p><h1 id="17-与-Spring-的不同之处"><a href="#17-与-Spring-的不同之处" class="headerlink" title="17. 与 Spring 的不同之处"></a>17. 与 Spring 的不同之处</h1><h2 id="17-1-动态代理"><a href="#17-1-动态代理" class="headerlink" title="17.1. 动态代理"></a>17.1. 动态代理</h2><ol><li>Spring 是动态选择的，有接口就用 JDK 动态代理，否则使用 cglib 动态代理<br>可以通过 <code>exproxy-target-class</code><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/" title="1、Spring-基础">1、Spring-基础</a></li><li>SpringBoot 默认是 cglib 动态代理</li></ol><h2 id="17-2-SpringMVC-容器⭐️🔴"><a href="#17-2-SpringMVC-容器⭐️🔴" class="headerlink" title="17.2. SpringMVC 容器⭐️🔴"></a>17.2. SpringMVC 容器⭐️🔴</h2><ol><li>Spring 集成 SpringMVC 是通过 SPI 方式注册子容器来实现集成</li><li>SpringBoot 通过@Bean 注册了 DispatcherServlet，并没有像 Spring 集成 SpringMVC 中那样，通过 SPI 的方式创建子容器</li></ol><h1 id="18-参考与感谢"><a href="#18-参考与感谢" class="headerlink" title="18. 参考与感谢"></a>18. 参考与感谢</h1><h2 id="18-1-SpringBoot"><a href="#18-1-SpringBoot" class="headerlink" title="18.1. SpringBoot"></a>18.1. SpringBoot</h2><h3 id="18-1-1-视频"><a href="#18-1-1-视频" class="headerlink" title="18.1.1. 视频"></a>18.1.1. 视频</h3><p>01、P112–P198 为雷神 2021 版 springboot2 教程 &lt;– 建议直接看新版 02、2021 版直达链接: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4">https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4</a><br>&#x2F;Volumes&#x2F;Seagate Bas&#x2F;001-ArchitectureRoad&#x2F;尚硅谷 Springboot 经典版（核心技术 and 整合篇）&#x2F;核心技术篇&#x2F;视频 3&#x2F;视频 3 ^yfxc8z</p><h3 id="18-1-2-代码"><a href="#18-1-2-代码" class="headerlink" title="18.1.2. 代码"></a>18.1.2. 代码</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;SpringBoot</p><h3 id="18-1-3-笔记"><a href="#18-1-3-笔记" class="headerlink" title="18.1.3. 笔记"></a>18.1.3. 笔记</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;002- 框架源码专题&#x2F;000-Spring&#x2F;SpringBoot<br>[[SpringBoot]]</p><h2 id="18-2-SpringBoot2"><a href="#18-2-SpringBoot2" class="headerlink" title="18.2. SpringBoot2"></a>18.2. SpringBoot2</h2><h3 id="18-2-1-视频"><a href="#18-2-1-视频" class="headerlink" title="18.2.1. 视频"></a>18.2.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT?p=58&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV19K4y1L7MT?p=58&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="18-2-2-笔记"><a href="#18-2-2-笔记" class="headerlink" title="18.2.2. 笔记"></a>18.2.2. 笔记</h3><p>语雀： <a target="_blank" rel="noopener" href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></p><h3 id="18-2-3-代码"><a href="#18-2-3-代码" class="headerlink" title="18.2.3. 代码"></a>18.2.3. 代码</h3><p>&#x2F;Users&#x2F;taylor&#x2F;Nutstore Files&#x2F;Obsidian_data&#x2F;pages&#x2F;002-schdule&#x2F;001-Arch&#x2F;001-Subject&#x2F;013-DemoCode&#x2F;springboot2</p><h2 id="18-3-汇总"><a href="#18-3-汇总" class="headerlink" title="18.3. 汇总"></a>18.3. 汇总</h2><blockquote><p>01、P112–P198 为雷神 2021 版 springboot2 教程 &lt;– 建议直接看新版 02、2021 版直达链接: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4">https://www.bilibili.com/video/BV1Et411Y7tQ?p=112&amp;spm_id_from=333.788.b_636f6d6d656e74.4</a></p></blockquote><hr><p>2021 版配套笔记及源码：<br>配套源码 - 雷神码云地址： <a target="_blank" rel="noopener" href="https://gitee.com/leifengyang/springboot2">https://gitee.com/leifengyang/springboot2</a><br>配套笔记 - 语雀地址： <a target="_blank" rel="noopener" href="https://yuque.com/atguigu/springboot">https://yuque.com/atguigu/springboot</a></p><hr><p>旧版配套源码、文档等：<br>尚硅谷 springboot 核心篇 + 整合篇配套资料<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Yfv05ncJoP_gOHB6cm9jdg">https://pan.baidu.com/s/1Yfv05ncJoP_gOHB6cm9jdg</a> 提取码: 9h5i</p><h2 id="18-4-其他"><a href="#18-4-其他" class="headerlink" title="18.4. 其他"></a>18.4. 其他</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zh411H79h?p=4">https://www.bilibili.com/video/BV1zh411H79h?p=4</a></p><h2 id="18-5-Spring"><a href="#18-5-Spring" class="headerlink" title="18.5. Spring"></a>18.5. Spring</h2><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/" title="1、Spring-基础">1、Spring-基础</a><h2 id="18-6-黑马⭐️🔴✅"><a href="#18-6-黑马⭐️🔴✅" class="headerlink" title="18.6. 黑马⭐️🔴✅"></a>18.6. 黑马⭐️🔴✅</h2><h3 id="18-6-1-视频"><a href="#18-6-1-视频" class="headerlink" title="18.6.1. 视频"></a>18.6.1. 视频</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15b4y1a7yG?p=169&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204">https://www.bilibili.com/video/BV15b4y1a7yG?p=169&amp;spm_id_from=pageDriver&amp;vd_source=c5b2d0d7bc377c0c35dbc251d95cf204</a></p><h3 id="18-6-2-资料"><a href="#18-6-2-资料" class="headerlink" title="18.6.2. 资料"></a>18.6.2. 资料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/Users/taylor/Nutstore Files/Obsidian_data/pages/<span class="hljs-number">002</span>-schdule/<span class="hljs-number">001</span>-Arch/<span class="hljs-number">001</span>-Subject/<span class="hljs-number">002</span>-框架源码专题/<span class="hljs-number">000</span>-Spring/SpringBoot/原理篇-资料<br></code></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">https://taylorluo.github.io/2023/06/12/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/SpringBoot-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timeline/">timeline</a></div><div class="post_share"><div class="social-share" data-image="https://picsum.photos/1920/962" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-10%E3%80%81%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7(%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4)-Sentinel/"><img class="prev-cover" src="https://unpkg.com/justlovesmile-img/cover2.jpg" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">服务治理-10、限流熔断降级(服务保护)-Sentinel</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/12/011-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E9%A2%98/1%E3%80%81Spring-%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://unpkg.com/justlovesmile-img/cover1.JPG" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1、Spring-基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-1%E3%80%81%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="计算机基础-基本原理-1、相关名词"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">计算机基础-基本原理-1、相关名词</div></div></a></div><div><a href="/2023/03/27/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/JDK-1%E3%80%81SPI/" title="框架源码专题-JDK-1、SPI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover5.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">框架源码专题-JDK-1、SPI</div></div></a></div><div><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-9%E3%80%81SQL%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/" title="框架源码专题-MySQL-9、SQL应用优化"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">框架源码专题-MySQL-9、SQL应用优化</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/01/22/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-19%E3%80%81Queue/" title="并发编程专题-基础-19、Queue"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">并发编程专题-基础-19、Queue</div></div></a></div><div><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构实战专题-基础-1、架构演进"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">架构实战专题-基础-1、架构演进</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SpringBoot-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">1. SpringBoot 的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">1.1. 依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E7%88%B6%E9%A1%B9%E7%9B%AE%E5%81%9A%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">1.1.1. 父项目做依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-starter-%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="toc-text">1.1.2. starter 场景启动器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">1.2. 自动配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-SpringBoot-%E7%9A%84%E7%90%86%E8%A7%A3-%E4%BC%98%E7%82%B9%E7%89%B9%E6%80%A7"><span class="toc-text">2. 谈谈你对 SpringBoot 的理解 (优点特性)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-SpringBoot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-SpringBootApplication-%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3. SpringBoot 自动配置原理 -@SpringBootApplication ⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">3.1. 引导加载自动配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-SpringBootConfiguration"><span class="toc-text">3.1.1. @SpringBootConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-ComponentScan"><span class="toc-text">3.1.2. @ComponentScan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-EnableAutoConfiguration"><span class="toc-text">3.1.3. @EnableAutoConfiguration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-AutoConfigurationPackage"><span class="toc-text">3.1.3.1. @AutoConfigurationPackage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-Import-AutoConfigurationImportSelector-class"><span class="toc-text">3.1.3.2. @Import(AutoConfigurationImportSelector.class)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-2-1-SPI-%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.3.2.1. SPI 原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%8C%89%E9%9C%80%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">3.2. 按需开启自动配置项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3. 修改默认配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%B8%8E-SpringMVC-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.4. 与 SpringMVC 配置的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%85%B3%E4%BA%8E-JSON-%E7%BC%96%E7%A0%81%E9%85%8D%E7%BD%AE"><span class="toc-text">3.4.1. 关于 JSON 编码配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-EnableAspectJAutoProxy%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">3.4.2. @EnableAspectJAutoProxy⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="toc-text">3.5. 自动配置总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E9%BB%91%E9%A9%AC%E8%A1%A5%E5%85%85"><span class="toc-text">3.6. 黑马补充</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-SpringBoot-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4. SpringBoot 的启动原理⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%88%9B%E5%BB%BA-SpringApplication"><span class="toc-text">4.1. 创建 SpringApplication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%BF%90%E8%A1%8C-SpringApplication"><span class="toc-text">4.2. 运行 SpringApplication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%AE%B0%E5%BD%95%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4-%E5%88%9B%E5%BB%BA%E5%BC%95%E5%AF%BC%E4%B8%8A%E4%B8%8B%E6%96%87-bootstrappers-intitialize"><span class="toc-text">4.2.1. 记录应用的启动时间 - 创建引导上下文 -bootstrappers.intitialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%8F%91%E5%B8%83-ApplicationStartingEvent-%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.2.2. 发布 ApplicationStartingEvent 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%8F%91%E5%B8%83-environmentPreparedEvent"><span class="toc-text">4.2.3. 读取环境配置信息发布 environmentPreparedEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E6%A0%B9%E6%8D%AE%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA-IOC-%E5%AE%B9%E5%99%A8%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.2.4. 根据项目类型创建 IOC 容器⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E5%87%86%E5%A4%87-IOC-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF-%E5%88%B7%E6%96%B0%E5%89%8D%E5%87%86%E5%A4%87-contextPrepared-loaded"><span class="toc-text">4.2.5. 准备 IOC 容器基本信息 (刷新前准备 -contextPrepared-loaded)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E5%88%B7%E6%96%B0-IOC-%E5%AE%B9%E5%99%A8%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">4.2.6. 刷新 IOC 容器⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-1-invokeBeanFactoryPostProcessors"><span class="toc-text">4.2.6.1. invokeBeanFactoryPostProcessors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-2-onrefresh-%E5%88%9B%E5%BB%BA%E5%AD%90%E5%AE%B9%E5%99%A8"><span class="toc-text">4.2.6.2. onrefresh 创建子容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E8%AE%B0%E5%BD%95%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9D%9F%E6%97%B6%E9%97%B4%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="toc-text">4.2.7. 记录启动结束时间并输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-8-%E5%8F%91%E5%B8%83-ApplicationStartedEvent"><span class="toc-text">4.2.8. 发布 ApplicationStartedEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-9-%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89-runners"><span class="toc-text">4.2.9. 调用所有 runners</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-10-%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8%E5%88%99%E5%8F%91%E9%80%81-ApplicationFailedEvent"><span class="toc-text">4.2.10. 如果启动异常则发送 ApplicationFailedEvent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%B5%8C%E5%85%A5%E5%BC%8F-Servlet-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86-V2"><span class="toc-text">5. 嵌入式 Servlet 容器启动原理 V2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E8%A7%A6%E5%8F%91%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">5.1. 引入依赖触发自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%8E%82%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.1.1. 容器工厂自动配置类⭐️🔴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-Web-%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%8E%82-%E9%BB%98%E8%AE%A4-Tomcat"><span class="toc-text">5.1.2. Web 容器工厂 - 默认 Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-Web-%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%8E%82%E5%AE%9A%E5%88%B6%E5%8C%96%E5%99%A8%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">5.1.3. Web 容器工厂定制化器的后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-1-BeanPostProcessorsRegistrar"><span class="toc-text">5.1.3.1. BeanPostProcessorsRegistrar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-2-WebServerFactoryCustomizer-%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%8E%82%E5%AE%9A%E5%88%B6%E5%8C%96%E5%99%A8-%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">5.1.3.2. WebServerFactoryCustomizer(容器工厂定制化器)⭐️🔴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-SpringBoot-%E5%BA%94%E7%94%A8%E6%89%A7%E8%A1%8C-Run-%E6%96%B9%E6%B3%95"><span class="toc-text">5.2. SpringBoot 应用执行 Run 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%88%9B%E5%BB%BA-IOC-%E5%AE%B9%E5%99%A8"><span class="toc-text">5.2.1. 创建 IOC 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB-refresh"><span class="toc-text">5.2.2. 调用父类 refresh()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E6%89%A7%E8%A1%8C%E9%87%8D%E5%86%99%E7%9A%84-onRefresh-%E6%96%B9%E6%B3%95"><span class="toc-text">5.2.3. 执行重写的 onRefresh() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%8F%96-TomcatServletWebServerFactory"><span class="toc-text">5.2.4. 从容器中获取 TomcatServletWebServerFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%89%A7%E8%A1%8C%E9%85%8D%E7%BD%AE%E5%AE%9A%E5%88%B6"><span class="toc-text">5.2.5. 后置处理器执行配置定制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-%E5%88%9B%E5%BB%BA-Servlet-%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-text">5.2.6. 创建 Servlet 容器并启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="toc-text">5.2.7. 顺序总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%A6%82%E8%BF%B0"><span class="toc-text">5.3. 概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-SpringBoot-%E5%A4%96%E7%BD%AE-Tomcat-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6. SpringBoot 外置 Tomcat 启动原理⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.1. 操作步骤⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">6.2. 底层原理⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">6.3. 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%85%B6%E4%BB%96"><span class="toc-text">6.4. 其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-SpringBoot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">7. SpringBoot 的核心注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88-SpringBoot-%E7%9A%84-jar-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">8. 为什么 SpringBoot 的 jar 可以直接运行⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-spring-boot-maven-plugin-%E6%89%93-Fat-jar"><span class="toc-text">8.1. spring-boot-maven-plugin 打 Fat jar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-MANIFEST-MF-%E6%96%87%E4%BB%B6"><span class="toc-text">8.2. MANIFEST.MF 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-LaunchedURLClassLoader"><span class="toc-text">8.3. LaunchedURLClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-launch"><span class="toc-text">8.4. launch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89-starter%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">9. 自定义 starter⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">9.1. 使用场景⭐️🔴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-text">9.2. 操作步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E7%A1%AE%E5%AE%9A%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96"><span class="toc-text">9.2.1. 确定场景需要使用依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">9.2.2. 使用注解编写自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E7%BC%96%E5%86%99-2-%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="toc-text">9.2.3. 编写 2 个模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E4%B8%8E-common-%E5%8C%85%E5%AF%B9%E6%AF%94"><span class="toc-text">9.3. 与 common 包对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">9.4. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">10. 配置读取原理和优先级规则⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E8%AF%BB%E5%8F%96%E5%8E%9F%E7%90%86"><span class="toc-text">10.1. 读取原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99"><span class="toc-text">10.2. 优先级规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">10.2.1. 文件优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-1-%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%BA%90"><span class="toc-text">10.2.1.1. 外部配置源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-2-properties-%E4%BC%98%E4%BA%8E-ymal"><span class="toc-text">10.2.1.2. properties 优于 ymal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E6%9F%A5%E6%89%BE%E8%A6%86%E7%9B%96%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">10.2.2. 查找覆盖优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-%E5%8A%A0%E8%BD%BD%E7%94%9F%E6%95%88%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">10.2.3. 加载生效优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-text">10.2.4. 官方文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-5-%E6%A1%88%E4%BE%8B"><span class="toc-text">10.2.5. 案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-SpringBoot-%E7%9A%84%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%88%87%E6%8D%A2"><span class="toc-text">11. SpringBoot 的默认日志实现框架及切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-SpringBoot-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-text">11.1. SpringBoot 日志框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%B0%86-logback-%E5%88%87%E6%8D%A2%E6%88%90-log4j2"><span class="toc-text">11.2. 将 logback 切换成 log4j2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%B0%86-logback-%E5%88%87%E6%8D%A2%E6%88%90-log4j"><span class="toc-text">11.3. 将 logback 切换成 log4j</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%AE%B9%E5%99%A8"><span class="toc-text">12. 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8F-Servlet-%E5%AE%B9%E5%99%A8"><span class="toc-text">12.1. 配置嵌入式 Servlet 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%B5%8C%E5%85%A5%E5%BC%8F-Servlet-%E5%AE%B9%E5%99%A8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-v1%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">12.2. 嵌入式 Servlet 容器自动配置原理 v1⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E8%A7%A6%E5%8F%91%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">12.2.1. 引入依赖触发自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-%E5%88%9B%E5%BB%BA%E9%BB%98%E8%AE%A4%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8-EmbeddedServletContainerFactory"><span class="toc-text">12.2.2. 创建默认的嵌入式容器 -EmbeddedServletContainerFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-3-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F-EmbeddedServletContainerCustomizerBeanPostProcessor"><span class="toc-text">12.2.3. 嵌入式配置自动解析方式 -EmbeddedServletContainerCustomizerBeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-4-%E6%80%BB%E7%BB%93"><span class="toc-text">12.2.4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-text">12.3. 定制化原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Java-Config"><span class="toc-text">13. Java Config</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-Configuration-proxyBeanMethods-x3D-false"><span class="toc-text">13.1. @Configuration(proxyBeanMethods &#x3D; false)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-Import"><span class="toc-text">13.2. @Import</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Rest-%E5%8E%9F%E7%90%86"><span class="toc-text">14. Rest 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-filter-wrapper"><span class="toc-text">14.1. filter+wrapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E8%97%8F%E5%9F%9F%E5%90%8D%E7%A7%B0"><span class="toc-text">14.2. 自定义隐藏域名称</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">15. 请求映射原理⭐️🔴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84"><span class="toc-text">15.1. 请求路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-text">15.2. 执行逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-1-handlerMappings"><span class="toc-text">15.2.1. handlerMappings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-2-RequestMappingHeaderMapping"><span class="toc-text">15.2.2. RequestMappingHeaderMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-3-%E8%8E%B7%E5%8F%96-handler-%E9%80%BB%E8%BE%91"><span class="toc-text">15.2.3. 获取 handler 逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-4-mappingRegistry"><span class="toc-text">15.2.4. mappingRegistry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E5%85%B6%E4%BB%96"><span class="toc-text">16. 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-jar-%E5%8C%85%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">16.1. jar 包引入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-spring-boot-starter-parent"><span class="toc-text">16.1.1. spring-boot-starter-parent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-spring-boot-dependencies"><span class="toc-text">16.1.2. spring-boot-dependencies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-text">16.2. 多继承问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-dependencyManagement"><span class="toc-text">16.3. dependencyManagement</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E4%B8%8E-Spring-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">17. 与 Spring 的不同之处</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">17.1. 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-SpringMVC-%E5%AE%B9%E5%99%A8%E2%AD%90%EF%B8%8F%F0%9F%94%B4"><span class="toc-text">17.2. SpringMVC 容器⭐️🔴</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-text">18. 参考与感谢</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-SpringBoot"><span class="toc-text">18.1. SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-1-%E8%A7%86%E9%A2%91"><span class="toc-text">18.1.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-2-%E4%BB%A3%E7%A0%81"><span class="toc-text">18.1.2. 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-3-%E7%AC%94%E8%AE%B0"><span class="toc-text">18.1.3. 笔记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-SpringBoot2"><span class="toc-text">18.2. SpringBoot2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-%E8%A7%86%E9%A2%91"><span class="toc-text">18.2.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-%E7%AC%94%E8%AE%B0"><span class="toc-text">18.2.2. 笔记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-3-%E4%BB%A3%E7%A0%81"><span class="toc-text">18.2.3. 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-%E6%B1%87%E6%80%BB"><span class="toc-text">18.3. 汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-%E5%85%B6%E4%BB%96"><span class="toc-text">18.4. 其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-Spring"><span class="toc-text">18.5. Spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-%E9%BB%91%E9%A9%AC%E2%AD%90%EF%B8%8F%F0%9F%94%B4%E2%9C%85"><span class="toc-text">18.6. 黑马⭐️🔴✅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-1-%E8%A7%86%E9%A2%91"><span class="toc-text">18.6.1. 视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-2-%E8%B5%84%E6%96%99"><span class="toc-text">18.6.2. 资料</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://picsum.photos/1920/962')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>