<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Kafka | Taylor</title><meta name="keywords" content="timeline"><meta name="author" content="Taylor Luo"><meta name="copyright" content="Taylor Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Kafka 知识总结1.1. 一、讲讲 acks 参数对消息持久化的影响1.1.1. 目录 写在前面 如何保证宕机时数据不丢失？ 多副本之间数据如何同步？ ISR 到底指的是什么东西？ acks 参数的含义？ 最后的思考  1.1.2. 1.写在前面面试大厂时，一旦简历上写了 Kafka，几乎必然会被问到一个问题：说说 acks 参数对消息持久化的影响？ 这个 acks 参数在 kafka"><meta property="og:type" content="article"><meta property="og:title" content="Kafka"><meta property="og:url" content="https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/index.html"><meta property="og:site_name" content="Taylor"><meta property="og:description" content="1. Kafka 知识总结1.1. 一、讲讲 acks 参数对消息持久化的影响1.1.1. 目录 写在前面 如何保证宕机时数据不丢失？ 多副本之间数据如何同步？ ISR 到底指的是什么东西？ acks 参数的含义？ 最后的思考  1.1.2. 1.写在前面面试大厂时，一旦简历上写了 Kafka，几乎必然会被问到一个问题：说说 acks 参数对消息持久化的影响？ 这个 acks 参数在 kafka"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://unpkg.com/justlovesmile-img/cover2.jpg"><meta property="article:published_time" content="2023-06-13T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-13T23:32:42.687Z"><meta property="article:author" content="Taylor Luo"><meta property="article:tag" content="timeline"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://unpkg.com/justlovesmile-img/cover2.jpg"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/code-anan/image/蜘蛛网万圣节.png"><link rel="canonical" href="https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Kafka",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 07:32:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/self/Kimbiedark.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Taylor" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/index.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://unpkg.com/justlovesmile-img/cover2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Taylor</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kafka</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T23:32:42.687Z" title="更新于 2023-06-14 07:32:42">2023-06-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="Kafka"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr><h1 id="1-Kafka-知识总结"><a href="#1-Kafka-知识总结" class="headerlink" title="1. Kafka 知识总结"></a>1. <strong>Kafka 知识总结</strong></h1><h2 id="1-1-一、讲讲-acks-参数对消息持久化的影响"><a href="#1-1-一、讲讲-acks-参数对消息持久化的影响" class="headerlink" title="1.1. 一、讲讲 acks 参数对消息持久化的影响"></a>1.1. <strong>一、讲讲 acks 参数对消息持久化的影响</strong></h2><h3 id="1-1-1-目录"><a href="#1-1-1-目录" class="headerlink" title="1.1.1. 目录"></a>1.1.1. <strong>目录</strong></h3><ol><li>写在前面</li><li>如何保证宕机时数据不丢失？</li><li>多副本之间数据如何同步？</li><li>ISR 到底指的是什么东西？</li><li>acks 参数的含义？</li><li>最后的思考</li></ol><h3 id="1-1-2-1-写在前面"><a href="#1-1-2-1-写在前面" class="headerlink" title="1.1.2. 1.写在前面"></a>1.1.2. <strong>1.写在前面</strong></h3><p>面试大厂时，一旦简历上写了 Kafka，几乎必然会被问到一个问题：说说 acks 参数对消息持久化的影响？</p><p>这个 acks 参数在 kafka 的使用中，是非常核心以及关键的一个参数，决定了很多东西。</p><p>所以无论是为了面试还是实际项目使用，大家都值得看一下这篇文章对 Kafka 的 acks 参数的分析，以及背后的原理。</p><h3 id="1-1-3-2-如何保证宕机的时候数据不丢失？（或者-kafka-如何保证高可用、或者-Kafka-如何保证高可用）"><a href="#1-1-3-2-如何保证宕机的时候数据不丢失？（或者-kafka-如何保证高可用、或者-Kafka-如何保证高可用）" class="headerlink" title="1.1.3. 2.如何保证宕机的时候数据不丢失？（或者 kafka 如何保证高可用、或者 Kafka 如何保证高可用）"></a>1.1.3. <strong>2.如何保证宕机的时候数据不丢失？（或者 kafka 如何保证高可用、或者 Kafka 如何保证高可用）</strong></h3><ul><li><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是 <strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是 <strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p></li><li><p>而且 Kafka 还提供 replica<strong>副本机制</strong>，每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。所有 replica 会选举出来一个 leader 出来，那么 <strong>生产和消费都跟这个 leader 打交道</strong>，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</p></li></ul><p>如果某个 broker 宕机了，那个 broker 上的 partition 在其他机器上都有副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么从 follower 中重新选举一个新的 leader 出来，然后继续读写新的 leader 即可，这就是所谓的高可用。</p><p><img src="https://raw.githubusercontent.com/TaylorLuo/typora-imgs/master/img20230514115527.jpg" alt="11"></p><h3 id="1-1-4-3-多副本之间数据如何保证同步"><a href="#1-1-4-3-多副本之间数据如何保证同步" class="headerlink" title="1.1.4. 3.多副本之间数据如何保证同步"></a>1.1.4. 3.<strong>多副本之间数据如何保证同步</strong></h3><p>其实任何一个 Partition，只有 Leader 是对外提供读写服务的，也就是说，如果有一个客户端往一个 Partition 写入数据，此时一般就是写入这个 Partition 的 Leader 副本。</p><p>然后 Leader 副本接收到数据之后，Follower 副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/2.jpg"></p><h3 id="1-1-5-4-ISR-到底指的是什么东西？"><a href="#1-1-5-4-ISR-到底指的是什么东西？" class="headerlink" title="1.1.5. 4.ISR 到底指的是什么东西？"></a>1.1.5. <strong>4.ISR 到底指的是什么东西？</strong></h3><p>ISR 全称是“In-Sync Replicas”，也就是 <strong>保持同步的副本</strong>，他的含义就是，跟 Leader 始终保持同步的 Follower 有哪些。</p><p>大家可以想一下 ，如果说某个 Follower 所在的 Broker 因为 JVM FullGC 之类的问题，导致自己卡顿了，无法及时从 Leader 拉取同步数据，那么是不是会导致 Follower 的数据比 Leader 要落后很多？</p><p>所以这个时候，就意味着 Follower 已经跟 Leader 不再处于同步的关系了。但是只要 Follower 一直及时从 Leader 同步数据，就可以保证他们是处于同步的关系的。</p><p>所以每个 Partition 都有一个 ISR，这个 ISR 里一定会有 Leader 自己，因为 Leader 肯定数据是最新的，然后就是那些跟 Leader 保持同步的 Follower，也会在 ISR 里。</p><h3 id="1-1-6-5-acks-参数的含义"><a href="#1-1-6-5-acks-参数的含义" class="headerlink" title="1.1.6. 5.acks 参数的含义"></a>1.1.6. <strong>5.acks 参数的含义</strong></h3><p>首先这个 acks 参数，是在 KafkaProducer，也就是生产者客户端里设置的</p><p>也就是说，你往 kafka 写数据的时候，就可以来设置这个 acks 参数。然后这个参数实际上有三种常见的值可以设置，分别是：<strong>0、1 和 all</strong>。</p><p><strong>第一种选择是把 acks 参数设置为 0</strong>，意思就是我的 KafkaProducer 在客户端，只要把消息发送出去，不管那条数据有没有在哪怕 Partition Leader 上落到磁盘，我就不管他了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。结果呢，Partition Leader 所在 Broker 就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会 <strong>导致这条消息就丢失了</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/3.jpg"></p><p><strong>第二种选择是设置 acks &#x3D; 1</strong>，意思就是说只要 Partition Leader 接收到消息而且写入本地磁盘了，就认为成功了，不管他其他的 Follower 有没有同步过去这条消息了。</p><p>这种设置其实是 <strong>kafka 默认的设置</strong></p><p>也就是说，默认情况下，你要是不管 acks 这个参数，只要 Partition Leader 写成功就算成功。</p><p>但是这里有一个问题，万一 Partition Leader 刚刚接收到消息，Follower 还没来得及同步过去，结果 Leader 所在的 broker 宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/4.jpg"></p><p><strong>最后一种情况，就是设置 acks&#x3D;all</strong>，这个意思就是说，<strong>Partition Leader 接收到消息之后，还必须要求 ISR 列表里跟 Leader 保持同步的那些 Follower 都要把消息同步过去</strong>，才能认为这条消息是写入成功了。</p><p>如果说 Partition Leader 刚接收到了消息，但是结果 Follower 没有收到消息，此时 Leader 宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能 Partition 2 的 Follower 变成 Leader 了，此时 ISR 列表里只有最新的这个 Follower 转变成的 Leader 了，那么只要这个新的 Leader 接收消息就算成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/5.jpg"></p><h3 id="1-1-7-6-最后的思考"><a href="#1-1-7-6-最后的思考" class="headerlink" title="1.1.7. 6.最后的思考"></a>1.1.7. <strong>6.最后的思考</strong></h3><p>acks&#x3D;all 就可以代表数据一定不会丢失了吗？</p><p>当然不是，如果你的 Partition 只有一个副本，也就是一个 Leader，任何 Follower 都没有，你认为 acks&#x3D;all 有用吗？</p><p>当然没用了，因为 ISR 里就一个 Leader，他接收完消息后宕机，也会导致数据丢失。</p><p>所以说，<strong>这个 acks&#x3D;all，必须跟 ISR 列表里至少有 2 个以上的副本配合使用</strong>，起码是有一个 Leader 和一个 Follower 才可以。</p><p>这样才能保证说写一条数据过去，一定是 2 个以上的副本都收到了才算是成功，此时任何一个副本宕机，不会导致数据丢失。</p><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A">https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A</a></p><h2 id="1-2-二、Kafka-参数调优实战"><a href="#1-2-二、Kafka-参数调优实战" class="headerlink" title="1.2. 二、Kafka 参数调优实战"></a>1.2. 二、Kafka 参数调优实战</h2><h3 id="1-2-1-目录"><a href="#1-2-1-目录" class="headerlink" title="1.2.1. 目录"></a>1.2.1. 目录</h3><ol><li>背景引入：很多同学看不懂的 Kafka 参数</li><li>一段 Kafka 生产端的示例代码</li><li>内存缓冲的大小</li><li>多少数据打包为一个 Batch 合适？</li><li>要是一个 Batch 迟迟无法凑满怎么办？</li><li>最大请求大小</li><li>重试机制</li><li>持久化机制</li></ol><h4 id="1-2-1-1-1、背景引入：很多同学看不懂的-kafka-参数"><a href="#1-2-1-1-1、背景引入：很多同学看不懂的-kafka-参数" class="headerlink" title="1.2.1.1. 1、背景引入：很多同学看不懂的 kafka 参数"></a>1.2.1.1. 1、背景引入：很多同学看不懂的 kafka 参数</h4><p>在使用 Kafka 的客户端编写代码与服务器交互的时候，是需要对客户端设置很多的参数的。</p><h4 id="1-2-1-2-2、一段-Kafka-生产端的示例代码"><a href="#1-2-1-2-2、一段-Kafka-生产端的示例代码" class="headerlink" title="1.2.1.2. 2、一段 Kafka 生产端的示例代码"></a>1.2.1.2. 2、一段 Kafka 生产端的示例代码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">Properties</span> props = <span class="hljs-keyword">new</span> <span class="hljs-type">Properties</span>();<br>props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;localhost:9092&quot;</span>); <br>props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);<br>props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">67108864</span>); <br>props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">131072</span>); <br>props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">100</span>); <br>props.put(<span class="hljs-string">&quot;max.request.size&quot;</span>, <span class="hljs-number">10485760</span>); <br>props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>); <br>props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">10</span>); <br>props.put(<span class="hljs-string">&quot;retry.backoff.ms&quot;</span>, <span class="hljs-number">500</span>);<br><br><span class="hljs-type">KafkaProducer</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaProducer</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt;(props);<br></code></pre></td></tr></table></figure><h4 id="1-2-1-3-3、内存缓冲的大小"><a href="#1-2-1-3-3、内存缓冲的大小" class="headerlink" title="1.2.1.3. 3、内存缓冲的大小"></a>1.2.1.3. 3、内存缓冲的大小</h4><p>首先看看“<strong>buffer.memory</strong>”这个参数是什么意思？</p><p>Kafka 的客户端发送数据到服务器，一般都是要经过 <strong>缓冲</strong> 的，也就是说，<strong>通过 KafkaProducer 发送出去的消息都是先进入到客户端本地的内存缓冲里，然后把很多消息收集成一个一个的 Batch，再发送到 Broker 上去的</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/6.jpg"></p><p>所以这个“<strong>buffer.memory”的本质就是用来约束 KafkaProducer 能够使用的内存缓冲的大小的，他的默认值是 32MB</strong>。</p><p>你可以先想一下，如果这个内存缓冲设置的过小的话，可能会导致一个什么问题？</p><p>首先要明确一点，那就是在内存缓冲里大量的消息会缓冲在里面，形成一个一个的 Batch，每个 Batch 里包含多条消息。</p><p>然后 KafkaProducer 有一个 Sender 线程会把多个 Batch 打包成一个 Request 发送到 Kafka 服务器上去。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/7.jpg"></p><p>那么如果要是 <strong>内存设置的太小</strong>，可能 <strong>导致一个问题</strong>：消息快速的写入内存缓冲里面，但是 Sender 线程来不及把 Request 发送到 Kafka 服务器。</p><p>这样是不是会造成内存缓冲很快就被写满？一旦被写满，就会阻塞用户线程，不让继续往 Kafka 写消息了。</p><p>所以对于“buffer.memory”这个参数应该结合自己的实际情况来进行压测，你需要测算一下在生产环境，你的用户线程会以每秒多少消息的频率来写入内存缓冲。</p><p>比如说每秒 300 条消息，那么你就需要压测一下，假设内存缓冲就 32MB，每秒写 300 条消息到内存缓冲，是否会经常把内存缓冲写满？经过这样的压测，你可以调试出来一个合理的内存大小。</p><h4 id="1-2-1-4-4、多少数据打包为一个-Batch-合适？"><a href="#1-2-1-4-4、多少数据打包为一个-Batch-合适？" class="headerlink" title="1.2.1.4. 4、多少数据打包为一个 Batch 合适？"></a>1.2.1.4. 4、多少数据打包为一个 Batch 合适？</h4><p>接着你需要思考第二个问题，就是你的“<strong>batch.size</strong>”应该如何设置？<strong>这决定了你的每个 Batch 要存放多少数据就可以发送出去了</strong>。</p><p>比如说你要是给一个 Batch 设置成是 16KB 的大小，那么里面凑够 16KB 的数据就可以发送了。</p><p>这个 <strong>参数的默认值是 16KB</strong>，一般可以尝试把这个参数调节大一些，然后利用自己的生产环境发消息的负载来测试一下。</p><p>比如说发送消息的频率就是每秒 300 条，那么如果比如“batch.size”调节到了 32KB，或者 64KB，是否可以提升发送消息的整体吞吐量。</p><p>因为理论上来说，提升 batch 的大小，可以允许更多的数据缓冲在里面，那么一次 Request 发送出去的数据量就更多了，这样吞吐量可能会有所提升。</p><p>但是 <strong>不能无限的大</strong>，过于大了之后，要是数据老是缓冲在 Batch 里迟迟不发送出去，那么岂不是你发送消息的延迟就会很高，<strong>导致高延迟问题</strong>。</p><p>比如说，一条消息进入了 Batch，但是要等待 5 秒钟 Batch 才凑满了 64KB，才能发送出去。那这条消息的延迟就是 5 秒钟。</p><p>所以需要在这里按照生产环境的发消息的速率，调节不同的 Batch 大小自己测试一下最终出去的吞吐量以及消息的 延迟，设置一个最合理的参数。</p><h4 id="1-2-1-5-5、要是一个-Batch-迟迟无法凑满怎么办？"><a href="#1-2-1-5-5、要是一个-Batch-迟迟无法凑满怎么办？" class="headerlink" title="1.2.1.5. 5、要是一个 Batch 迟迟无法凑满怎么办？"></a>1.2.1.5. 5、要是一个 Batch 迟迟无法凑满怎么办？</h4><p>要是一个 Batch 迟迟无法凑满，此时就需要引入另外一个参数了，“<strong>linger.ms</strong>”</p><p><strong>含义是一个 Batch 被创建之后，最多过多久，不管这个 Batch 有没有写满，都必须发送出去了</strong>。</p><p>给大家举个例子，比如说 batch.size 是 16kb，但是现在某个低峰时间段，发送消息很慢。</p><p>这就导致可能 Batch 被创建之后，陆陆续续有消息进来，但是迟迟无法凑够 16KB，难道此时就一直等着吗？</p><p>当然不是，假设你现在设置“linger.ms”是 50ms，那么只要这个 Batch 从创建开始到现在已经过了 50ms 了，哪怕他还没满 16KB，也要发送他出去了。</p><p>所以“linger.ms”决定了你的消息一旦写入一个 Batch，最多等待这么多时间，他一定会跟着 Batch 一起发送出去。</p><p>避免一个 Batch 迟迟凑不满，导致消息一直积压在内存里发送不出去的情况。<strong>这是一个很关键的参数。</strong></p><p>这个参数一般要非常慎重的来设置，要配合 batch.size 一起来设置。</p><p>举个例子，首先假设你的 Batch 是 32KB，那么你得估算一下，正常情况下，一般多久会凑够一个 Batch，比如正常来说可能 20ms 就会凑够一个 Batch。</p><p>那么你的 linger.ms 就可以设置为 25ms，也就是说，正常来说，大部分的 Batch 在 20ms 内都会凑满，但是你的 linger.ms 可以保证，哪怕遇到低峰时期，20ms 凑不满一个 Batch，还是会在 25ms 之后强制 Batch 发送出去。</p><p>如果要是你把 linger.ms 设置的太小了，比如说默认就是 0ms，或者你设置个 5ms，那可能导致你的 Batch 虽然设置了 32KB，但是经常是还没凑够 32KB 的数据，5ms 之后就直接强制 Batch 发送出去，这样也不太好其实，会导致你的 Batch 形同虚设，一直凑不满数据。</p><h4 id="1-2-1-6-6、最大请求大小"><a href="#1-2-1-6-6、最大请求大小" class="headerlink" title="1.2.1.6. 6、最大请求大小"></a>1.2.1.6. 6、最大请求大小</h4><p><strong>“max.request.size”这个参数决定了每次发送给 Kafka 服务器请求的最大大小</strong>，同时也会限制你一条消息的最大大小也不能超过这个参数设置的值，这个其实可以根据你自己的消息的大小来灵活的调整。</p><p>给大家举个例子，你们公司发送的消息都是那种大的报文消息，每条消息都是很多的数据，一条消息可能都要 20KB。</p><p>此时你的 batch.size 是不是就需要调节大一些？比如设置个 512KB？然后你的 buffer.memory 是不是要给的大一些？比如设置个 128MB？</p><p>只有这样，才能让你在大消息的场景下，还能使用 Batch 打包多条消息的机制。但是此时“max.request.size”是不是也得同步增加？</p><p>因为可能你的一个请求是很大的，默认他是 1MB，你是不是可以适当调大一些，比如调节到 5MB？</p><h4 id="1-2-1-7-7、重试机制"><a href="#1-2-1-7-7、重试机制" class="headerlink" title="1.2.1.7. 7、重试机制"></a>1.2.1.7. 7、重试机制</h4><p><strong>“retries”和“retries.backoff.ms”决定了重试机制，也就是如果一个请求失败了可以重试几次，每次重试的间隔是多少毫秒</strong>。</p><p>这个大家适当设置几次重试的机会，给一定的重试间隔即可，比如给 100ms 的重试间隔。</p><h4 id="1-2-1-8-8、持久化机制"><a href="#1-2-1-8-8、持久化机制" class="headerlink" title="1.2.1.8. 8、持久化机制"></a>1.2.1.8. 8、持久化机制</h4><p>“acks”参数决定了发送出去的消息要采用什么样的持久化策略，这个涉及到了很多其他的概念，大家可以参考之前专门为“acks”写过的一篇文章。</p><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw"></a></p><h2 id="1-3-三、消息中间件消费到的消息处理失败怎么办？"><a href="#1-3-三、消息中间件消费到的消息处理失败怎么办？" class="headerlink" title="1.3. 三、消息中间件消费到的消息处理失败怎么办？"></a>1.3. 三、消息中间件消费到的消息处理失败怎么办？</h2><p>消息中间件最核心的作用是：解耦、异步、削峰。</p><p>假如有如下的系统：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/8.jpg"></p><p>生产中存在这种情况：如果独立仓库系统或者第三方物流系统故障了，导致仓储系统消费到一条订单消息之后，尝试进行发货失败，也就是对这条消费到的消息处理失败。这种情况，怎么处理？</p><h4 id="1-3-1-死信队列的使用：处理失败的消息"><a href="#1-3-1-死信队列的使用：处理失败的消息" class="headerlink" title="1.3.1. 死信队列的使用：处理失败的消息"></a>1.3.1. 死信队列的使用：处理失败的消息</h4><p>一般生产环境中，如果你有丰富的架构设计经验，都会在使用 MQ 的时候设计两个队列：一个是 <strong>核心业务队列</strong>，一个是 <strong>死信队列</strong>。</p><p>核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。</p><p>面试被问到这个问题时，必须要结合你自己的业务实践经验来说。</p><p>比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。</p><p>此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！<strong>注意，这个步骤很重要。</strong></p><p>一旦标志这条消息处理失败了之后，MQ 就会把这条消息转入提前设置好的一个死信队列中。</p><p>然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。</p><p>然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。</p><p>一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。</p><p><strong>死信队列的使用，其实就是 MQ 在生产实践中非常重要的一环，也就是架构设计必须要考虑的</strong>。</p><p>整个过程，如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/9.jpg"></p><h2 id="1-4-四、Kafka-选举"><a href="#1-4-四、Kafka-选举" class="headerlink" title="1.4. 四、Kafka 选举"></a>1.4. 四、Kafka 选举</h2><p>Kafka 中的选举大致可以分为三大类：</p><ul><li>控制器的选举</li><li>分区 leader 的选举</li><li>消费者相关的选举</li></ul><h4 id="1-4-1-1、控制器选举"><a href="#1-4-1-1、控制器选举" class="headerlink" title="1.4.1. 1、控制器选举"></a>1.4.1. 1、控制器选举</h4><p>在 Kafka 集群中会有一个或多个 broker，其中有一个 broker 会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。</p><p>比如 <strong>当某个分区的 leader 副本出现故障时，由控制器负责为该分区选举新的 leader 副本</strong>。再比如当检测到某个分区的 ISR 集合发生变化时，由控制器负责通知所有 broker 更新其元数据信息。</p><p>Kafka Controller 的选举是依赖 Zookeeper 来实现的，在 Kafka 集群中那个 broker 能够成功创建&#x2F;controller 这个临时（Ephemeral）节点他就可以成为 Kafka Controller。</p><p>这里需要说明一下的是 Kafka Controller 的实现还是相当复杂的，涉及到各个方面的内容，如果你掌握了 Kafka Controller，你就掌握了 Kafka 的“半壁江山”。</p><h4 id="1-4-2-2、分区-leader-的选举"><a href="#1-4-2-2、分区-leader-的选举" class="headerlink" title="1.4.2. 2、分区 leader 的选举"></a>1.4.2. 2、分区 leader 的选举</h4><p>分区 leader 副本的选举 <strong>由 Kafka Controller 负责具体实施</strong>。</p><p>当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的 leader 副本下线，此时分区需要选举一个新的 leader 上线来对外提供服务）的时候都需要执行 leader 的选举动作。</p><p>基本思路是按照 AR 集合中副本的顺序查找第一个存活的副本，并且这个副本在 ISR 集合中。</p><p>一个分区的 AR 集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的 ISR 集合中副本的顺序可能会改变。</p><p>注意：这里是根据 AR 的顺序而不是 ISR 的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭&#x2F;开启某个集群中的 broker 来观察一下具体的变化。</p><p>还有一些情况也会发生分区 leader 的选举，比如当分区进行重分配（reassign）的时候也需要执行 leader 的选举动作。</p><p>这个思路比较简单：从重分配的 AR 列表中找到第一个存活的副本，且这个副本在目前的 ISR 列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为 leader 即可，AR 集合中的第一个副本即为优先副本。</p><p>还有一种情况就是当某节点被优雅地关闭（也就是执行 ControlledShutdown）时，位于这个节点上的 leader 副本都会下线，所以与此对应的分区需要执行 leader 的选举。</p><p>这里的具体思路为：从 AR 列表中找到第一个存活的副本，且这个副本在目前的 ISR 列表中，与此同时还要确保这个副本不处于正在被关闭的节点上。</p><h4 id="1-4-3-3、消费者相关的选择"><a href="#1-4-3-3、消费者相关的选择" class="headerlink" title="1.4.3. 3、消费者相关的选择"></a>1.4.3. 3、消费者相关的选择</h4><p>组协调器 GroupCoordinator 需要为消费组内的消费者选举出一个消费组的 leader，这个选举的算法也很简单，分两种情况分析。</p><ul><li><strong>如果消费组内还没有 leader，那么第一个加入消费组的消费者即为消费组的 leader</strong>。</li><li><strong>如果某一时刻 leader 消费者由于某些原因退出了消费组，那么会重新选举一个新的 leader，这个重新选举 leader 的过程又更“随意”了，相关代码如下</strong>：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//scala code.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> members = <span class="hljs-keyword">new</span> mutable.<span class="hljs-type">HashMap</span>[<span class="hljs-type">String</span>, <span class="hljs-type">MemberMetadata</span>]<br><span class="hljs-keyword">var</span> leaderId = members.keys.head<br></code></pre></td></tr></table></figure><p>解释一下这 2 行代码：在 GroupCoordinator 中消费者的信息是以 HashMap 的形式存储的，其中 key 为消费者的 member_id，而 value 是消费者相关的元数据信息。</p><p>leaderId 表示 leader 消费者的 member_id，它的取值为 HashMap 中的第一个键值对的 key，这种选举的方式基本上和随机无异。</p><p>总体上来说，消费组的 leader 选举过程是很随意的。</p><p>到这里就结束了吗？还有分区分配策略的选举呢。</p><p>或许你对此有点陌生，但是用过 Kafka 的同学或许对 partition.assignment.strategy（取值为 RangeAssignor、RoundRobinAssignor、StickyAssignor 等）这个参数并不陌生。</p><p>每个消费者都可以设置自己的分区分配策略，对消费组而言需要从各个消费者呈报上来的各个分配策略中选举一个彼此都“信服”的策略来进行整体上的分区分配。</p><p>这个分区分配的选举并非由 leader 消费者决定，而是根据消费组内的各个消费者投票来决定的。</p><p><strong>参考</strong>：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ"></a></p><h2 id="1-5-五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"><a href="#1-5-五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）" class="headerlink" title="1.5. 五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"></a>1.5. 五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）</h2><h3 id="1-5-1-面试官心理分析"><a href="#1-5-1-面试官心理分析" class="headerlink" title="1.5.1. 面试官心理分析"></a>1.5.1. 面试官心理分析</h3><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你 <strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p><h3 id="1-5-2-面试题剖析"><a href="#1-5-2-面试题剖析" class="headerlink" title="1.5.2. 面试题剖析"></a>1.5.2. 面试题剖析</h3><p>回答这个问题，首先大概说一说可能会有哪些重复消费的问题。</p><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，挑 Kafka 来举个例子，说说怎么重复消费吧。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（<strong>定时定期</strong>），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是，你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是 <strong>没来得及提交 offset，重启之后，少数消息会再次消费一次</strong>。</p><p>例如，数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&#x2F;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1&#x2F;2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/10.png"></p><p><strong>如何保证消息队列消费的幂等性</strong>？</p><p>回答这个问题需要结合业务思考，有如下几个思路：</p><ul><li>比如数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update 一下。</li><li>比如是写 Redis，那没问题了，因为每次都是 set，天然幂等性。</li><li>比如不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面 <strong>加一个全局唯一的 id</strong>，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，就别处理，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/11.png"></p><h2 id="1-6-六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"><a href="#1-6-六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）" class="headerlink" title="1.6. 六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"></a>1.6. 六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）</h2><h2 id="1-7-面试官心理分析"><a href="#1-7-面试官心理分析" class="headerlink" title="1.7. 面试官心理分析"></a>1.7. 面试官心理分析</h2><p>这个是肯定的，用 MQ 有个基本原则，就是 <strong>数据不能多一条，也不能少一条</strong>，不能多，就是前面说的 [重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中 <strong>绝对不会把计费消息给弄丢</strong>。</p><h2 id="1-8-面试题剖析"><a href="#1-8-面试题剖析" class="headerlink" title="1.8. 面试题剖析"></a>1.8. 面试题剖析</h2><p>数据的丢失问题，可能出现在 <strong>生产者、MQ、消费者</strong> 中，从 Kafka 来分析一下。</p><h3 id="1-8-1-Kafka"><a href="#1-8-1-Kafka" class="headerlink" title="1.8.1. Kafka"></a>1.8.1. Kafka</h3><h3 id="1-8-2-1、消费者丢失数据"><a href="#1-8-2-1、消费者丢失数据" class="headerlink" title="1.8.2. 1、消费者丢失数据"></a>1.8.2. 1、消费者丢失数据</h3><p>唯一可能导致消费者弄丢数据的情况，是消费到了这个消息，然后消费者那边 <strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>由于 Kafka 会自动提交 offset，那么只要 <strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是 <strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题是 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h3 id="1-8-3-2、Kafka-弄丢数据"><a href="#1-8-3-2、Kafka-弄丢数据" class="headerlink" title="1.8.3. 2、Kafka 弄丢数据"></a>1.8.3. 2、Kafka 弄丢数据</h3><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是 <strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是 <strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h3 id="1-8-4-3、生产者会不会弄丢数据？"><a href="#1-8-4-3、生产者会不会弄丢数据？" class="headerlink" title="1.8.4. 3、生产者会不会弄丢数据？"></a>1.8.4. 3、生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h2 id="1-9-七、如何保证消息的顺序性？"><a href="#1-9-七、如何保证消息的顺序性？" class="headerlink" title="1.9. 七、如何保证消息的顺序性？"></a>1.9. 七、如何保证消息的顺序性？</h2><p>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞 <strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/12.png"></p><h4 id="1-9-1-解决方案："><a href="#1-9-1-解决方案：" class="headerlink" title="1.9.1. 解决方案："></a>1.9.1. 解决方案：</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个 <strong>内存 queue</strong>，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/13.png"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io">Taylor Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/">https://taylorluo.github.io/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/Kafka/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://taylorluo.github.io" target="_blank">Taylor</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/timeline/">timeline</a></div><div class="post_share"><div class="social-share" data-image="https://unpkg.com/justlovesmile-img/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"><img class="prev-cover" src="https://picsum.photos/1920/1082" onerror='onerror=null,src="/null"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法-1、题目解析</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/12/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-5%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon/"><img class="next-cover" src="https://picsum.photos/1920/942" onerror='onerror=null,src="/null"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式专题-5、负载均衡-Ribbon</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/06/001-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-1%E3%80%81%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/" title="计算机基础-基本原理-1、相关名词"><img class="cover" src="https://picsum.photos/1920/952" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">计算机基础-基本原理-1、相关名词</div></div></a></div><div><a href="/2023/03/27/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/JDK-1%E3%80%81SPI/" title="框架源码专题-JDK-1、SPI"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover5.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-28</div><div class="title">框架源码专题-JDK-1、SPI</div></div></a></div><div><a href="/2023/03/18/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/MySQL-9%E3%80%81SQL%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/" title="框架源码专题-MySQL-9、SQL应用优化"><img class="cover" src="https://picsum.photos/1920/1086" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">框架源码专题-MySQL-9、SQL应用优化</div></div></a></div><div><a href="/2023/01/28/002-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B8%93%E9%A2%98/Spring-7%E3%80%81%E6%89%A9%E5%B1%95%E7%82%B9/" title="框架源码专题-Spring-7、扩展点"><img class="cover" src="https://picsum.photos/1920/992" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">框架源码专题-Spring-7、扩展点</div></div></a></div><div><a href="/2023/01/22/003-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-19%E3%80%81Queue/" title="并发编程专题-基础-19、Queue"><img class="cover" src="https://unpkg.com/justlovesmile-img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-23</div><div class="title">并发编程专题-基础-19、Queue</div></div></a></div><div><a href="/2023/03/08/006-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E4%B8%93%E9%A2%98-%E5%9F%BA%E7%A1%80-1%E3%80%81%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构实战专题-基础-1、架构演进"><img class="cover" src="https://picsum.photos/1920/1083" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">架构实战专题-基础-1、架构演进</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/index.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Taylor Luo</div><div class="author-info__description">人生海海 不忘初心</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">183</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Kafka-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-text">1. Kafka 知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%B8%80%E3%80%81%E8%AE%B2%E8%AE%B2-acks-%E5%8F%82%E6%95%B0%E5%AF%B9%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">1.1. 一、讲讲 acks 参数对消息持久化的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E7%9B%AE%E5%BD%95"><span class="toc-text">1.1.1. 目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-1-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">1.1.2. 1.写在前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%95%E6%9C%BA%E7%9A%84%E6%97%B6%E5%80%99%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F%EF%BC%88%E6%88%96%E8%80%85-kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%81%E6%88%96%E8%80%85-Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89"><span class="toc-text">1.1.3. 2.如何保证宕机的时候数据不丢失？（或者 kafka 如何保证高可用、或者 Kafka 如何保证高可用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-3-%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%90%8C%E6%AD%A5"><span class="toc-text">1.1.4. 3.多副本之间数据如何保证同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-4-ISR-%E5%88%B0%E5%BA%95%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-text">1.1.5. 4.ISR 到底指的是什么东西？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-5-acks-%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">1.1.6. 5.acks 参数的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-7-6-%E6%9C%80%E5%90%8E%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">1.1.7. 6.最后的思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BA%8C%E3%80%81Kafka-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98"><span class="toc-text">1.2. 二、Kafka 参数调优实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%9B%AE%E5%BD%95"><span class="toc-text">1.2.1. 目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-1-1%E3%80%81%E8%83%8C%E6%99%AF%E5%BC%95%E5%85%A5%EF%BC%9A%E5%BE%88%E5%A4%9A%E5%90%8C%E5%AD%A6%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84-kafka-%E5%8F%82%E6%95%B0"><span class="toc-text">1.2.1.1. 1、背景引入：很多同学看不懂的 kafka 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-2-2%E3%80%81%E4%B8%80%E6%AE%B5-Kafka-%E7%94%9F%E4%BA%A7%E7%AB%AF%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">1.2.1.2. 2、一段 Kafka 生产端的示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-3-3%E3%80%81%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">1.2.1.3. 3、内存缓冲的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-4-4%E3%80%81%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%E6%89%93%E5%8C%85%E4%B8%BA%E4%B8%80%E4%B8%AA-Batch-%E5%90%88%E9%80%82%EF%BC%9F"><span class="toc-text">1.2.1.4. 4、多少数据打包为一个 Batch 合适？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-5-5%E3%80%81%E8%A6%81%E6%98%AF%E4%B8%80%E4%B8%AA-Batch-%E8%BF%9F%E8%BF%9F%E6%97%A0%E6%B3%95%E5%87%91%E6%BB%A1%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">1.2.1.5. 5、要是一个 Batch 迟迟无法凑满怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-6-6%E3%80%81%E6%9C%80%E5%A4%A7%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%B0%8F"><span class="toc-text">1.2.1.6. 6、最大请求大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-7-7%E3%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2.1.7. 7、重试机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-8-8%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2.1.8. 8、持久化机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E8%B4%B9%E5%88%B0%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">1.3. 三、消息中间件消费到的消息处理失败怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-text">1.3.1. 死信队列的使用：处理失败的消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%9B%9B%E3%80%81Kafka-%E9%80%89%E4%B8%BE"><span class="toc-text">1.4. 四、Kafka 选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-1%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%89%E4%B8%BE"><span class="toc-text">1.4.1. 1、控制器选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-2%E3%80%81%E5%88%86%E5%8C%BA-leader-%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-text">1.4.2. 2、分区 leader 的选举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-3%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">1.4.3. 3、消费者相关的选择</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%89"><span class="toc-text">1.5. 五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BF%83%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">1.5.1. 面试官心理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90"><span class="toc-text">1.5.2. 面试题剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%85%AD%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%89"><span class="toc-text">1.6. 六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BF%83%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">1.7. 面试官心理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90"><span class="toc-text">1.8. 面试题剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-Kafka"><span class="toc-text">1.8.1. Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-1%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-text">1.8.2. 1、消费者丢失数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-3-2%E3%80%81Kafka-%E5%BC%84%E4%B8%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">1.8.3. 2、Kafka 弄丢数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-4-3%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BC%84%E4%B8%A2%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">1.8.4. 3、生产者会不会弄丢数据？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-text">1.9. 七、如何保证消息的顺序性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-1-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">1.9.1. 解决方案：</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题"><img src="https://picsum.photos/1920/1081" onerror='this.onerror=null,this.src="/null"' alt="无题"></a><div class="content"><a class="title" href="/2023/06/13/012-%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98/%E7%BB%8F%E9%AA%8C%E4%B8%93%E9%A2%98-%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F-2%E3%80%81%E9%A3%8E%E6%8E%A7%E4%B8%AD%E5%8F%B0/" title="无题">无题</a><time datetime="2023-06-13T23:32:43.044Z" title="发表于 2023-06-14 07:32:43">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪"><img src="https://picsum.photos/1920/962" onerror='this.onerror=null,this.src="/null"' alt="分布式专题-15、链路追踪"></a><div class="content"><a class="title" href="/2023/06/13/005-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98-15%E3%80%81%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" title="分布式专题-15、链路追踪">分布式专题-15、链路追踪</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航"><img src="https://picsum.photos/1920/992" onerror='this.onerror=null,this.src="/null"' alt="资源导航"></a><div class="content"><a class="title" href="/2023/06/13/013-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/" title="资源导航">资源导航</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总"><img src="https://picsum.photos/1920/972" onerror='this.onerror=null,this.src="/null"' alt="算法-0、汇总"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-0%E3%80%81%E6%B1%87%E6%80%BB/" title="算法-0、汇总">算法-0、汇总</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析"><img src="https://picsum.photos/1920/1082" onerror='this.onerror=null,this.src="/null"' alt="算法-1、题目解析"></a><div class="content"><a class="title" href="/2023/06/13/014-AI%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95-1%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/" title="算法-1、题目解析">算法-1、题目解析</a><time datetime="2023-06-13T16:00:00.000Z" title="发表于 2023-06-14 00:00:00">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://unpkg.com/justlovesmile-img/cover2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Taylor Luo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo-taylorluo.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="拼搏,自强,正直,自信" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>